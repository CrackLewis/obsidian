
## LijunChang-Efficient maximum k-plex computation

问题：maximum k-plex prob'

核心工作：
- 新的最大k-plex计算框架
- core-truss co-pruning（CTCP）算法：提取一个小规模子图
- BBMatrix算法：针对从输入图提取的密集子图进行分支限界，使用一阶和二阶信息进行upper-bounding和pruning

有关工作：P2右下
- 最大k-plex计算
- 最大k-plex枚举
- clique计算

*计算框架核心内容*：
- 通过CTCP从稀疏图中提取小规模子图
- 通过BBMatrix

## DeepSeek-Nukplex

### 概述

这篇论文提出了一种名为Nukplex的高效局部搜索算法，用于解决最大k-plex问题（MKPP）。以下是其核心要点：

**问题背景**
- **k-plex定义**：在图\( G=(V,E) \)中，一个k-plex子集\( S \subseteq V \)满足每个顶点在\( S \)中至少有\( |S| - k \)个邻居。MKPP的目标是找到规模最大的k-plex，属于NP难问题。
- **应用场景**：社交网络分析（如社区检测、反洗钱建模）等需要挖掘紧密子图的场景。

**算法创新**：
Nukplex算法结合以下三种新策略，显著提升搜索效率和解的质量：

1. **松弛有界配置检查策略（RBCC）**
- 改进传统配置检查（CC）策略，引入顶点频率信息，动态调整禁止顶点重新加入候选解的阈值。
- 通过随机采样和频率比较，减少对潜在优质顶点的误禁，增强搜索多样性。

2. **基于解信息的顶点选择策略**
- **当前解评分函数**（\( score_{cst} \)）：结合顶点在当前解中的邻接数（\( d_S(v) \)）及其外部扩展潜力（\( \overline{d_S}(v) \)），平衡即时收益与后续扩展能力。
- **历史最优解评分函数**（\( score_{lbs} \)）：利用历史局部最优解的邻接信息，优先选择频繁出现在高质量解中的顶点。
- 根据图密度（稀疏或稠密）动态调整交换操作中的顶点选择规则。

3. **基于核心的扰动策略**
- **解核心（Solution Core）**：从当前解中提取满足\( (k-1) \)-plex约束的更紧密子集，作为扰动的基础。
- **收缩-扩展机制**：通过移除饱和顶点缩小解规模，再基于概率选择新顶点扩展，避免搜索陷入局部最优。

**实验验证**：
- **基准测试**：在经典实例（DIMACS、BHOSLIB）和大规模稀疏图（SNAP、DIMACS10）上，Nukplex与主流启发式算法（DCCplex、KLS）及精确算法（KpLeX-Gap、DiseMKP）对比。
- **结果**：
  - 在484个经典实例中，Nukplex在480个实例上取得最优解，显著优于其他算法。
  - 对于大规模稀疏图，Nukplex在100秒内覆盖436个实例，优于精确算法（需1800秒）。
  - 消融实验表明，RBCC和核心扰动策略对性能提升贡献最大。

 **结论**：
Nukplex通过创新策略有效平衡了局部搜索的深度与广度，在解决MKPP时表现出更高的效率和稳定性。未来工作可扩展至其他紧密子图问题，并探索更多顶点属性以进一步优化算法。

### 松弛有界配置检查策略（RBCC）

**1. 什么是配置检查（Configuration Checking, CC）？**
在局部搜索算法中，我们通过不断调整候选解（例如添加、交换或移除顶点）来寻找更优的解。但可能会出现“循环”问题：算法反复添加和移除同一个顶点，导致搜索在原地打转，无法跳出局部最优。

**传统CC的作用**：  
当一个顶点被移除后，如果它的邻接状态（周围顶点的配置）未发生变化，则暂时禁止该顶点被重新加入候选解。这种“冷却期”通过一个标记数组（`conf`）实现：  
- `conf(v)=1`：允许顶点`v`被加入候选解。  
- `conf(v)=0`：暂时禁止顶点`v`被加入候选解。

**2. 传统CC的局限性**：
假设顶点`v`被频繁移除，其`conf`会被反复设为0。但若`v`本身是一个潜在优质顶点（例如与其他顶点连接紧密），过于严格的禁止可能导致算法错失探索机会，降低效率。

**3. RBCC的改进思想**：
RBCC在传统CC的基础上，引入两个关键机制：  
4. **顶点频率（Frequency）**：记录每个顶点被添加/移除的总次数，反映顶点的“活跃度”。  
5. **动态阈值调整**：根据频率信息，灵活调整顶点的禁止时长，避免长期误禁优质顶点。

**4. RBCC的具体规则**

**（1）初始化规则（RBCC Initial Rule）**
- 每个顶点`v`的`conf(v)`和`thred(v)`（禁止阈值）初始化为1。  
  - `thred(v)`：表示顶点`v`需要满足的最低允许条件。  
  - 例如，当`conf(v) ≥ thred(v)`时，`v`才能被加入候选解。

**（2）添加规则（RBCC Add Rule）**
- **操作**：当顶点`v`被加入候选解时，做两件事：  
  1. **更新邻居的阈值**：对`v`的每个邻居`v'`，增加其`thred(v')`和`conf(v')`（例如`thred(v') += 1`）。  
  2. **动态调整`v`的阈值**：  
     - 若`thred(v)`达到预设上限`ub_thre`（例如3）：  
       - **随机采样**：从图中随机选`t`个顶点，按频率降序排列，得到集合`FreqSet`。  
       - **频率比较**：若`v`的频率小于`FreqSet`中第`0.8t`个顶点的频率，说明`v`相对不活跃，将其`thred(v)`重置为0（快速解禁）；否则重置为1。

**（3）交换规则（RBCC Swap Rule）**
- **操作**：当顶点`u`被移除且`v`被加入候选解时，将`u`的`conf(u)`设为0，禁止其短期内被重新加入。

**（4）移除规则（RBCC Drop Rule）**
- **操作**：当顶点`u`被移除时，直接将其`conf(u)`设为0。

**5. RBCC如何“松弛”禁止条件？**：
通过**频率信息**和**动态阈值调整**，RBCC实现了以下平衡：  
- **避免循环**：通过`conf`禁止频繁被移除的顶点。  
- **灵活解禁**：当某个顶点被长期禁止（`thred(v)`达到上限），通过比较其频率与其他顶点的活跃度，决定是否提前解禁。  
  - **例子**：若顶点`v`被频繁操作，但其他顶点更活跃（频率更高），则`v`的禁止阈值会被降低，避免错失探索机会。

**6. 与传统策略（如BoundedCC）的区别**：
- **BoundedCC**：当`thred(v)`达到上限时，直接重置为1，可能导致优质顶点被反复禁止。 
- **RBCC**：结合频率信息，动态判断是否需要解禁，更智能地平衡搜索的广度与深度。

**7. 实际示例**：
假设图中顶点`A`被多次移除，其`thred(A)`已达到上限`ub_thre=3`：  
6. **随机采样**：选取5个顶点（`B, C, D, E, F`），按频率排序为`B(10), C(8), D(7), E(5), F(3)`。  
7. **比较频率**：`A`的频率为6，高于第4个顶点`E(5)`，说明`A`相对活跃。  
8. **调整阈值**：将`thred(A)`重置为1（而非0），适度延长禁止时间，避免干扰搜索。

**8. 总结**：
- **RBCC的核心**：通过频率记录和动态阈值，智能控制顶点的禁止时长，避免循环问题同时保留探索潜力。  
- **优势**：在保证解质量的前提下，显著提升搜索效率，尤其适用于复杂图结构。

通过RBCC，Nukplex算法能够更灵活地探索解空间，避免陷入局部最优，从而在最大k-plex问题中取得更好的性能。

### 基于解信息的顶点选择策略

在解决最大k-plex问题（MKPP）时，局部搜索算法的核心挑战是如何在每一步操作中**智能选择顶点**，既能快速提升当前解的质量，又能避免陷入局部最优。Nukplex算法提出了一种**基于解信息的顶点选择策略**，通过结合当前解的结构特征和历史搜索经验，动态调整顶点的优先级。以下是详细解析：

**1. 当前解信息评分函数（\( \text{score}_{cst}(v) \)）**

这一评分函数专注于**当前候选解的结构特性**，目标是选择能够**直接优化当前解**的顶点。

**核心指标**
- **\( d_S(v) \)**：顶点\( v \)在当前解\( S \)中的邻接数。  
  表示\( v \)与当前解中其他顶点的连接紧密程度。\( d_S(v) \)越大，\( v \)加入后对解的稳定性越有利。
- **\( \overline{d_S}(v) \)**：顶点\( v \)在解外部的邻接数（即\( \overline{d_S}(v) = deg(v) - d_S(v) \)）。  
  反映\( v \)的潜在扩展能力。若\( \overline{d_S}(v) \)较大，说明\( v \)与解外顶点连接多，后续可能吸引更多顶点加入。

**评分公式**

\[
\text{score}_{cst}(v) = d_S(v) \times \left( 1 + \frac{\rho \times \overline{d_S}(v)}{|V|} \right)
\]
- **参数\( \rho \)**：平衡\( d_S(v) \)和\( \overline{d_S}(v) \)的权重（通常取0.2）。  
  - 当\( \rho = 0 \)时，仅考虑当前邻接数\( d_S(v) \)，完全贪婪。  
  - 当\( \rho > 0 \)时，引入外部邻接数的影响，鼓励选择既有高内部连接、又有扩展潜力的顶点。
- **分母\( |V| \)**：标准化外部邻接数的权重，防止大图的\( \overline{d_S}(v) \)值过大导致偏向。

**示例**
假设当前解\( S \)有5个顶点，顶点\( v \)的\( d_S(v) = 4 \)，\( \overline{d_S}(v) = 3 \)，图中总顶点数\( |V|=100 \)，取\( \rho = 0.2 \)：  
\[
\text{score}_{cst}(v) = 4 \times \left( 1 + \frac{0.2 \times 3}{100} \right) = 4 \times 1.006 = 4.024
\]  
若另一顶点\( u \)的\( d_S(u) = 3 \)，\( \overline{d_S}(u) = 10 \)，则：  
\[
\text{score}_{cst}(u) = 3 \times \left( 1 + \frac{0.2 \times 10}{100} \right) = 3 \times 1.02 = 3.06
\]  
尽管\( u \)的扩展潜力更高，但\( v \)因更高的当前邻接数被优先选择。

**2. 历史最优解信息评分函数（\( \text{score}_{lbs}(v) \)）**

这一评分函数利用**历史局部最优解**的信息，目标是挖掘**高质量解的共同特征**。

**规则**
- **初始化**：所有顶点的\( \text{score}_{lbs}(v) \)初始化为1。  
- **更新**：每当算法找到一个局部最优解\( S_{\text{best}} \)，对每个顶点\( v \in V \)，更新：  
  \[
  \text{score}_{lbs}(v) += d_{S_{\text{best}}}(v)
  \]  
  即，顶点\( v \)在局部最优解中的邻接数会被累积到其历史评分中。

**逻辑**
- 频繁出现在高质量解中的顶点，其\( \text{score}_{lbs}(v) \)会逐渐升高。  
- 这类顶点可能构成解的核心结构，优先选择它们可以引导搜索向更优区域移动。

**示例**
假设算法在三次搜索中找到三个局部最优解：  
1. 解1：顶点\( v \)的邻接数\( d_{S_{\text{best}}}(v) = 4 \) → \( \text{score}_{lbs}(v) = 1 + 4 = 5 \)。  
2. 解2：\( d_{S_{\text{best}}}(v) = 3 \) → \( \text{score}_{lbs}(v) = 5 + 3 = 8 \)。  
3. 解3：\( d_{S_{\text{best}}}(v) = 5 \) → \( \text{score}_{lbs}(v) = 8 + 5 = 13 \)。  
最终，\( v \)因频繁参与高质量解而被优先选择。

---

**3. 动态调整交换规则的条件**
根据图的密度（稀疏或稠密），Nukplex在**交换操作（Swap）**中采用不同的选择策略：

**条件规则**
- **稠密图（\( \text{dens}(G) > \alpha \)**：选择\( \text{score}_{lbs}(v) \)最高的顶点。  
  - 稠密图结构复杂，历史经验更可靠，利用历史评分探索潜在优质区域。  
- **稀疏图（\( \text{dens}(G) \leq \alpha \)**：选择频率\( \text{freq}(v) \)最低的顶点。  
  - 稀疏图易陷入局部最优，选择较少被操作的顶点以增强多样性。

**参数\( \alpha \)**：通常设置为0.35，通过实验确定。

**示例**
- **稠密图场景**：  
  顶点\( v \)的\( \text{score}_{lbs}(v) = 10 \)，顶点\( u \)的\( \text{score}_{lbs}(u) = 8 \)，优先选择\( v \)。  
- **稀疏图场景**：  
  顶点\( v \)的\( \text{freq}(v) = 5 \)，顶点\( u \)的\( \text{freq}(u) = 20 \)，优先选择\( v \)。

**4. 实际应用流程**
假设当前处于**添加操作（Add）**和**交换操作（Swap）**阶段：

**添加操作**：  
   - 从候选集\( \text{ConstrAddSet}(S) \)中，选择\( \text{score}_{cst}(v) \)最高的顶点加入解。  
   - **目标**：直接提升解的大小和质量。
**交换操作**：  
   - 根据图密度选择策略：  
     - 若为稠密图，选择\( \text{score}_{lbs}(v) \)最高的顶点。  
     - 若为稀疏图，选择\( \text{freq}(v) \)最低的顶点。  
   - 移除一个与新增顶点不相连的旧顶点，保持解的k-plex性质。  
   - **目标**：通过替换顶点，跳出局部最优区域。

**5. 策略优势总结**
- **平衡即时与长期收益**：  
  \( \text{score}_{cst} \)关注当前解的结构优化，\( \text{score}_{lbs} \)利用历史经验引导全局搜索。  
- **动态适应性**：  
  根据图密度调整交换策略，灵活应对不同图结构的挑战。  
- **避免局部最优**：  
  在稀疏图中通过低频顶点探索新区域，在稠密图中依赖历史评分聚焦优质解。

**6. 实际案例演示**
**问题背景**：在社交网络图中寻找最大2-plex（每个顶点至少连接解中其他顶点数的\( |S| - 2 \)个）。

**步骤**：  
-  **初始化**：随机生成一个初始解\( S \)，计算各顶点的\( \text{score}_{cst} \)。  
-  **添加阶段**：选择\( \text{score}_{cst} \)最高的顶点\( v \)加入\( S \)，例如\( v \)的\( d_S(v) = 5 \)，\( \overline{d_S}(v) = 8 \)。  
-  **交换阶段（稀疏图）**：  
	-  检测到图密度为0.3（<0.35），选择\( \text{freq} \)最低的顶点\( u \)（假设\( \text{freq}(u) = 2 \)）。  
	-  移除一个与\( u \)不相连的旧顶点\( w \)，保持解的2-plex性质。  
-  **更新历史评分**：若新解成为局部最优，更新所有顶点的\( \text{score}_{lbs} \)。

**结果**：通过动态策略，算法逐步扩展解规模，同时避免循环和局部最优，最终找到更大k-plex。

**总结**
基于解信息的顶点选择策略通过**综合利用当前解结构、历史经验及图特征**，使Nukplex算法在复杂图数据中高效导航。这一策略的核心思想是**“立足当前，借鉴历史，因地制宜”**，在每一步操作中智能权衡，最终提升全局搜索效率和解的质量。

### 基于核心的扰动策略详解

在解决最大k-plex问题（MKPP）时，局部搜索算法常因陷入局部最优而停滞。**基于核心的扰动策略（Core-Based Perturbation Strategy）**通过“收缩-扩展”机制，在保留解核心结构的同时引入多样性，帮助算法跳出局部最优。以下是其核心原理与步骤：

**1. 核心概念**
- **解核心（Solution Core）**：  
  当前解\( S \)中满足以下条件的子集\( S_{\text{core}} \subseteq S \)：  
  \[
  \forall v \in S_{\text{core}}, \ |N(v) \cap S_{\text{core}}| > |S_{\text{core}}| - k
  \]  
  即，解核心是一个更紧密的\( (k-1) \)-plex结构，稳定性强于原解。
- **扰动目标**：  
  通过部分破坏当前解，引导搜索转向新区域，同时保留高质量部分（解核心），避免完全随机化导致的效率损失。

**2. 策略流程**
策略分为**收缩阶段**（Shrinking Phase）和**扩展阶段**（Expanding Phase）：

**步骤1：收缩阶段**
- **目标**：移除当前解中的饱和顶点，生成解核心\( S_{\text{core}} \)。  
  **饱和顶点**：邻接数恰好等于\( |S| - k \)的顶点，是解中的“脆弱点”。
- **操作**：  
  1. 初始化临时集合\( TempSet = \emptyset \)。  
  2. **循环移除**：  
     - 若当前解中存在饱和顶点（即\( C(S) \neq \emptyset \)），随机选择一个饱和顶点\( u \in C(S) \)。  
     - 将\( u \)从\( S \)中移除，并加入\( TempSet \)。  
     - 更新\( u \)的配置检查状态（根据RBCC的Drop规则：\( conf(u) = 0 \)）。  
  3. **终止条件**：当\( C(S) = \emptyset \)时，停止收缩。此时\( S \)即为解核心\( S_{\text{core}} \)。
- **示例**：  
  假设解\( S = \{A, B, C, D\} \)，其中\( A \)为饱和顶点（邻接数\( |S| - k = 2 \)）。移除\( A \)后，\( S = \{B, C, D\} \)，\( TempSet = \{A\} \)。

**步骤2：扩展阶段**
- **目标**：通过向解核心中添加顶点，生成扰动后的新解。  
  添加顶点时，混合选择**历史移除顶点**（\( AddSet \cap TempSet \)）和**新候选顶点**（\( AddSet \setminus TempSet \)）。
- **操作**：  
  1. **顶点选择规则**：  
     - 以概率\( p \)选择\( AddSet \cap TempSet \)中的顶点（如\( A \)）。  
     - 以概率\( 1-p \)选择\( AddSet \setminus TempSet \)中的顶点（如\( E \)）。  
  2. **添加顶点**：  
     - 将选中的顶点\( v \)加入\( S \)，并更新其配置检查状态（根据RBCC的Add规则）。  
  3. **终止条件**：当\( AddSet \cap TempSet \)或\( AddSet \setminus TempSet \)为空时，停止扩展。
- **参数\( p \)**：  
  控制对历史顶点的偏好（通常设为0.5）。较高\( p \)倾向于恢复旧顶点，较低\( p \)探索新顶点。
- **示例**：  
  - 若选择重新加入\( A \)，解恢复为\( \{B, C, D, A\} \)，但可能因结构变化引入新可能性。  
  - 若选择加入新顶点\( E \)，解变为\( \{B, C, D, E\} \)，开辟全新搜索方向。

**3. 策略优势**
- **保留高质量结构**：  
  通过解核心保留稳定部分，避免完全破坏当前解的质量。
- **平衡探索与利用**：  
  混合选择历史顶点和新顶点，既尝试恢复可能被误删的优质顶点，又探索新区域。
- **动态适应性**：  
  触发条件（如未改进步数达到阈值）确保仅在必要时扰动，减少无效操作。

**4. 实际案例演示**
**问题背景**：在社交网络图中寻找最大2-plex（每个顶点至少连接解中其他顶点数的\( |S| - 2 \)个）。

**步骤**：  
1. **初始解**：\( S = \{A, B, C, D\} \)，其中\( A \)为饱和顶点（邻接数=2）。  
2. **收缩阶段**：  
   - 移除\( A \)，解核心\( S_{\text{core}} = \{B, C, D\} \)，\( TempSet = \{A\} \)。  
3. **扩展阶段**：  
   - \( AddSet \cap TempSet = \{A\} \)，\( AddSet \setminus TempSet = \{E\} \)。  
   - 以\( p=0.5 \)的概率选择顶点：  
     - 若选择\( A \)，解恢复为\( \{B, C, D, A\} \)，但可能因结构重组发现更大解。  
     - 若选择\( E \)，解变为\( \{B, C, D, E\} \)，探索新结构。  
**结果**：通过扰动，算法可能发现包含\( E \)的更大k-plex，或优化原结构中的连接。

**5. 常见疑问解答**
- **如何保证扰动后的解仍是k-plex？**  
  在扩展阶段，仅允许加入满足\( AddSet \)条件的顶点（即加入后仍保持k-plex性质）。
- **扰动频率如何设置？**  
  论文中通过参数\( L \)（搜索深度）和未改进步数阈值（如\( k \times |S_{\text{best}}| \)）控制扰动触发频率。
- **解核心是否可能为空？**  
  若原解中所有顶点均为饱和顶点，收缩后解核心为空，此时需重新初始化解。

**6. 总结**
基于核心的扰动策略通过**“先收缩后扩展”**的机制，在保留解核心稳定性的基础上，引入多样性。其核心思想是：  
- **收缩阶段**：移除脆弱顶点，保留高质量核心。  
- **扩展阶段**：混合历史与新顶点，平衡探索与利用。  

这一策略使Nukplex算法在复杂图数据中高效跳出局部最优，显著提升解的质量和搜索效率。