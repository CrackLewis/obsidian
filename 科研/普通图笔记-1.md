
## 0-a survey of community search over big graphs

*community*: a group of vertices densely connected internally

community retrieval: find communities from large graphs

factors that retrieval solutions should satisfy: ^1a9310
- high efficiency, scalability, personalization, quality, and support dynamic graphs

*community search* (C.S.):
- goal: search high-quality comm.s in online manners based on queries

given a vtx $q\in G$, C.S. aims to find a community which contains $q$ and satisfies:
- connectivity: vtx.s in this comm. are connected
- cohesiveness (内聚性): vtx.s in the comm. are intensively linked to each other w.r.t. a *particular goodness metric* (特优度度量), the metric being defined by subgraph cohesiveness metrics such as:
	- $k$-core: largest possible $S\subseteq G$, in which $\forall v\in S, \deg(v)\ge k$
	- $k$-truss: largest possible $S\subseteq G$, in which $\forall e\in S$, e is contained by at least $k-2$ triangles within $S$ ^58148d
	- $k$-clique: a set of $k$ vtx.s in $G$ which forms a complete graph
	- $k$-ECC ($k$-edge-connected-component): a subgraph $S\subseteq G$ such that after removing any $k-1$ edges, it's still connected

*community detection* (C.D.):
- diff. with C.S.:
	- goals: C.S. searches comm.s based on queries, while C.D. detects all comm.s in graph
	- criteria: C.S. criteria are based on user-defined param.s, while C.D. uses the same global criterion
	- algorithms: C.S. soln.s are online, more efficient and scalable to big graphs, and can better satisfy the [[#^1a9310|factors above]]

C.S. solution classification: 
- five categories (four metrics and others)
- two groups: sol's on simple graphs; sol.s on attributed graphs (kw, loc, temporal, influence, profile)

P3/40

### sec02-preliminaries

- comm' cohesiveness metrics
- comparison of metrics' cohesiveness and computational efficiency

consider a simple undirected graph $G(V,E)$, in which $n=|V|,m=|E|$, and the degree of vtx $v$ is $\deg_G(v)$.

*k-core*: given graph $G$ and $k\ge 0$, the k-core of $G$, denoted by $H_k$, is the largest subgraph of $G$, such that $\forall v\in H_k, \deg_{H_k}(v)\ge k$. $k$ is called the order of $H_k$.
- if $i<j$, then $H_j\subseteq H_i$.
- $H_k$ might not be connected

*core number*: given $v\in V$, its core number, denoted by $\text{core}_G[v]$, is the highest order of a $k$-core that contains $v$.

![[Pasted image 20241019154452.png]]

e.g.: $H_3\subset H_2\subset H_1$. $H_1$ contains all vtx's except J. $\text{core}_G [E]$ is 2.

说人话：
- k-core描述一个图最小度数不低于k的最大子图。
- 注意这里的k-core是全局概念，因此不一定是连通图。
- 顶点的core数指的是最大的k，使得它包含在图的k-core中。

k-truss is defined based on triangles. A triangle in $G$ is a cycle of length 3 with all three vtx's on the cycle in $V$.

*support*: given $G(V,E)$, the support of an edge $e=(u,v)\in E$, denoted by $\text{sup}(e,G)$, is defined as $|\{\triangle_{uvw} : u,v,w\in V\}|$.

*k-truss*: given $G$ and $k\ge 2$, the $k$-truss of $G$, denoted by $J_k$, is the largest subgraph of $G$, such that $\forall e\in J_k$, $\text{sup}(e,J_k)\ge k-2$.
- k-truss might not be connected, just like k-core

*truss number*: given $G$, the truss number of $e\in G$, denoted by $\tau(e)$, is the largest $k$ such that $e\in J_k$.

e.g. (the graph above):
- $J_4=\{A,B,C,D\}$, $J_3=\{A,B,C,D,E\}$, $J_2=G$. 
- $\tau((A,B))=\tau((A,C))=4$, $\tau((A,E))=3$, $\tau((D,F))=2$.

说人话：
- 图中某边的“支撑”是指它包含在多少个长度为3的环路中。
- 图的k-truss（truss译为“束”）是指由图中所有“支撑”不低于(k-2)的边导出的子图。显然k最低为2。
- 图中某边的truss数是指包含它的k最大的k-truss。

*k-clique*: given $k\ge 2$, k-clique is a complete graph with $k$ vtx.s
- any edge is 2-clique, any triangle is 3-clique
- a $k$-clique has $\dfrac{k(k-1)}{2}$ edges

e.g. (the graph above): $\{A,B,C,D\}$ is a $4$-truss

说人话：图的k-clique（clique译为“团”）是指图中所有k个结点完全子图组成的子图。

*edge connectivity* (局部边连通度): given $G(V,E)$ and $u,v\in V$, the connectivity between $u,v$, denoted by $\lambda(u,v)$, is the minimum number of edges whose removal disconnects $u$ and $v$.

*graph connectivity* (全局边连通度): given $G(V,E)$, the connectivity of $G$, denoted by $\lambda(G)$, is the minimum number of edges whose removal disconnects $G$. ^2690c9
- $\lambda(G)=\min_{u,v\in V} \lambda(u,v)$

*k-ECC*: given $G(V,E)$, a subgraph $G'$ of $G$ is a k-edge-connected component, or a k-ECC, if $\lambda(G')\ge k$ and the connectivity of any super-graph of $G'$ in $G$ is less than $k$.

e.g. (still the graph above): $\{A,B,C,D\}$ is a 3-ECC of $G$. $\{A,B,C,D,E\}$ is a 2-ECC of $G$.

说人话：
- 两个顶点的局部边连通度：图中最少移除多少条边会让这两点之间无通路。
- 图的全局边连通度：图中任意两个顶点边连通度的最小值。
- 图的k-ECC指的是：所有子图中，全局边连通度不小于k的最大子图

*comparison*:
- cohesiveness: k-clique>k-truss>k-ECC>k-core
	- inclusionship (包含关系): less operator means inclusion
		- k-clique\<k-truss, each CC of k-truss\<a k-ECC
		- k-truss\<(k-1)-core, k-ECC\<k-core
- computational efficiency:
	- k-core: time $O(m+n)$, space $O(m+n)$
	- k-ECC: time $O(h\cdot l\cdot m)$, space $O(m+n)$
	- k-truss: time $O(m^{1.5})$, space $O(m+n)$
	- k-clique: time $O(c(G)\cdot \sum_{l=2}^{k-1} N^l+k\cdot N^k)$, space $O(m+n)$
		- $c(G)$ is the maximum core number of vertices, $N^l$ is the number of $l$-cliques
	- comparison: k-core>k-ECC>k-truss>k-clique
- suggestion:
	- k-clique and k-truss for small graphs, k-core and k-ECC for larger graphs
	- k-truss is preferable to graphs with higher clustering coeff'nt and could be decomposed into more triangles, but not to special graphs with less or no triangles (such as trees, long loops)

说人话：
- k-clique/k-truss/k-ECC/k-core：从左到右稠密度递减，求解效率递增
- k-truss由于需要依赖图结构，所以可能不适用于环路较少的图（如：层次结构图）

### sec03-k-core based CS

undirected graphs, directed graphs, attributed graphs (keyword-based, location-based, temporal, influence value-based, profile-based)

#### k-core on undirected graphs

*size-unbounded k-core CS on undirected graph*:

> [!problem] Prob. 1
> Given graph $G=(V,E)$, query $Q\subseteq V$ and a goodness function $f$, return a subgraph $H(V_H,E_H)$ of $G$ such that:
> - $Q\subseteq V_H$
> - $H$ is connected
> - $f(H)$ is maximized among all feasible choices for $H$

$f$ shall be larger if the graph is denser. a typical one is $f(H)=\min_{\forall v\in H} \deg_H(v)$, the *minimun degree* of $H$. other metrics include average degree and density, etc.

*Solution 1*: a global search algorithm (named *Global* specifically): 
- let $G_0=G$
- for all integer $1\le t<n$, $G_t$ is $G_{t-1}$ removing vtx's with the lowest degree
- if one of vtx's in $Q$ has the lowest deg in $G_{T-1}$, then stops at $T$-th step
- $H_i'$ are all connected component that contains $Q$ in $G_{T-1}$
- $H=\arg\max\{f(H_i')\}$
 
time $O(n+m)$, space $O(n+m)$, $H$ is a connected k-core

*Solution 2*: a local search algorithm (named *Local* specifically):
- assumes $Q=\{q\}$ has only one vtx, and expand search space from it
- generates a candidate vtx set $C$ in the search space:
	- selects a local optimal vtx $v$ using a specific *heuristic criterion*, a typical one being the vtx which leads to the largest increment of $f(C)$, another being the vtx which connects to most vtx's in $C$
	- add $v$ to $C$
	- iterate the two steps until $C$ satisfies the constraint of $H$
- find an optimal community $H$ from $C$

Global vs Local: suppose Global returns $H$ and Local returns $H'$:
- $f(H)=f(H'), H'\subseteq H$
- Local and Global has the same time complexity, but Local is usually more efficient

*Solution 3*: an index-based algorithm
- propose an index structure called *ShellStruct*, which organizes all connected k-cores in an offline manner
- *ShellStruct* is a tree-like structure built based on k-core nesting:
	- for any $1\le k\le k_{\max}$, $k$-core is a subgraph of a $(k-1)$-core
	- ShellStruct has $k$ levels, with nodes in $k$-th level corresponding to the $k$-core
	- $1$-core level is the root, and any node in the $k$-th level is a connected component of the $k$-core
	- the parent of a $k$-th level node is the $(k-1)$-core component it resides in
- index construction algorithm: time $O(m\cdot\alpha (n))$, where $\alpha(n)$ is the reverse Ackermann function which satisfies $\alpha(n)\le 5$ for all practical $n$.
- query algorithm: the $k$-core is the lowest common ancestor of all vtx's in $Q$. time $O(|H_V|)$.

a variant of Prob. 1, which allows less-connected vtx's to be involved:

> [!problem] Prob. 2
> Given $G(V,E)$, query vtx $q\in V$, integer $k\ge 0$, return a subgraph $H(V_H,E_H)$ of $G$, such that:
> - $q\in V_H$.
> - $H$ is connected.
> - for each $v\in V_H$, $\deg_H(v)\ge k$.

e.g. 

![[Pasted image 20241019154452.png]]

if this graph is $G$, then the $H$ from Prob.1 is $\{A,B,C,D\}$, while the $H$ from Prob.2 when $k=2,q=A$ is $\{A,B,C,D,E\}$.

*size-bounded k-core CS on undirected graph*:

in real applications, outputs are often required to be less than a size upperbound

drawback of Prob.1 and its sln's: it may return a large enough graph to breach the upperbound, even if we use *Local* sln'. 

another variant of Prob.1 but this time it's size-bounded:

> [!problem] Prob. 3
> Given $G(V,E)$, query vtx's $Q\subseteq V$, size constraint $k>0$, a goodness func $f$, return a subgraph $H(V_H,E_H)$ of $G$, such that:
> - $Q\subseteq V_H$
> - $H$ is connected
> - $|V_H|\le k$
> - $f(H)$ is maximized among all feasible choices of $H$

this is an NP-hard prob', meaning an exact algo' takes exponential time cost. but some heuristic algo's can achieve reasonable efficiency.

another variant of Prob. 1 to reduce vtx's:

> [!problem] Prob. 4
> Given $G(V,E)$, query vtx's $Q\subseteq V$, a minimum-deg-based func $f$. Let $H^*$ be the subgraph returned by Prob.1's *Global* sln'. Find a subgraph $H$ of $G$, such that:
> - $Q\subseteq V_H$, $H$ is conn'd
> - $f(H^*)=f(H)$
> - the size of $H$ is the smallest possible

Prob. 4 is also NP-hard, as it's more complex than Steiner tree prob', but an algo' is proposed to provide a "good enough" sol' with two steps:
- reduce $|H^*|$ as much as possible using local greedy search, making it smaller in size but still qualified for Prob.1
- find a subgraph of $H^*$ by adopting the above approximation algo' for the Steiner tree prob'

*Steiner tree problem*: given $G(V,E)$ and vtx's $Q\subseteq V$, return a graph $H(V_H,E_H)$ such that $Q\subseteq V_H$ and $|E_H|$ is minimized.
- above approx' algo': out of my brain capacity, see this [blog](https://zhuanlan.zhihu.com/p/684571642)

#### k-core on directed graphs

for directed graph $G(V,E)$, all edges are directed. extra def's:
- in-degree of $v$ is denoted by $\deg_G^{in}(v)$ and out-degree is denoted by $\deg_{G}^{out}(v)$.
- min in-deg of $G$ is denoted by $\delta_{in}(G)$, and min out-deg is denoted by $\lambda_{out}(G)$

![[Pasted image 20241020201750.png]]

an obvious sol' to CS on drct' graphs is to *ignore directions* and transfer it to CS on undrct' graphs. def:

*(k, l)-core*: given drct' graph $G(V,E)$, and integers $k\ge 0,l\ge 0$, the (k-l)-core of $G$ is the maximum subgraph $C$ of $G$ such that $\delta_{in}(C)\ge k$ and $\delta_{out}(C)\ge l$.

based on it Prob.5 is issued (named *CSD*):

> [!problem] Prob. 5
> Given a drct' graph $G(V,E)$, integers $k> 0,l> 0$, and a query vtx $q\in V$, return a connected subgraph $G_q\subseteq G$, such that:
> - $q\in G_q$
> - $\forall v\in G_q$, $\delta_{in}(G_q)\ge k$ and $\delta_{out}(G_q)\ge l$.

e.g. in fig. (b), $\{A,B,C\}$ is a 2-core of $G$.

![[Pasted image 20241020201750.png]]

a sol' to *CSD* similar to *Global* in undrct' graph CS:
- peel vtx's until the remaining satisfies the constraints
- time $O(m+n)$, might be inefficient for large graphs
- index-based optimization:
	- perform D-core decompositions first, calculating all (k,l)-cores and lay them out in a table
	- answer the query using the table index
	- overall space cost could be $O(m)$ using key observation

P9/40

#### k-core on keyword-based attributed graphs

kwbag' = keyword-based attributed graph

a *keyword-based attributed graph* $G$ is an undrct' graph $G$, whose vtx's are associated with a set of *keywords*, denoted by $W(v)$. ^ad767a

![[Pasted image 20241020211600.png]]

Prob. 6 (namely *ACQ*):

> [!problem] Prob. 6
> Given an kwbag' $G(V,E)$, int' $k>0$, vtx $q\in V$, and a set of kw's $S\subseteq W(q)$. Return a set $H$ of subgraphs of $G$, such that for all $G_q\in H$, the following properties hold:
> - connectivity: $q\in G_q$, and $G_q$ is conn'd
> - structure cohesiveness: $\forall v\in G_q$, $\deg_{G_q}(v)\ge k$
> - keyword cohesiveness: $L(G_q,S)=\bigcap_{v\in G_q} (W(v)\cap S)$ is maximal, which marks the common kw. within $G_q$

e.g. in fig(a) above, if $q=A,k=2,S=\{w,x,y\}$, then output of Prob.6 is all subsets of  $\{A,C,D\}$, indicating that they share the kw' $x,y$.

each $G_q$ is called an *attributed community* (A.C.) of $q$, and $L(G_q,S)$ is the *AC-label* of $G_q$. 

two outstanding features of ACQ:
- ease of interpretation: AC contains tightly conn'd vtx's with similar contexts
- personalization: by specifying $S$, user can control AC's semantics

a sol' to ACQ:
- steps:
	- all non-empty subsets of $S$ are enumerated
	- for each subset $S_i$ ($1\le i\le 2^l-1$), check whether there is a subgraph satisfying the first two properties (conn'ty, structure coh'ness)
	- output the subgraphs having the most shared kw's
- *anti-monotonicity property* (反单调性): given $S$, if it appears in every vtx' of an AC, then all of $S'\subseteq S$ appears in them too, so a lot of subsets $S_i$ can be pruned

*CL-tree*: an index proposed for organizing the vtx' kw' data hierarchically
- the structure is like ShellStruct, but for each node $p$, an inverted list is maintained to store all kw' appearing in the vtx' of $p$
- space cost $O(\hat{l}\cdot n)$, where $\hat{l}=\sum_{v\in G} |W(v)|/|V|$ denotes the average kw' count each vtx' has
- time cost $O(\alpha(n)\cdot m)$

e.g. fig(b) presents the CL-tree index of $G$ in fig(a)

![[Pasted image 20241021135902.png]]

#### k-core on location-based attributed graphs

a *location-based attributed graph* (基于位置的属性图), a.k.a. *geo-social network*, is an undrct' graph $G(V,E)$. for each vtx' $v\in V$, it has a location position $(v.x,v.y)$, denoting its positions along the $x,y$-axis respectively.

e.g. a simple geo-social network

![[Pasted image 20241021141056.png]]

three kinds of CS on geo-soc' nw' studied:
- *spatial-aware community* (SAC) search
- *radius-bounded k-core* (RB-k-core) search
- *geo-social group queries* with minimum acquaintance constraints (GSGQ)
- comparison:
	- all adopt k-core model, all require comm' to be spatially cohesive
	- spatial cohesiveness criteria differ: SAC uses smallest minimum covering circle (MCC), RB-k-core uses radius-fixed covering circle, and GSGQ uses center-fixed rectangles or circles

*SAC search*:

*minimum covering circle* (MCC, 最小覆盖圆): given a set $S$ of vtx's with loc's, the MCC of $S$ is the spatial circle containing all the vtx's in $S$ with the smallest radius

SAC search can be desc'd as Prob.7:

> [!problem] Prob. 7
> Given a geo-social nw' $G(V,E)$, int' $k>0$, and a vtx' $q\in V$, return a subgraph $G_q\subseteq G$, and the following properties hold:
> - connectivity: $q\in G_q$, $G_q$ is conn'd
> - structure cohesiveness: $\forall v\in G_q$, $\deg_{G_q}(v)\ge k$
> - spatial cohesiveness: the MCC of vtx's in $G_q$ has the smallest radius

the first two prop' forms a feasible sol', the third one forms the optimal sol', denoted by $\Psi$ (MCC radius denoted by $r_{opt}$). 

e.g. 

![[Pasted image 20241021141056.png]]

for $q=Q,k=2$, two subgraphs $\{Q,A,B\}$, $\{Q,C,D\}$ satisfies first two prop's. but the former $r=\sqrt{13}/2$, the latter $r=3/2$, so $\Psi=\{Q,C,D\}$.

the exact sol' time is $O(m\times n^3)$, which is impractical in real app's

approximation ratio: how many times the result circle radius is larger than $r_{opt}$

*AppInc*: an approx' algo' to solve Prob.7
- for given $q,k$, returns the feasible sol' in a circ' $O(q,\delta)$ (centers in $q$ and the radius is $\delta$). for fig' above, it returns $\{Q,A,B\}$, $\delta=2$.
- $\delta$ is approx'ed thru' binary search

*AppAcc*: 
- AppInc $\delta$ is around $(2+\epsilon)r_{opt}$. AppAcc aims to optimize $\delta$ further, reducing it to lower than $2r_{opt}$
- locate the area containing $\Psi$'s center first, then approx' the center by splitting area into grids, and find an approx' sol' using grids finally

trade-off between approx' ratio & effn'

*RB-k-core search*:

as defined in Prob.8:

> [!problem] Prob. 8
> Given a geo-social nw' $G(V,E)$, $k>0$, a radius $r>0$, and a vtx' $q\in V$, return all the subgraphs $G_q\subseteq G$, and the following properties hold:
> - connectivity: $q\in G_q$, $G_q$ is conn'd
> - structure cohesiveness: $\forall v\in G_q$, $\deg_{G_q}(v)\ge k$.
> - spatial cohesiveness: the MCC of vtx's in $G_q$ has a radius $r'\le r$.
> - maximality constraint: there exists no other subgraph $G_q'$ satisfying prop's above and $G_q\subset G_q'$

three sol's to RB-k-core search:
- *TriV*: a triple-vtx'-based algo' based on observations that three vtx's can determine a circle
	- propose to generate all candidate circles containing $q$, and compute the maximum k-core for subgraphs contained in the candidate circles with $r'\le r$
	- time $O(mn^3)$, $m$ denotes the time to verify each circle
- *BinV*: an optimization to TriV
	- only circles with $r'=r$ and containing $q$ are generated
	- for each pair of vtx's, at most 2 circles are generated, so time can be optim'd to $O(mn^2)$
- *RotC*: a rotating-circ'-based algo' to reuse the intermediate computation results in finding RB-k-cores
	- fix each vtx' $v\in V$ as a pole, and generate circ's in a rotating way so the computation cost is shared among adjacent circ's
	- some pruning techniques to terminate invalid circ's

P11/40

*geo-social group queries with minimum acquaintance constraint* (GSGQ):

as defined in Prob. 9:

> [!problem] Prob. 9
> Given a geo-social nw' $G(V,E)$, a vtx' $q\in V$, int' $k>0$, and a spatial constraint $\Lambda$. return a subgraph $G_q\subseteq G$, and the following constraints hold:
> - connectivity: $q\in G_q$, $G_q$ is conn'd
> - structure cohesiveness: $\forall v\in G_q$, $\deg_{G_q}(v)\ge k$
> - spatial cohesiveness: $G_q$ satisfies constraint $\Lambda$
> - maximality constraint: no other subgraph $G_q'$ exist to satisfy prop's above and $G_q\subset G_q'$.

spatial constraint $\Lambda$ could be one of the three following:
- a spatial rectangle for containing $G_q$
- a circ' centered in $q$ with radius $r\le r_k$, $r_k$ denoting the distance from $q$ to its $k$-th nearest vtx' in $G_q$ ($G_q$ might have more than $(k+1)$ vtx's)
- a circ' satisfying the previous constraint and $G_q$ contains exactly $(k+1)$ vtx's

using *R-tree index*, Prob.9 satisfying different $\Lambda$ could be solved:
- first one only: $O(n+m)$
- second one only: $O(n(n+m))$
- second+third: $O(C_k^{n-1} (m+n))$

social-aware R-trees (*SaR-tree*) index:
- incorporates both vtx's spatial and social locations
- built based on the concept of core bounding rectanle (*CBR*), which projects the minimum degree constraint on the spatial layer
	- CBR of vtx $v$ is a rectangle containing $v$, inside which any vtx' group with $v$ doesn't satisfy the minimum degree constraint
- SaR-tree vs R-tree:
	- each entry of SaR-tree refers to a set of CBRs and a minimum bounding rectangle (*MBR*)
		- CBR bounds vtx's from social perspective, while MBR bound 'em from spatial perspective
	- SaR-tree can gain power for both social- and spatial-based pruning
- *SaR\*-tree*: a variant which optim' the group of spatial obj's to minimize the disk I/O cost

#### k-core on temporal graphs

a *temporal graph* (时态图) is an undrct' graph $G(V,E)$. each edge $e\in E$ is a triplet $e=(u,v,t)$, where $u,v$ are vtx's in $V$ and $t$ is the interaction time btwn' $u,v$.

the projected graph $G_p$ over the time interval $[t_s,t_e]$ is def'd as $G_p=(V,E,[t_s,t_e])$, where $V=V(E)$, $E=\{(u,v)|(u,v,t)\in E(G), t\in[t_s,t_e]\}$. 

e.g. 

![[Pasted image 20241022125314.png]]

def's:

*maximal (θ-k)-persistent-core interval* (最大(θ-k)-持续核心间隔): given a temporal graph $G=(V,E)$ and param' $\theta>0,k>0$, an interval $[t_s,t_e]$ with $t_e-t_s\ge \theta$ is called a maximal (θ-k)-persistent-core interval for $G$ iff the following two cond's hold:
- for any $t\in [t_s,t_e-\theta]$, the projected graph of $G$ over $[t,t+\theta]$ is a connected k-core.
- there is no super-interval of $[t_s,t_e]$ such that the previous cond' hold.

说人话：让时态图在任何$\theta$时间内投影达到k-core要求的一个最长时间段，区间超了就达不到k-core要求了

*core persistence* (核心持久度): let $T=\{[t_{s_1},t_{e_1}],[t_{s_2},t_{e_2}],\ldots,[t_{s_r},t_{e_r}]\}$ be the set of all maximal $(\theta,k)$-persistent-core intervals of $G$. the core persistence of $G$ with param' $\theta,k$, denoted by $F(\theta,k,G)$ is def'd as:
$$
F(\theta,k,G)=\left\{\begin{matrix}
\sum_{i=1}^r (t_{e_i}-t_{s_i}) - (r-1)\theta, & if\ T\neq\varnothing, \\
0, & otherwise.
\end{matrix}\right.
$$

说人话：一个时态图可能有多个时段的投影都满足k-core性质。这些时段的溢出总和即为core persistence.

*(θ,τ)-persistent k-core* ((θ-τ)-持久的k-core): given a temporal graph $G$ and param's $\theta,\tau,k$, a (θ-τ)-persistent k-core is an induced temporal subgraph $C=(V_C,E_C)$ meeting the following prop's:
- persistent-core property: $F(\theta,k,C)\ge \tau$.
- maximal property: there doesn't exist an induced temporal subgraph $C'$ that contains $C$ and also satisfies the persistent-core prop'

CS on temporal graphs can be def'd as the *persistent community search* prob' as Prob.10:

> [!problem] Prob. 10
> Given a temporal graph $G$ and param's $\theta,\tau,k$, find the largest $(\theta,\tau)$-persistent k-core in $G$.

e.g.

![[Pasted image 20241022125314.png]]

assume $\theta=3,k=2$:
- there's no maximal $(3,2)$-persistent-core interval for $G$.
- there is a maximal $(3,2)$-persistent-core interval $[1,5]$ for $C=\{v_1,v_2,v_3\}$.
- let $\tau=4$, then $\{v_1,v_2,v_3\}$ is a $(3,4)$-persistent 2-core.

这块没咋懂（P12左下，建议重读）

Prob.10 is NP-hard, so a prune-and-search approach is proposed:
- pruning phase: temporal graph reduction algo' which decomposes the whole time span of the temporal graph into meta-intervals
- searching phase: a branch-and-bound algo' with several pruning rules which finds the maximum $(\theta,\tau)$-persistent k-core

#### k-core on influence value-based attributed graphs

##### single-dimensional influential CS

an influential CS prob': 
- given an undrct' graph $G(V,E)$, each vtx' $v\in V$ is assoc'd with a weight $w_v$ indicating the influence of $v$.
- without loss of generality, it's assumed that $\forall 1\le i,j\le n,i\neq j, w_i\neq w_j$.

def's:

*influence value of a subgraph* (子图影响值): given an undrct' graph $G(V,E)$ and an induced subgraph $H(V_H,E_H)$ of $G$. the influence value of $H$ denoted by $f(H)$ is:
$$
f(H)=\min_{u\in V_H}\{w_u\}
$$

*k-influential community* (k-影响社区): given an undrct' graph $G(V,E)$ and int' $k$, a $k$-influential community is an induced subgraph $H^k=(V_H^k,E_H^k)$ of $G$ that meets all the following constraints:
- conn'ty: $H^k$ is conn'd
- cohesiveness: each vtx' $u$ in $H^k$ has deg' at least $k$
- maximal structure: no other idc'd subgraph $\overset{\sim}{H}$ containing $H^k$ exists to satisfy the previous constraints

*non-contained k-influential community*: given $G(V,E)$ and $k$, a non-contained k-influential comm'ty $H^k=(V_H^k,E_H^k)$ is a k-influential comm'ty that meets:
- non-containment: $H^k$ can't contain a k-influential comm'ty $\overset{\_}{H^k}$ such that $f(\overset{\_}{H^k})>f(H^k)$. 

e.g. 

![[Pasted image 20241022190112.png]]

suppose $k=2$:
- $\{v_{12},v_{13},v_{14},v_{15}\}$ is a 2-influential comm'ty with influence value 12
- $\{v_{12},v_{14},v_{15}\}$ is NOT any influential comm'ty
- $\{v_3,v_4,v_5\}$, $\{v_8,v_9,v_{11}\}$ and $\{v_{13},v_{14},v_{15}\}$ are non-contained 2-influential comm'ties
- $\{v_{12},v_{13},v_{14},v_{15}\}$ is NOT a non-contained 2-influential comm'ty

*top-r k-influential CS problem* (desc'd in Prob.11):

> [!problem] Prob. 11
> Given $G(V,E)$ and param's $k,r$, find the top-$r$ $k$-influential comm's with the highest influence value.

*top-r non-contained k-influential CS problem* (desc'd in Prob.12):

> [!problem] Prob. 12
> Given $G(V,E)$ and param's $k,r$, find the top-r non-contained k-influential comm'ties with the highest influence value.

Prob.11 and Prob.12 sol's:
- online search algo's:
	- an online algo': remove a k-influential comm'ty in each iteration (the comm'ty contains the vtx' having the lowest influence in $G$). the last $r$ iterations yield the top-$r$ k-influential comm'ties
		- if after removing $u$, the whole conn'd component $u$ resides in is removed, then the component is a non-contained $k$-influential comm'ty
		- time and space are both $O(n+m)$
	- a backward search algo': add vtx's with largest influence to a vtx set $C$ in each iteration. the top-$r$ yielded $C$ are the top-$r$ k-influential comm'ties
		- if after inserting $u$, subgraph induced by $C$ is k-core, then $C$ is a k-influential comm'ty
	- a local search algo': keeps vtx's with $w_v\ge \tau$ only and denote the induced subgraph as $G_{\ge \tau}$. if $G_{\ge\tau}$ has at least $r$ k-influential comm'ties, then they are the query result. the goal is to find a small enough $\tau^*$ for $G_{\ge\tau^*}$ to contain at least $r$ k-infl'l comm'ties
	- 说人话：第一个是逐个移除最低的影响社区，取倒数$r$个；第二个是逐个移除最高的影响社区，取前$r$个；第三个是二分法调整影响度阈值，每轮只有大于阈值的结点活动，取最小的满足至少$r$个k-影响社区的阈值
- an index-based algo': 
	- *ICP-index*: a tree structure based on the observation that k-infl'l comm'ties include each other, i.e., (k-1)-infl'l comm'ties include k-infl'l ones
	- compression: the k-infl'l comm'ties only store vtx's not included in sub-k infl'l ones. ICP-index nodes form a link from leaves to root
	- construction time $O(m^{1.5})$, space $O(m+n)$
	- e.g. ![[Pasted image 20241023181914.png]] ICP-index for the graph above
	- 说人话：似乎是根据k-影响社区的包含关系建立层次索引？（没懂，建议重读）
- an I/O-efficient algo': assumes all vtx's are in main memory. it computes k-infl'l comm'ties following descending order of weights
	- sorts all edges' weight $w_e=\min(w_u,w_v)$ in descending order externally
	- loads some edges in memory, computes k-infl'l comm'ties among them and removes edges in these comm'ties
	- fill some new edges and iterate the prev' step, until there're $r$ comm'ties
	- 说人话：定义边权为两个端点最小权值。先对所有边按边权进行降序外部排序，然后依次载入内存，在内存中反复选择$r$个k-影响社区
- *Center-core CS*: utilizes k-core to qualify dense structures for comm'ties, and coreness to evaluate the vtx' influence
	- *center-core community*: given query vtx' $q$, it's a conn'd component of the maximal k-core containing $q$ and the coreness of vtx's in the comm'ty is no less than $q$
	- P14/40 upper-right

##### multi-dimensional influential CS

*multi-valued graph*: graph $G(V,E,X)$ where each vtx $v$ is assoc'd with a $d$-dimensional vector $X_v=(x_1^v,x_2^v,\ldots,x_d^v)$, where $x_i^v\in \mathbb{R}$.

the value of a graph on the i-th dimension:
$$
f_i(G)=\min_{v\in V(G)} \{x_i^v\}
$$

it's supposed that $\forall\ 1\le i\le d, u,v\in V, u\neq v\Rightarrow x_i^v\neq x_i^u$.

def's:

multi-value subgraph *domination*: let $H(V_H,E_H), H'(V_{H'},E_{H'})$ be two subgraphs of a multi-valued graph $G$. if:
- $\forall 1\le i\le d$, $f_i(H)\le f_i(H')$ holds
- there exists $f_i(H)<f_i(H')$ for a certain $i$
then $H'$ dominates $H$, denoted by $H\prec H'$.

说人话：
- 多值图的属性值是其所有顶点在该属性值的最小值。
- 多值图A对B的支配是指：A的所有属性值严格不小于B，且至少一个属性大于B。

*skyline community*: given a multi-valued graph $G(V,E,X)$ and an int' $k$. a skyline community with a param' $k$ is an induced subgraph $H(V_H,E_H,X_H)$ of $G$ such that the following prop's hold:
- cohesive prop': $H$ is a conn'd k-core
- skyline prop': there doesn't exist an induced subgraph $H'$ of $G$ such that $H'$ is a conn'd k-core and $H\prec H'$
- maximal prop': there doesn't exist an induced subgraph $H'$ of $G$ such that:
	- $H'$ is a conn'd k-core, and $H'$ contains $H$
	- $\forall 1\le i\le d\Rightarrow f_i(H')=f_i(H)$

说人话：天际线社区（？）是一些导出子图，它们不被任何其他子图支配，也不被任何天际线社区包含

skyline CS prob' is desc'd as Prob.13:

> [!problem] Prob. 13
> Given a multi-valued graph $G(V,E,X)$ and int' $k$. find all skyline comm'ties from $G$ with param' $k$.
> (formal def' in P15/40 mid-left)

e.g.

![[Pasted image 20241023212547.png]]

suppose $k=2$, then:
- $H_1=\{v_1,v_2,v_3\}$ is a skyline comm'ty with $f(H_1)=(8,14,3)$
- $H_2=\{v_2,v_4,v_5,v_6\}$ is also a skyline comm'ty
- $H_3=\{v_4,v_5,v_6\}$ is NOT a skyline comm'ty bcz it's contained in $H_2$
- $H_4=\{v_2,v_3,v_4,v_5,v_6\}$ is NOT a skyline comm'ty bcz it's dominated by $H_1,H_2$

*SkylineComm2D*: an effn't algo' for $d=2$ scenario:
- time $O(s(m+n))$, space $O(m+n+s)$, where $s$ denotes the answer size
- for $d>2$: a space partition algo'
	- features: can progressively output skyline comm'ties; worst-case time complexity depends on answer size

#### k-core on profile-based attributed graphs

profile-based attributed graph (*profiled graph*): an undrct' graph $G(V,E)$ with each vtx' $v$ assoc'd with a *profile*. the profile of $v$ is a set of kw's $T(v)$ arranged in a hierarchical manner called a P-tree.
- typical attr's: users' affiliation, expertise, loc's, etc.

说人话：网上的翻译比较诡异：（轮廓图？）是一个每个结点都对应一棵

e.g. each vtx' below is assoc'd with a tree rooting at $r$.

![[Pasted image 20241024083135.png]]

*maximal common subtree* of a profile graph: given a profiled graph $G$, the maximum common subtree of $G$, denoted by $M(G)$, holds the prop's:
- $\forall v\in G, M(G)\subseteq T(v)$
- there exists no other common subtree $M'(G)$ such that $M(G)\subseteq M'(G)$

说人话：“轮廓图”的最大公共子树是所有结点“轮廓”的子集。

profiled community search (*PCS*) can be def'd as Prob.14:

> [!problem] Prob. 14
> Given a profiled graph $G(V,E)$, int' $k$, query node $q\in G$. find a set $S$  of graphs, such that $\forall G_q\in S$, the following prop's hold:
> - conn'ty: $G_q$ is conn'd and contains $q$.
> - structure cohesiveness: $\forall v\in G_q$, $\deg_{G_q}(v)\ge k$.
> - profile cohesiveness: no other $G_q'\subseteq G_q$ exists to satisfy the above two constraints, such that $M(G_q)\subseteq M(G_q')$
> - maximal structure: no other subgraph $G_q'$ exists to satisfy the above prop's, such that $G_q\subset G_q'$ and $M(G_q)=M(G_q')$.

说人话：图里找一系列包含查询节点的子图，要求它们是尽可能小、同时覆盖关键字尽可能多的k-core（以至于：如果其子集是k-core，则其不可能包含覆盖更多关键字）

each set $G_q$ in the result is called a *profiled community* (PC). e.g.
- in the graph above, $\{B,C,D\},\{A,D,E\}$ are two profiled comm'ties

![[Pasted image 20241024111429.png]]

Prob.14 (PCS) is technically challenging, bcz subtree numbers are exponentially large
- anti-monotonicity property
- CP-tree index: organizes all graph vtx's and their P-trees into a compact tree structure, thus enabling the development of two fast PC discovery algo's

#### discussions

- simple graphs: 
	- undrct' graphs / drct' graphs
- attributed graphs:
	- kw'-based/loc'-based/temporal/infl'-based/profiled graphs
	- common idea: 
		- take both link relationship & attributes into consideration
		- have online and index-based sol's. latter is faster but incurs offline computation and space cost

### sec04-k-truss based CS

see [[#^58148d]] for k-truss def'.

- triangle-conn'd truss comm'ty
- closest truss comm'ty
- attr'-driven truss comm'ty
- weighted truss comm'ty

#### k-truss on simple graphs

k-truss's disconnectivity prob': the k-truss of a graph might not be conn'd and sufficient enough to def' a cohesive and meaningful comm'ty

*triangle connectivity*: 
- given two triangles $\triangle_1,\triangle_2$ in $G(V,E)$, they are *adjacent* if they share a common edge
- given two edges $e_1,e_2\in E$, $e_1,e_2$ are *triangle-connected* if they:
	- either belong to the same triangle
	- or are reachable from each other thru' a series of adjacent triangles

说人话：
- k-truss不保证是连通图，因此需要更强的连通标准
- “三角连通性”：
	- 两个三角若有公共边，则为相邻三角
	- 两条边若在同一三角、或一组相邻三角形内，则它们是“三角连通”的

triangle-conn'd truss comm'ty search (*TTC* search) is def'd as Prob.15:

> [!problem] Prob. 15
> Given an undrct' simple graph $G(V,E)$, query vtx' $q\in V$, int' $k\ge 2$. Return all subgraphs $H\subseteq G$ satisfying the following prop's:
> - structure cohesiveness: $H$ contains $q$, $\forall e\in E(H),\text{sup}(e,H)\ge k-2$.
> - triangle conn'ty: $\forall e_1,e_2\in E(H)$, $e_1,e_2$ are triangle-conn'd.
> - maximal subgraph: $H$ is the maximal subgraph of $G$ satisfying the prev' 2 prop's.

truss-based comm'ties have some interesting features:
- one vtx can be included in multiple truss-based comm'ties.
- a k-truss-based comm'ty is also (k-1)-edge-conn'd.
- the diameter of a k-truss-based comm'ty $H$ is no larger than $\left\lfloor\frac{2|V(H)|-2}{k}\right\rfloor$, with smaller diameter indicating better cohesiveness.
- truss-based comm'ties are strongly decomposable (强可分解的) for analyzing large-scale networks at different levels of granularity (粒度)

sol's to Prob.15:
- an online search algo': applies the truss decomposition on $G$
	- start with edges conn'd to $q$: check the trussness of edges $(q,v)\in E(G)$. pick those with $\tau((q,v))\ge k$ and collect the edges triangle-conn'd with them
	- check the collected edges' trussness, and collect new edges like prev' step, in a BFS manner, until all k-truss comm'ties are formed
	- could incur a lot of wasteful edge access, thus being inefficient
- TCP-index-based search algo':
	- triangle connectivity-preserving index (*TCP-index*): a tree-shape index preserving truss number and triangle adjacency relationships, and support linear-time k-truss comm'ty query
		- construction: 
			- each vtx $x$ assoc' with a TCP-index $T_x$. $T_x$ is the maximum spanning forest of $G_x$, where $G_x$ denotes the induced subgraph of $G$ by vtx set of $x$'s neighbors
			- for each edge $(y,z)$ in $G_x$, its weight $w(x,y)=\min(\tau((x,y)),\tau((x,z)),\tau((y,z)))$. only when $k\le w(y,z)$ can $\triangle_{xyz}$ appear in $G_x$
	- query processing algo':
		- e.g.![[Pasted image 20241024210627.png]]
		- assume that 5-truss comm'ties containing $q$ is being queried. TCP-index of $q$ denoted by $T_q$ is as follows:![[Pasted image 20241025105456.png]]
		- the algo' retrieves 5-truss vtx's from $T_p$, performs the reverse operations on the TCP-index for them, and gets the complete 5-truss comm'ties
		- TCP-index construction time $O(\sum_{(u,v)\in E}\min\{\deg_G(u),\deg_G(v)\}$, space $O(m)$
	- EquiTruss-index-based search algo':
		- *k-truss equivalence*: given $e_1,e_2\in E(G)$, they are k-truss equivalent iff :
			- $\tau(e_1)=\tau(e_2)=k$
			- $e_1,e_2$ are triangle-conn'd via a series of triangles in a k-truss
		- EquiTruss index: a summarized graph $H=(V_H,E_H)$ constructed based on k-truss equivalence, where each vtx in $H$ represents a k-truss equivalence class (a group of k-truss equivalent edges), and each edge in $H$ represents a triangle-conn'ty between two classes
			- more succinct (简练的) and space-effn't than TCP-index
			- ![[Pasted image 20241025153451.png]]
		- algo': find triangle-conn'd comm'ties containing $q$ directly on the index, instead of $G$
			- find all vtx's in EquiTruss-index $H$ containing $q$, then BFS-traverse in $H$ and explore vtx' $E^*\in V_H$ with $\tau(E^*)\ge k$. after BFS, output all vtx's in $H$ containing $q$

说人话：
- 问题15（truss社区搜索）：给定查询结点，检索图中包含查询结点的所有k-truss最大连通子图，要求每个子图内部任意两边满足三角连通性。
- 在线算法：在原图上跑BFS，从与查询结点相连的边开始搜索，搜索时加入与当前边同属一个三角形的新边，所有被搜索的边组成答案。效率偏低
- 三角连通性保持索引（TCP-index）搜索：
	- TCP-index计算：计算原图中每条边的truss数（包含在多少个三角环路），以truss数为每条边的权值；对每个结点$v$，计算其所有邻居导出子图的最大生成树，该最大生成树即为结点$v$的TCP-index
	- 搜索过程：设查询节点为$q$，在其TCP-index中取边权不低于$k$的导出子图，即为所有符合条件的k-truss社区
- k-truss等价性索引（EquiTruss-index）搜索：
	- k-truss等价性是指：两条边truss数是否相等，是否三角连通
	- EquiTruss索引：，由一个超结点表示一组k-truss等价的边及其导出子图；每一条超边表示两组k-truss等价边之间“三角连通”，形成一个超图，即为EquiTruss索引
	- 搜索：在超图上跑BFS，找所有包含查询结点$q$的超结点

#### closest truss CS

triangle conn'ty:
- power: can find overlapping comm'ties effn'tly
- weakness: may fail to discover any comm'ty for multiple query vtx's due to struct reqr's of triangle conn'ty constraint

closest truss community search (*CTC* search) can be desc'd as Prob.16:

> [!problem] Prob. 16
> Given a graph $G$ and a set of query vtx's $Q$. Return a subgraph $H\subseteq G$ as a closest truss comm'ty (CTC), satisfying the following 2 prop's:
> - connected k-truss: $H$ contains $Q$ and a conn'd k-truss with the largest $k$, i.e., $Q\subseteq H$ and $\forall e\in E(H)$, $\text{sup}(e,H)\ge k-2$.
> - smallest diameter: $H$ is a subgraph of smallest diameter satisfying Prop.1.

the second prop' can solve the "free rider effect" issue: a scenario when vtx's far away from query vtx's and irrelevant to them are included

Prob.16 is unfortunately NP-hard, and even hard to approx' with factor-2. but a simple but effective greedy algo' is proposed:
- steps:
	- given a graph $G$ and query vtx's $Q$, find a maximal conn'd k-truss denoted by $G_0$, containing $Q$ and having the largest trussness
	- iteratively remove vtx's far away from query vtx's, while maintaining truss of the remaining subgraph at $k$
- the answer is a 2-approx' to CTC
- improvements:
	- bulk deletion: remove vtx's far away from query vtx's, sacrificing approx' ratio for better effn'cy
	- local exploration: 
		- form a Steiner tree connecting all query vtx's, and then expand it to a k-truss by involving query vtx's' neighborhood
		- remove the furthest vtx's from the k-truss to reduce the diameter

说人话：
- 三角连通的truss社区搜索有一个问题：如果有多个查询结点，三角连通性标准过于严格，可能无法返回任何社区
- 最近truss社区搜索（问题16）：给定一个图和查询结点集合，要求找一个包含所有查询结点的、半径最小的k-truss子图
- 问题16是NP-难问题。贪心能找到一个好一些（但不是最好）的解：
	- 流程：先找一个包含所有查询结点的最大k-truss，然后在确保truss值不降的情况下，逐个移除离查询结点最远的结点
	- 优化：先取包含查询结点集的Steiner树，然后通过访问树上结点将其扩充至k-truss，再后移除稍远的结点

#### k-truss on keyword-based attributed graphs

see [[#^ad767a]] for kw-based attr' graph def'

attribute-driven truss comm'ty (*ATC*) model:
- *(k,d)-truss*: every edge is contained by at least $(k-2)$ triangles, and communication cost btwn' $H$'s vtx's and query vtx's is no greater than $d$
	- higher $k$ means stronger cohesiveness, lower $d$ means higher proximity
- attribute score function: denoted by $f(H,W_q)$ for comm'ty $H$ and query attrib's $W_q$, measures goodness of an attributed comm'ty w.r.t. attrib' coverage and correlation (相关性)
	- def': $f(H,W_q)=\sum_{w\in W_q} \dfrac{\text{score}(H,w)^2}{|V(H)|}$, where $\text{score}(H,w)=|V_w\cap V(H)|$ is the number of vtx's covering query attrib' $w$
	- prop's: 
		- the more query attrib's covered by some vtx's of $H$, the higher score
		- the more vtx's containing attrib' $w\in W_q$, the higher the contrib' of $w$ toward the overall score
		- the more vtx's of $H$ irrelevant to the query, the lower the score; the more query attrib's a comm'ty has that are shared by more of its vtx's, the higher its score

ATC search prob' is def'd as Prob.17:

> [!problem] Prob. 17
> Given $G$, a query $Q=(V_q,W_q)$, and two numbers $k,d$. Return an attrib'ed truss comm'ty (ATC) $H$, satisfying:
> - $H$ is a (k,d)-truss containing $V_q$.
> - $H$ has the maximum attrib' score $f(H,W_q)$ among all subgraphs satisfying the prev' prop'.

Prob.17 is also NP-hard. 

sol' to Prob.17: a greedy algorithmic framework for finding an ATC in a top-down search manner
- steps:
	- find the maximal (k,d)-truss of original graph $G$ as a candidate
	- iteratively remove vtx's with the smallest "attrib' margin gains" from the candidate while maintaining the remaining as a (k,d)-truss, until no longer possible
	- return a (k,d)-truss with the maximum attrib' score among all generated candidates
- improvements:
	- attrib'd truss index (*ATindex*): consists of both structural and attrib' trussness, maintaining known graph structure and attrib' info, thus can quickly identify a good candidate of (k,d)-truss
	- local exploration for effn'ly detecting small neighborhood subgraph around query vtx's, which tends to be densely conn'd with query attrib's

说人话：
- 属性驱动的truss社区模型（ATC模型）：
	- (k,d)-truss社区：社区既满足k-truss，又满足社区中结点到任意查询结点$v\in V_q$距离不超过d
	- 属性评分函数：对于社区$H$和查询属性集$W_q$，属性评分函数$f(H,W_q)$衡量属性在社区中的覆盖度以及与社区的相关性
		- 定义：每个属性在社区内出现次数的平方和除以社区规模
- ATC搜索（问题17）：给定图$G$和查询结点集$V_q$、查询属性集$W_q$和参数$k,d$，返回包含$V_q$的、属性评分函数最大的(k,d)-truss
- 问题17的解决方案：自上而下贪心策略
	- 步骤：首先找到原图的所有最大(k,d)-truss，并移除属性贡献较小的结点
	- 优化：ATindex

#### k-truss on weight-based attributed graphs

weighted truss community (*WTC*): given an undrct' weighted graph $G=(V,E,W)$ and an int' $k>0$, a weighted k-truss comm'ty is an induced subgraph $H\subseteq G$, and the following prop's hold:
- connectivity: $\forall e_1,e_2\in E(H)$, $e_1,e_2$ are triangle-conn'd in $H$
- cohesiveness: $\forall e\in E(H)$, $\text{sup}_{H}(e)\ge k-2$
- maximal structure: $H$ is a maximal induced subgraph satisfying the prev' 2 prop's

comm'ty weight of a WTC $H$: $w(H)=\min_{e\in E(H)} w(e)$

WTC search is def'd as Prob.18:

> [!problem] Prob. 18
> Given an undrct' weighted graph $G(V,E,W)$ and param's $k,r$, find the top-$r$ weighted k-truss comm'ties $H$ with the largest weights $w(H)$.

sol' to Prob.18 based on KEP-index:
- *KEP-index*: an index structure built opon the observation that all comm'ties can be organized into a tree-shaped structure. 
- indexes all pre-computed weighted k-truss comm'ties in a tree-shaped structure, so WTC search can be done in the linear time w.r.t. answer size

说人话：
- 带权重的truss社区（WTC）：带边权的最大k-truss。注意定义没有对边权做限制
- WTC搜索（问题18）：给定truss数$k$，在带权图中找权重前$r$大的WTC。
- 解决方案：KEP-index，基于k-truss之间相互嵌套的观察

#### discussions on k-truss methods

two groups on k-truss-based CS:
- computing k-truss comm'ty
- find closest comm'ties

two comm'ty models: 
- triangle-conn'd model: suitable for one single query vtx' to discover all overlapping comm'ties containing it
- closest model: suitable to discover one closest comm'ty containing all query vtx's
- conn'ty metrics strength: triangle-conn'ty\<closest model

two types of algo's: online & index-based

### sec05-k-clique based CS

#### k-clique and its variants

*γ-quasi-k-clique*: a graph with $k$ vtx's and at least $\left\lfloor \gamma \frac{k(k-1)}{2}\right\rfloor$ edges, where $0\le \gamma\le 1$.
- when $\gamma=1$, the corrsp' γ-quasi-k-clique is a k-clique.

*k-plex*: a graph $G(V,E)$ is a k-plex, if for each vtx' $v\in V$, $v$ has at least $|V|-k$ neighbors in $G$, where $1\le k\le |V|$.
- when $k=1$, the k-plex is a $|V|$-clique.
- finding a k-plex for int' $k$ is NP-hard

*kr-clique*: given a graph $G$ and two int's $k,r$, a kr-clique $S$ is an induced subgraph of $G$ such that:
- prop's:
	- the number of vtx's in $S$ is at least $k$
	- any two vtx's in $S$ can reach each other within $r$ hops
- when $r=1$, kr-clique is a k-clique.
- finding a kr-clique is NP-hard

说人话：k-clique的紧密度要求有些严格，所以有3种松弛方案
- γ-quasi-k-clique：对边数放宽限制，要求子团密度不低于$\gamma$
- k-plex：对邻居数放开限制。但注意实际上是k越小，k-plex越密集：1-plex即为k-clique。
- kr-clique：放宽跳数限制。朴素k-clique的跳数是1，而kr-clique允许跳数不超过r。

#### k-clique based CS

- overlapping comm'ty detection -> k-clique component
- CS algo' based on relaxation of k-clique component
- densest k-clique comm'ty search

##### k-clique-based community

in real life networks are characterized by overlapping comm'ties, such as school, hobbies, families, etc.

*k-clique component*: let $C$ denote a conn'd component in the k-clique graph $G$, then a k-clique component is the union of all k-cliques represented by vtx's in $C$.

an effn't k-clique component detection algo': 
- identify all maximal cliques
- enumerate comm'ties by carrying out a standard component analysis of the clique overlap matrix

说人话：
- 现实生活中的社区往往高度重叠
- k-子团分量：一个连通分量所有结点所在k-子团的并集
- k-子团分量检测算法：通过对子团重叠矩阵进行标准分量分析，实现对所有社区的枚举

##### k-clique based CS details

two shortcomings in k-clique comm'ty model:
- overwhelming numbers of k-clique comm'ties in real life graphs
- k-clique constraint and adjacency def's are not flexible in practice

online community search (*OCS*) problem: relaxes k-clique component constraints to simplify the prob'. *(α,γ)-OCS* is formally def'd as Prob.19:

> [!problem] Prob. 19
> Given an undrct' simple graph $G(V,E)$, a query vtx' $q\in V$, int' $k,\alpha\le k-1$, and a real value $0\le \gamma\le 1$. Find all $\gamma$-quasi-k-clique components containing query vtx' $q$ and satisfying $\alpha$-adjacency.

remarks:
- if $\alpha=k-1$ and $\gamma=1$ hold, then it's k-clique CS
- (α,γ)-OCS is \#P-complete
- the density (edges div' by max-possible-edges) of each comm'ty in (α,γ)-OCS is at least $2\max\{0,\min\{f(1),f(\alpha)\}\}$, where $f(x)=\gamma C_k^2 C_{k-x}^2 /x$.

exact sol':
- a naive algo': enumerate all γ-quasi-k-cliques containing $q$ and then compute components based on $\alpha$-adjacency
- propose a computing framework to avoid enumerating cliques not belonging to any valid comm'ties
- optimize the searching cost by maintaining visit status of each clique

approx sol':
- only enumerates unvisited cliques which contains at least one vtx not contained by any existing comm'ty
- a heuristic strat' is proposed to choose a vtx sequence such that resulting clique sequence is short

说人话：

k-clique在现实图中要求太严，而且小规模子团巨多，标准不够灵活

(α,γ)-在线社区搜索（OCS）问题（问题19）：给定简单无向图$G$、查询结点$q$、子团规模$k$、团内结点临近度$\alpha$和密度参数$\gamma$，找图内所有的γ-quasi-k-clique，要求：
- 所有团必须包含$q$。
- 团内所有结点至少有$\alpha$个邻居。

解法：
- 精确解法：先找所有包含$q$的γ-quasi-k-clique，再从其中筛选。
	- 剪枝：维护每个子团的访问状态
- 估计解法：与精确解法相比，只枚举那些未完全访问的子团
	- 启发式策略：调整枚举结点顺序，降低子团序列长度

##### densest clique percolation CS

densest clique percolation community (*DCPC*) search (最密子团渗流社区搜索) problem is desc'd as Prob.20:

> [!problem] Prob. 20
> Given an undrct' graph $G(V,E)$ and a set of query vtx's $Q\subseteq V$, the problem of densest clique percolation comm'ty (DCPC) search is to find the k-clique component with the maximum $k$ value that contains all vtx's in $Q$.

a baseline sol':
- steps: 
	- start from the largest possible $k$ value and check if there is a KCPC by applying k-clique component detection
	- if there is no KCPC detected, then reduce $k$ by 1, until a KCPC is detected

an index-based approach:
- observing that a k-clique component can be treated as a union of maximal cliques
- *clique adjacency tree*: identifies the k-clique components for a given $k$ value
- *ordered adjacency tree*: assures that only the subtrees of query vtx's are explored
- *DCPC-index*: support effn't DCPC queries

说人话：

最密子团渗流社区搜索？问题（DCPC，问题20）：给定一个简单无向图$G$、查询点集$Q$，求一个包含$Q$的k-clique分量，并使得$k$最大。

解法：
- 基准解法：将k从大到小枚举，选择最大的能检验出合法k-clique分量的$k$
- 基于索引的解法：
	- 观察到一个k-clique分量是若干个极大子团的并集
	- 子团临近树、有序临近树、DCPC-index、etc.

#### k-plex based CS

social group query (*SGQ*) is desc'd as Prob.21: 

> [!problem] Prob. 21
> Given a simple undrct' graph $G(V,E)$, an activity initiator $q\in V$, three int's $p,s,k$. Return a set $F$ of vtx's from $G$ such that the following prop's hold:
> - $|F|=p$
> - the length of the min' distance path btwn' $v,q$ (denoted by $d_{v,q}$) is at most $s$.
> - each vtx' $v\in F$ is allowed to share no edges with at most $k$ other vtx's in $F$.
> - the total social dist' $\sum_{v\in F} d_{v,q}$ is minimized.

Prob.21 is NP-hard.

*SGSelect*: a sol' to Prob.21
- retract a subgraph $F_1$ of $G$ using the 2nd constraint
- iterate vtx's starting from $q$:
	- keep track of a set $F_2\subseteq F_1$ of vtx's satisfying the 4th constraint in each iteration
	- stops when $|F_2|$ hits $q$
- pruning criteria: boosts iteration process
	- prioritize vtx's that might significantly increase the total social distance
	- prune vtx's which would not contrib' to the answer

social-temporal group query (*STGQ*):
- each vtx in $G$ is called an attendee in the activity. SGQ aims to find $p$ attendees closest to the initiator $q$ and inter-conn'd enough
- STGQ takes each attendee $v$'s available time $[t_v,t_v+\delta_v]$ into consideration, aiming to find $p$ attendees satisfying SGQ's constraints and available in $[t,t+\delta]$

说人话：

社交分组查询（SGQ，问题21）：给定一个无向简单图$G$、查询结点$q$、答案规模$p$、直径上界$s$、紧密度参数$k$。返回一个简单图的子结点集$F$使其满足：
- $F$的规模必须是$p$。
- $F$内任一结点到$q$的最短路不超过$s$（全图半径不超过$s$）。
- $F$是一个k-plex。
- $F$内所有结点到$q$的总距离最小。

问题21的一个解决方案：先根据半径限制圈出子图，再在子图中BFS遍历所有符合紧密度要求的结点，直到总结点数达到$p$。
- 剪枝策略：提前判断哪些结点不会构成答案

社交-时态分组查询（STGQ）：考虑进入每个结点的可用时间，选择既满足SGQ限制，又在某个时段可用的$p$个结点。

maximum-k-plex community query (*MCKPQ*) is desc'd as Prob.22:

> [!problem] Prob. 22
> Given a simple undrct' graph $G(V,E)$, a set of query vtx's $Q\subseteq V$, an int' $k$. Return a subgraph $G_Q(V_Q,E_Q)\subseteq G(V,E)$ such that the following prop's hold:
> - connectivity: $G_q$ is conn'd and contains $Q$.
> - structure cohesiveness: $G_q$ is a k-plex.
> - maximal structure: there exists no other $G_Q'\subseteq G$ satisfying the above prop's and $G_Q\subset G_Q'$.

Prob.22 is very challenging and NP-complete, which can be proved from a reduction from the k-plex prob'. and it's also hard to be approx'd in polynomial time within $n^{1-\epsilon}$.

a basic sol' to Prob.22: 
- generate-and-verify method: enumerates all k-plexes in the whole search space, and returns the one with the largest size
	- too impractical for large graphs
- a more advanced method by Wang et al. in "Wang, Y., Jian, X., Yang, Z., Li, J.: Query optimal k-plex based community in graphs. Data Sci. Eng. 2(4), 257–273 (2017)"

说人话：

最大k-plex社区查询（问题22）：给定一个简单无向图、一组查询结点和一个整数$k$。返回一个子图，使得：
- $G_q$连通并包含$Q$。
- $G_q$是一个k-plex。
- 没有更大的$G_q$符合要求。

解决方案：生成所有k-plex并检验。
- 有人研究了更好的算法

#### k-clique-based most influential community search

*aggregate influence probability* (聚合影响概率) of a comm'ty $C$ w.r.t. a vtx' $v$, denoted by $Pr(v\mid C)$:
$$
Pr(v\mid C)=1-\prod_{u\in C} (1-P_{u\to v})
$$
where $P_{u\to v}$ denotes the probability that $v$ is influenced by $u$. suppose an influence prob'ty $P_{u,v}$ exists for each edge $(u,v)\in E$, then:
$$
P_{u\to v}=1-\prod_{\forall (u,a_1,a_2,\cdots,a_k,v)} (1-P_{u,a_1}P_{a_1,a_2}\cdots P_{a_{k},v})
$$
where $<u,a_1,a_2,\cdots,v>$ denotes all possible paths in $G$ btwn' $u,v$.

Given a probabilistic threshold $\Delta$, the *influence score* of a comm'ty $C$ is the number of vtx's in $G-C$ with aggregate influence no less than $\Delta$, denoted by $\text{score}(C)$.

most influential comm'ty search is def'd as Prob.23:

> [!problem] Prob. 23
> Given an attr'd graph $G$ where each edge has an influence probability, the problem of the most influential comm'ty search is to find a maximal kr-clique comm'ty with the highest influence score.

Prob.23 is also NP-hard due to clique computation.

a baseline sol' to Prob.23:
- access the vtx's by their individual influence, and compute the maximal kr-clique for each vtx'
- *C-Tree*: assures that any kr-cliques are generated effn'ly
- another four search algo's to prune search space

#### discussions

k-clique-based CS sol's in two groups:
- simple graph based:
	- quasi-clique model based sol' (to Prob.19)
	- k-clique model based sol' (to Prob.20)
	- k-plex model based sol's (to Prob.21, Prob.22)
- attr'd graph based
	- Prob.23: most influential comm'ty search

### sec06-k-ECC based CS

Steiner maximum-connected subgraph (*SMCS*): given a graph $G$, vtx' set $Q$, the SMCS of $G$ on $Q$ is a subgraph $H$ of $G$ that:
- contains $Q$
- has the maximum edge-connectivity

#### maximum SMCS

maximum SMCS search is def'd as Prob.24:

> [!problem] Prob. 24
> Given an undrct' graph $G$ and a set of vtx's $Q\subseteq V$. Return a subgraph $H$ of $G$, such that:
> - $V_H$ contains $Q$.
> - $\lambda(H)$ (i.e. [[#^2690c9|graph connectivity]]) is maximized.
> - no subgraph $H'$ exists to satisfy the above prop's, such that $H\subset H'$.

