
[官网](https://ysyx.oscc.cc/docs/2306/preliminary/preliminary.html)

## 进度

- [ ] 学习记录表
- [ ] 如何科学提问：800字观后感
- [ ] Linux系统安装
- [ ] verilator
- [ ] Linux基本使用
- [ ] 数字电路习题
- [ ] C语言习题
- [ ] PA1

## Linux系统安装

[[一次Ubuntu装机记录]]

装`libsdl2-dev`时出了一点小插曲：

![[Pasted image 20240612120107.png]]

参考[这篇博客](https://www.cnblogs.com/hanyj-home/p/17041384.html)，得知需要在`aptitude`中进行安装：

```bash
$ sudo apt install aptitude
$ sudo aptitude install libsdl2-dev
```

## 复习C语言

ysyx的C语言复习要求做一遍[C语言实验](https://www.cntofu.com/book/25/introduction.md)。

## 搭建verilator仿真环境

verilator是一种开源仿真器，可实现将Verilog转换为C/C++代码。

### 安装verilator

由于实验强烈要求5.008版本，所以从指定tag克隆源码：

```bash
$ git clone -b v5.008 git@github.com:verilator/verilator.git
```

verilator的安装依赖一些库和工具：

```bash
sudo apt-get install git perl python3 make autoconf g++ flex bison ccache
sudo apt-get install libgoogle-perftools-dev numactl perl-doc
sudo apt-get install libfl2
sudo apt-get install libfl-dev
sudo apt-get install zlibc zlib1g zlib1g-dev
sudo apt-get install help2man
```

安装过程需要先配置，后编译安装：

```bash
autoconf
./configure
make -j8
sudo make install
```

### 拉取并部署workbench

```bash
git clone https://github.com/OSCPU/ysyx-workbench.git
cd ysyx-workbench
```

workbench内的`init.sh`脚本能够拉取并初始化数个项目。实验要求拉取`nvboard`和`npc`：

```bash
bash init.sh npc
bash init.sh nvboard
```

`nvboard`是南京大学开发的用于教学的虚拟FPGA板卡项目。在`example`文件夹下跑`make run`可以显示一个图形化FPGA界面，描述虚拟开发板的当前状态。

`npc`则是一个示例项目，只包含了一个`.v`、一个`.cpp`文件和一个未完善的`Makefile`。

### 双控开关项目

`ysyx-workbench/npc`目录如下组织：

```
npc
+ .vscode
	+ settings.json
	+ c_cpp_properties.json
+ 00_example
	+ csrc
		+ sim_main.cpp
	+ vsrc
		+ top.v
		+ sub.v
+ 01_switch
	+ csrc
		+ sim_main.cpp
	+ vsrc
		+ top.v
+ ...
+ Makefile
+ obj_dir
+ .gitignore
+ README.md
```

其中，形如`xx_xxxx`的是各个硬件模块项目，其中`vsrc`为Verilog源码目录，`csrc`为C++源码目录。前者为模块描述文件，后者为仿真测试文件。

这是我根据项目结构调整的`Makefile`：

```makefile
ifneq ($(words $(CURDIR)),1)
 $(error Unsupported: GNU Make cannot build in directories containing spaces, build elsewhere: '$(CURDIR)')
endif

# 确定verilator仿真器的位置
ifeq ($(VERILATOR_ROOT),)
VERILATOR = verilator
VERILATOR_COVERAGE = verilator_coverage
else
export VERILATOR_ROOT
VERILATOR = $(VERILATOR_ROOT)/bin/verilator
VERILATOR_COVERAGE = $(VERILATOR_ROOT)/bin/verilator_coverage
endif

# 生成C++可执行程序
VERILATOR_FLAGS += -cc --exe --build
# 指定顶层模块名称为top
VERILATOR_FLAGS += --top-module top
# 优化
VERILATOR_FLAGS += -x-assign fast
# 打开警告开关
VERILATOR_FLAGS += -Wall 
# 生成.vcd仿真波形文件
VERILATOR_FLAGS += --trace 
# 检查断言
VERILATOR_FLAGS += --assert
# 生成覆盖分析
VERILATOR_FLAGS += --coverage 
# 
VERILATOR_FLAGS += -LDFLAGS -"lreadline"

INCLUDE_V = $1/vsrc/include 
INCLUDE_C = $1/csrc/include
VERILATOR_FLAGS += -I$(INCLUDE_V)

ifeq ($(PROJ),)
SRC_V = $(shell find ./vsrc -name "*.v")
SRC_C = $(shell find ./csrc -name "*.c" -or -name "*.cc" -or -name "*.cpp")
else 
SRC_V = $(shell find $(PROJ)/vsrc -name "*.v")
SRC_C = $(shell find $(PROJ)/csrc -name "*.c" -or -name "*.cc" -or -name "*.cpp")
endif
VERILATOR_INPUT = $(SRC_V) $(SRC_C)
 
build:
	$(call git_commit, "sim RTL") # DO NOT REMOVE THIS LINE!!!
	@echo SRC_V=$(SRC_V)
	@echo SRC_C=$(SRC_C)
	$(VERILATOR) $(VERILATOR_FLAGS) $(VERILATOR_INPUT)

sim: clean build
	./obj_dir/Vtop 

wave: clean build
	./obj_dir/Vtop 
	gtkwave wave.vcd
 
count:
	find . -name "sim_main.cpp" -or -name "*.[vc]" | xargs wc -l
 
clean:
	rm -rf obj_dir
	rm -f wave.vcd

include ../Makefile
```

例如，我们要创建双控开关项目，则创建`02_switch`子目录，并在该子目录下创建`vsrc/top.v`和`csrc/sim_main.cpp`文件。

`vsrc/top.v`文件内容如下：

```verilog
module top(
  input a,
  input b,
  output out
);
  assign out = a ^ b;
endmodule
```

`csrc/sim_main.cpp`文件内容如下：

```cpp
#include <verilated.h>
#include <memory>
#include "Vtop.h"

int main(int argc, char** argv) {
  // 防止出现变量未使用错误
  if (false && argc && argv) {
  }

  // 创建Verilated上下文
  const std::unique_ptr<VerilatedContext> contextp{new VerilatedContext};
  contextp->debug(0);
  contextp->randReset(2);
  contextp->commandArgs(argc, argv);

  // 初始化顶层模块
  const std::unique_ptr<Vtop> top{new Vtop{contextp.get(), "TOP"}};

  // 双控开关共4个测试用例，每个用例测试一组可能的开关情形
  for (int bm = 0; bm < 4; ++bm) {
    top->a = !!(bm % 2);
    top->b = !!(bm / 2);
    top->eval();

    int verdict = (top->out == top->a ^ top->b);
    VL_PRINTF("a=%d b=%d out=%d verdict=%s\n", top->a, top->b, top->out,
              verdict ? "SUCC" : "FAIL");
  }

  // 析构模块
  top->final();

  // Return good completion status
  // Don't use exit() or destructor won't get called
  return 0;
}
```

若需构建并运行项目，运行：

```sh
$ make sim PROJ=02_switch
```

输出结果如下，表示模块通过了测试：

```
...
make[1]: Leaving directory '/home/cracklewis/ysyx-workbench/npc/obj_dir'
./obj_dir/Vtop 
a=0 b=0 out=0 verdict=SUCC
a=1 b=0 out=1 verdict=SUCC
a=0 b=1 out=1 verdict=SUCC
a=1 b=1 out=0 verdict=SUCC
```

### 查看仿真波形

安装`gtkwave`：

```sh
$ sudo apt install gtkwave
```

在Verilator方案中，波形的生成必须依赖Verilog伪指令，这一点体现在官方案例中：

```verilog
module top
  (
   // Declare some signals so we can see how I/O works
   input              clk,
   input              reset_l,

   output wire [1:0]  out_small,
   output wire [39:0] out_quad,
   output wire [69:0] out_wide,
   input [1:0]        in_small,
   input [39:0]       in_quad,
   input [69:0]       in_wide
   );

   // Connect up the outputs, using some trivial logic
   assign out_small = ~reset_l ? '0 : (in_small + 2'b1);
   assign out_quad  = ~reset_l ? '0 : (in_quad + 40'b1);
   assign out_wide  = ~reset_l ? '0 : (in_wide + 70'b1);

   // And an example sub module. The submodule will print stuff.
   sub sub (/*AUTOINST*/
            // Inputs
            .clk                        (clk),
            .reset_l                    (reset_l));

   // Print some stuff as an example
   initial begin
      if ($test$plusargs("trace") != 0) begin
         $display("[%0t] Tracing to logs/vlt_dump.vcd...\n", $time);
         $dumpfile("logs/vlt_dump.vcd");
         $dumpvars();
      end
      $display("[%0t] Model running...\n", $time);
   end

endmodule
```