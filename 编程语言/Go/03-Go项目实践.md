
参考资料：
- [Go从零实现系列-geektuku](https://geektutu.com/post/gee.html)
	- [GitHub](https://github.com/geektutu/7days-golang?tab=readme-ov-file)

NOTE：这里不是博客的搬运，所以不会完整抄录整段代码，只记录有助于个人理解的内容。看原博客转博客网站，看源码转GitHub。

## 项目：Web框架

常用Web框架：
- Java：SpringBoot
- Python：Django、Flask、Bottle
- Go：Beego、Gin、Iris

`net/http`已经提供了一些响应HTTP请求的简单方法。但仍有一些功能如动态路由（`hello/*`、`hello/:name`等）、统一鉴权、模板等缺乏支持。

组成：
- 上下文设计
- 路由
- 分组控制
- 中间件
- HTML模板
- 错误恢复

### HTTP基础

`net/http`库通过`HandleFunc`设置路由，通过`ListenAndServe`启动HTTP服务：

```go
package main

import (
	"fmt"
	"log"
	"net/http"
)

func main() {
	http.HandleFunc("/", indexHandler)
	http.HandleFunc("/hello", helloHandler)
	log.Fatal(http.ListenAndServe(":9999", nil))
}

// handler echoes r.URL.Path
func indexHandler(w http.ResponseWriter, req *http.Request) {
	fmt.Fprintf(w, "URL.Path = %q\n", req.URL.Path)
}

// handler echoes r.URL.Header
func helloHandler(w http.ResponseWriter, req *http.Request) {
	// 遍历Header字典并输出
	for k, v := range req.Header {
		fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
	}
}
```

可以通过`curl`测试效果：

```
G:\Desktop\7days-golang>curl http://localhost:9999/
URL.Path = "/"

G:\Desktop\7days-golang>curl http://localhost:9999/hello
Header["User-Agent"] = ["curl/8.7.1"]
Header["Accept"] = ["*/*"]
```

`http.Handler`接口要求实现`ServeHTTP`方法，实现该方法的类型可作为参数传入`ListenAndServe`函数。下面的源码与上面等价：

```go
package main

import (
	"fmt"
	"log"
	"net/http"
)

type Engine struct{}

func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	switch req.URL.Path {
	case "/":
		...
	case "/hello":
		...
	default:
		fmt.Fprintf(w, "404 NOT FOUND: %s\n", req.URL)
	}
}

func main() {
	engine := new(Engine)
	log.Fatal(http.ListenAndServe(":9999", engine))
}
```

Web框架的任务是简化上面的内容，使用户通过如下方式就可以实现Web服务：

```go
// 创建一个Web服务实例
r := gee.New()
// 绑定路由/
r.GET("/", func(w http.ResponseWriter, req *http.Request) {
	fmt.Fprintf(w, "URL.Path = %q\n", req.URL.Path)
})
// 绑定路由/hello
r.GET("/hello", func(w http.ResponseWriter, req *http.Request) {
	for k, v := range req.Header {
		fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
	}
})
// 将服务绑定在9999端口并启动
r.Run(":9999")
```

框架对外提供`GET`和`POST`方法用于设置路由，提供`Run`方法用于启动服务。

### 上下文

考虑路由视窗函数，它接收请求并返回响应：

```go
r.GET("/hello", func(w http.ResponseWriter, req *http.Request) {
	for k, v := range req.Header {
		fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
	}
})
```

实际的请求-响应需要考虑的内容远更复杂：
- 请求消息头（状态码、消息类型Content-Type、Cookie等）、消息体
- 响应的格式（JSON、文本、图片，etc.）
- 服务状态等细节

考虑用一个*上下文类型*封装：

```go
type Context struct {
	// origin objects
	Writer http.ResponseWriter
	Req    *http.Request
	// request info
	Path   string
	Method string
	// response info
	StatusCode int
}
```

定义构造器和各成员函数：

```go
// 构造器
func newContext(w http.ResponseWriter, req *http.Request) *Context

// 返回请求表单
func (c *Context) PostForm(key string) string
// 返回请求的查询部分
func (c *Context) Query(key string) string
// 设置返回状态码
func (c *Context) Status(code int)
// 设置响应头
func (c *Context) SetHeader(key string, value string)
// 设置响应内容为文本
func (c *Context) String(code int, format string, values ...interface{})
// 设置响应内容为JSON
func (c *Context) JSON(code int, obj interface{})
// 设置响应内容为二进制数据
func (c *Context) Data(code int, data []byte)
// 设置响应内容为HTML
func (c *Context) HTML(code int, html string)
```

有了上下文类型的完整定义，可以按这种方式耦合：

```go
// 每个请求到达时会执行一次ServeHTTP。
// 函数内会创建一个上下文，并通过handleRoute函数处理上下文
func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {  
	c := newContext(w, req)  
	engine.handleRoute(c)  
}
```

`handleRoute`方法可以直接实现为`*Engine`的成员方法，也可独立作为一个`router`：

```go
type HandlerFunc func(*Context)
type router struct {  
	handlers map[string]HandlerFunc  
}  
  
func newRouter() *router {  
	return &router{handlers: make(map[string]HandlerFunc)}  
}  
// 添加路由
func (r *router) addRoute(method string, pattern string, handler HandlerFunc) {  
	log.Printf("Route %4s - %s", method, pattern)  
	key := method + "-" + pattern  
	r.handlers[key] = handler  
}  
// 处理路由
func (r *router) handle(c *Context) {  
	key := c.Method + "-" + c.Path  
	if handler, ok := r.handlers[key]; ok {  
		handler(c)  
	} else {  
		c.String(http.StatusNotFound, "404 NOT FOUND: %s\n", c.Path)  
	}  
}

// (*Engine).ServeHTTP中这么写
engine.router.handle(c)
```

### 前缀树路由

下面考虑添加动态路由匹配：
- 由`:<name>`指代一个不确定的名称，如`/user/:id`表示任意ID的用户路由。
- 由`*<name>`表示通配，如`/static/*filename`表示任意的静态文件。

实现这种路由需要依赖特殊实现的前缀树，每个节点表示一级路径。所有层次都匹配则说明路由匹配成功，否则匹配失败：

![WTF](https://geektutu.com/post/gee-day3/trie_router.jpg)

Trie结点定义如下：

```go
type node struct {
	pattern  string // 待匹配路由，例如 /p/:lang
	part     string // 路由中的一部分，例如 :lang
	children []*node // 子节点，例如 [doc, tutorial, intro]
	isWild   bool // 是否精确匹配，part 含有 : 或 * 时为true
}
```

添加如下成员函数：

```go
// 第一个匹配成功的节点，用于插入
func (n *node) matchChild(part string) *node {
	for _, child := range n.children {
		if child.part == part || child.isWild {
			return child
		}
	}
	return nil
}

// 所有匹配成功的节点，用于查找
func (n *node) matchChildren(part string) []*node {
	nodes := make([]*node, 0)
	for _, child := range n.children {
		if child.part == part || child.isWild {
			nodes = append(nodes, child)
		}
	}
	return nodes
}

// 插入方法：
func (n *node) insert(pattern string, parts []string, height int) {  
	// 如果到了叶结点或者通配结点（*），则匹配结束
	if len(parts) == height {  
		n.pattern = pattern  
		return  
	}  
	// 取当前前缀树深度对应的小节，并查找匹配子结点
	part := parts[height]  
	child := n.matchChild(part)  
	// 如果子结点尚不存在，则创建之
	if child == nil {  
		child = &node{part: part, isWild: part[0] == ':' || part[0] == '*'}  
		n.children = append(n.children, child)  
	}  
	// 深入插入
	child.insert(pattern, parts, height+1)  
}  

// 搜索方法：根据parts指定的各节进行路由查找
func (n *node) search(parts []string, height int) *node {  
	// 叶结点、通配结点：搜索完毕
	if len(parts) == height || strings.HasPrefix(n.part, "*") {  
		if n.pattern == "" {  
			return nil  
		}  
		return n  
	}  
	
	part := parts[height]  
	children := n.matchChildren(part)  
  
	for _, child := range children {  
		result := child.search(parts, height+1)  
		if result != nil {  
			return result  
		}  
	}  
  
	return nil  
}
```

前缀树逻辑在路由部分实现，应当提供添加路由和获取路由的有关方法：

```go
// 路由结构体
type router struct {
	// 每个请求方法（GET、POST等）一棵前缀树
	roots    map[string]*node
	// 每个请求方法和路由（如GET /api/info）一个窗口函数
	handlers map[string]HandlerFunc
}

// 构造路由结构
func newRouter() *router
// 将完整路由（形如/a/:b/c）解析为[a,:b,c]的形式
func parsePattern(pattern string) []string
// 添加一条路由
func (r *router) addRoute(method string, pattern string, handler HandlerFunc)
// 根据请求方法和完整路由，返回前缀树上的对应结点
// 同时计算并返回参数列表（如：/:name、/*path中name、path的匹配内容）
func (r *router) getRoute(method string, path string) (*node, map[string]string)
```

上下文结构应考虑增设有关参数列表的信息：

```go
type Context struct {
	...
	Params map[string]string
	...
}

func (c *Context) Param(key string) string {
	value, _ := c.Params[key]
	return value
}
```

路由部分的处理函数，如`addRoute`、`handle`函数等也应对应修改，这里不再赘述。

### 分组控制

实际应用中，往往某一组路由需要相似的处理逻辑，比如`/admin`开头的路由访问前需要鉴权，`/api`开头的路由是RESTful接口，需要三方平台鉴权等。

路由分组一般通过前缀区分，一般支持分组嵌套，即`/api/note/tags`同时属于`/`、`/api`、`/api/note`、`/api/nota/tags`总计4个路由分组。

每个路由分组可以运用*中间件*（middleware），提供一定的扩展能力。

分组可以下辖数个路由：

```go
r := gee.New()  
v1 := r.Group("/api")  
v1.GET("/", func(c *gee.Context) { ... })
v1.GET("/note", func(c *gee.Context) { ... })
v1.GET("/user", func(c *gee.Context) { ... })
```

路由分组可以采用如下的结构体表示：

```go
type RouterGroup struct {
	prefix      string
	middlewares []HandlerFunc // 中间件集合
	parent      *RouterGroup  // 其所属的上一级路由分组
	engine      *Engine       // 指向Web服务对象
}
```

最顶层的Web服务也可以作为一个路由分组（`/`），具备分组所有的全部职能：

```go
type Engine struct {
	*RouterGroup              // Engine本身作为一个最顶级的路由分组
	router *router            // 路由模块
	groups []*RouterGroup     // 存储所有已创建的路由分组
}
```

通过上述定义，路由分组可以组织成一棵有根树的形式，根结点为`Engine`。此时路由有关的功能可以重新定义在路由分组上：

```go
// 创建Web服务对象
func New() *Engine

// 根据子路径创建一个子分组，将其追加到engine.groups内
func (group *RouterGroup) Group(prefix string) *RouterGroup
// 添加一个路由（comp指分组下的路径）
func (group *RouterGroup) addRoute(method string, comp string, handler HandlerFunc)
// 添加一个GET路由
func (group *RouterGroup) GET(pattern string, handler HandlerFunc)
// 添加一个POST路由
func (group *RouterGroup) POST(pattern string, handler HandlerFunc)
```

### 中间件

中间件（middleware）是非业务的技术类组件。Web框架通过中间件允许用户自行定义一些功能。

中间件将作为闭包呈现给Web服务，并作用于某个路由分组：

```go
func Logger() HandlerFunc {  
	return func(c *Context) {  
		// Start timer  
		t := time.Now()  
		// Process request  
		c.Next()  
		// Calculate resolution time  
		log.Printf("[%d] %s in %v", c.StatusCode, c.Req.RequestURI, time.Since(t))  
	}  
}
```

为了使上下文结构能够访问中间件，需要新增2个成员，分别表示中间件列表和索引：

```go
type Context struct {
	...
	handlers []HandlerFunc   // 需要访问的中间件列表
	index    int             // 当前执行到的中间件索引
}

// 访问剩余所有未访问完毕的中间件
func (c *Context) Next()
```

路由分组需要实现添加中间件的有关逻辑：

```go
// 将参数内的中间件添加到分组的中间件列表
func (group *RouterGroup) Use(middlewares ...HandlerFunc) {  
	group.middlewares = append(group.middlewares, middlewares...)  
}  

// 在创建上下文时，将路由匹配的所有分组的中间件放入上下文
func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {  
	var middlewares []HandlerFunc  
	for _, group := range engine.groups {  
		if strings.HasPrefix(req.URL.Path, group.prefix) {  
			middlewares = append(middlewares, group.middlewares...)  
		}  
	}  
	c := newContext(w, req)  
	c.handlers = middlewares  
	engine.router.handle(c)  
}
```

如何使用中间件则：

```go
func (r *router) handle(c *Context) {
	n, params := r.getRoute(c.Method, c.Path)

	if n != nil {
		key := c.Method + "-" + n.pattern
		c.Params = params
		// 先执行中间件逻辑，后执行路由对应的窗口函数
		c.handlers = append(c.handlers, r.handlers[key])
	} else {
		c.handlers = append(c.handlers, func(c *Context) {
			c.String(http.StatusNotFound, "404 NOT FOUND: %s\n", c.Path)
		})
	}
	c.Next()
}
```

### HTML模板

前后端分离模式：
- 后端：提供RESTful（形如`/api/note?user=CrackLewis&category=cpp`）接口，返回结构化的数据
- 前端：应用ajax技术向后端请求数据，并在前端渲染
- 同一套后端可以支撑小程序、APP、网页端等服务，同一套前端可以对接任意后端（只要框架允许）

Go的`html/template`库提供了较为完备的HTML模板支持，Web服务直接拿来主义即可：

```go
type Engine struct {  
	*RouterGroup  
	router        *router  
	groups        []*RouterGroup     
	htmlTemplates *template.Template // for html render  
	funcMap       template.FuncMap   // for html render  
}  
  
func (engine *Engine) SetFuncMap(funcMap template.FuncMap) {  
	engine.funcMap = funcMap  
}  
  
func (engine *Engine) LoadHTMLGlob(pattern string) {  
	engine.htmlTemplates = template.Must(template.New("").Funcs(engine.funcMap).ParseGlob(pattern))  
}
```