
参考资料：
- [Go从零实现系列-geektuku](https://geektutu.com/post/gee.html)
	- [GitHub](https://github.com/geektutu/7days-golang?tab=readme-ov-file)

NOTE：这里不是博客的搬运，所以不会完整抄录整段代码，只记录有助于个人理解的内容。看原博客转博客网站，看源码转GitHub。

## 项目：Web框架

常用Web框架：
- Java：SpringBoot
- Python：Django、Flask、Bottle
- Go：Beego、Gin、Iris

`net/http`已经提供了一些响应HTTP请求的简单方法。但仍有一些功能如动态路由（`hello/*`、`hello/:name`等）、统一鉴权、模板等缺乏支持。

组成：
- 上下文设计
- 路由
- 分组控制
- 中间件
- HTML模板
- 错误恢复

### HTTP基础

`net/http`库通过`HandleFunc`设置路由，通过`ListenAndServe`启动HTTP服务：

```go
package main

import (
	"fmt"
	"log"
	"net/http"
)

func main() {
	http.HandleFunc("/", indexHandler)
	http.HandleFunc("/hello", helloHandler)
	log.Fatal(http.ListenAndServe(":9999", nil))
}

// handler echoes r.URL.Path
func indexHandler(w http.ResponseWriter, req *http.Request) {
	fmt.Fprintf(w, "URL.Path = %q\n", req.URL.Path)
}

// handler echoes r.URL.Header
func helloHandler(w http.ResponseWriter, req *http.Request) {
	// 遍历Header字典并输出
	for k, v := range req.Header {
		fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
	}
}
```

可以通过`curl`测试效果：

```
G:\Desktop\7days-golang>curl http://localhost:9999/
URL.Path = "/"

G:\Desktop\7days-golang>curl http://localhost:9999/hello
Header["User-Agent"] = ["curl/8.7.1"]
Header["Accept"] = ["*/*"]
```

`http.Handler`接口要求实现`ServeHTTP`方法，实现该方法的类型可作为参数传入`ListenAndServe`函数。下面的源码与上面等价：

```go
package main

import (
	"fmt"
	"log"
	"net/http"
)

type Engine struct{}

func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	switch req.URL.Path {
	case "/":
		...
	case "/hello":
		...
	default:
		fmt.Fprintf(w, "404 NOT FOUND: %s\n", req.URL)
	}
}

func main() {
	engine := new(Engine)
	log.Fatal(http.ListenAndServe(":9999", engine))
}
```

Web框架的任务是简化上面的内容，使用户通过如下方式就可以实现Web服务：

```go
// 创建一个Web服务实例
r := gee.New()
// 绑定路由/
r.GET("/", func(w http.ResponseWriter, req *http.Request) {
	fmt.Fprintf(w, "URL.Path = %q\n", req.URL.Path)
})
// 绑定路由/hello
r.GET("/hello", func(w http.ResponseWriter, req *http.Request) {
	for k, v := range req.Header {
		fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
	}
})
// 将服务绑定在9999端口并启动
r.Run(":9999")
```

框架对外提供`GET`和`POST`方法用于设置路由，提供`Run`方法用于启动服务。

### 上下文

考虑路由视窗函数，它接收请求并返回响应：

```go
r.GET("/hello", func(w http.ResponseWriter, req *http.Request) {
	for k, v := range req.Header {
		fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
	}
})
```

实际的请求-响应需要考虑的内容远更复杂：
- 请求消息头（状态码、消息类型Content-Type、Cookie等）、消息体
- 响应的格式（JSON、文本、图片，etc.）
- 服务状态等细节

考虑用一个*上下文类型*封装：

```go
type Context struct {
	// origin objects
	Writer http.ResponseWriter
	Req    *http.Request
	// request info
	Path   string
	Method string
	// response info
	StatusCode int
}
```

定义构造器和各成员函数：

```go
// 构造器
func newContext(w http.ResponseWriter, req *http.Request) *Context

// 返回请求表单
func (c *Context) PostForm(key string) string
// 返回请求的查询部分
func (c *Context) Query(key string) string
// 设置返回状态码
func (c *Context) Status(code int)
// 设置响应头
func (c *Context) SetHeader(key string, value string)
// 设置响应内容为文本
func (c *Context) String(code int, format string, values ...interface{})
// 设置响应内容为JSON
func (c *Context) JSON(code int, obj interface{})

```