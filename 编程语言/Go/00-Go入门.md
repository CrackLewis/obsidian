
## 安装

安装包下载：[网址](https://golang.google.cn/dl/)

## 基础语法

语句原则上需要用分号分隔。每行的最后一个语句可不加分号。

注释和C/C++类似。

Go中有如下关联字：

|          |             |        |           |        |
| -------- | ----------- | ------ | --------- | ------ |
| break    | default     | func   | interface | select |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |
\
有如下保留字：

|   |   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|---|
|append|bool|byte|cap|close|complex|complex64|complex128|uint16|
|copy|false|float32|float64|imag|int|int8|int16|uint32|
|int32|int64|iota|len|make|new|nil|panic|uint64|
|print|println|real|recover|string|true|uint|uint8|uintptr|

## 数据类型

Go类型：
- 布尔型
- 数字类型：
	- 整数型：`[int|uint][8|16|32|64]`
	- 实数型：`float[32|64]`
	- 复数型：`complex[32|64]`
	- 其他数字类型：`byte`（类似`uint8`）、`rune`（类似`int32`）、`int`（采用系统字长的带符号整数）、`uint`（不带符号整数）、`uintptr`（指针字面量）
- 字符串类型：UTF-8编码标识Unicode文本
- 派生类型：指针、数组、结构体、Channel、函数、切片、接口、Map

## 变量

定义：

```go
// 无初始值定义：默认为零值
var ident1 type
var ident1, ident2, ident3 type
// 有初始值定义：如果无类型限定，则会根据初始值推断
var ident1 type = value;
var ident1 = value;
// 简记法：左侧的变量不能是已声明的
ident1, ident2, _ := 3, 5, 6
// 多行声明：一般用于声明全局变量
var (
	vname1 v_type1
	vname2 v_type2
)
```

不同类型的零值：
- 布尔型：`false`
- 数字型：`0`、`0+0i`
- 字符串：`""`
- 指针、数组、函数等：`nil`

## 常量

常量声明时必须指定值，且不可修改。类型不必写明，可以由编译器自动推断。

```go
// 这两种写法都允许
const ident idtype = value;
const ident = value;

// 复合赋值也是允许的
const ident1, ident2 = val1, val2;
```

常量也允许多行声明，一般用于定义枚举：

```go
const (
	Informational = 1
	Success = 2
	Redirection = 3
	ClientError = 4
	ServerError = 5
)
```

`iota`是一种特殊常量，它用于为常量批量赋值。在多行常量声明内，如果一个常量被赋予`iota`表达式，在它后面、在下一个赋值常量前的所有常量都会采用该表达式。`iota`的值会从多行声明的首个变量开始，初试为0，每新定义一个变量递增1。

比较抽象，不如直接看这个示例：

```go
const (
	a = iota      // 0
	b             // 1
	c             // 2
	d = 1 << iota // iota=3,d=8
	e             // iota=4,e=16
	f = 3 * iota  // iota=5,f=15
	g             // iota=6,g=18
	h = 2         // iota=7,h=2
	i = "haha"    // iota=8,i="haha"
)
```

## 运算符

常用运算符：
- 算术运算符：四则、取模、自增、自减
- 关系运算符：6种
- 逻辑运算符：`&&`、`||`、`!`
- 位运算符：`&`、`|`、`^`、`&^`、`>>`、`<<`
- 赋值运算符：`=`、算术赋值、位运算赋值
- 其他运算符：取地址（`&`）、解引用（`*`）

运算符优先级：
- 5：乘除、取模、位移、按位与、按位与非
- 4：加减、按位或、按位异或
- 3：关系运算符
- 2：逻辑与
- 1：逻辑或

绝大部分运算符与C/C++比较类似，这里主要关注Go的取地址和解引用：

```go
package main

import "fmt"

func main() {
   var a int = 4
   var b int32
   var c float32
   var ptr *int

   /* 运算符实例 */
   fmt.Printf("第 1 行 - a 变量类型为 = %T\n", a ); // int
   fmt.Printf("第 2 行 - b 变量类型为 = %T\n", b ); // int32
   fmt.Printf("第 3 行 - c 变量类型为 = %T\n", c ); // float32

   /*  & 和 * 运算符实例 */
   ptr = &a     /* 'ptr' 包含了 'a' 变量的地址 */
   fmt.Printf("a 的值为  %d\n", a);    // 4
   fmt.Printf("*ptr 为 %d\n", *ptr);   // 4
}
```

## 流程控制

### if-else语句

Go的if-else语句格式十分像Rust：

```go
if condition {
	action1
} else if subcondition {
	action2
} else {
	action3
}
```

示例：

```go
func main() {
	var a int
	var b int
	fmt.Printf("请输入密码：   \n")
	fmt.Scan(&a)
	if a == 5211314 {
		fmt.Printf("请再次输入密码：")
		fmt.Scan(&b)
		if b == 5211314 {
			fmt.Printf("密码正确，门锁已打开")
		} else {
			fmt.Printf("非法入侵，已自动报警")
		}
	} else if a == 1919810 {
		fmt.Printf("哼哼哼，啊~啊，啊！你把门锁熏开了")
	} else {
		fmt.Printf("非法入侵，已自动报警")
	}
}
```

### switch语句

与C/C++的`switch`语句职能类似，但也有很大区别：
- 每个case不需要在末尾加break。
- 默认在执行一个case后，不会执行后面的case。如果要强制执行下去，需要加`fallthrough`声明。

格式：

```go
switch value {
	case val1: action1
	case val2: action2
	case val3, val4: action3
	...
	default: action4
}
```

示例：

```go
func main() {
   /* 定义局部变量 */
   var grade string = "B"
   var marks int = 90

   switch marks {
      case 90: grade = "A"
      case 80: grade = "B"
      case 50,60,70 : grade = "C"
      default: grade = "D"  
   }

   switch {
      case grade == "A" :
         fmt.Printf("优秀!\n" )     
      case grade == "B", grade == "C" :
         fmt.Printf("良好\n" )      
      case grade == "D" :
         fmt.Printf("及格\n" )      
      case grade == "F":
         fmt.Printf("不及格\n" )
      default:
         fmt.Printf("差\n" );
   }
   fmt.Printf("你的等级是 %s\n", grade );      
}
```

Go的switch语句有一个独特的功能：判断值的类型：

```go
func main() {
   var x interface{}
     
   switch i := x.(type) {
      case nil:  
         fmt.Printf(" x 的类型 :%T",i)                
      case int:  
         fmt.Printf("x 是 int 型")                      
      case float64:
         fmt.Printf("x 是 float64 型")          
      case func(int) float64:
         fmt.Printf("x 是 func(int) 型")                      
      case bool, string:
         fmt.Printf("x 是 bool 或 string 型" )      
      default:
         fmt.Printf("未知型")    
   }  
}
```

`fallthrough`是一种在case块执行结束后，特许控制流继续向下执行的机制。这一点和C/C++的默认继续向下执行非常不同：

```go
func main() {
    switch {
    case false:
            fmt.Println("1、case 条件语句为 false")
            fallthrough
    case true:
            fmt.Println("2、case 条件语句为 true")
            fallthrough
    case false:
            fmt.Println("3、case 条件语句为 false")
            fallthrough
    case true:
            fmt.Println("4、case 条件语句为 true")
    case false:
            fmt.Println("5、case 条件语句为 false")
            fallthrough
    default:
            fmt.Println("6、默认 case")
    }
}
```