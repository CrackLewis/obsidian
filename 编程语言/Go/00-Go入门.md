
## 安装

安装包下载：[网址](https://golang.google.cn/dl/)

## 基础语法

语句原则上需要用分号分隔。每行的最后一个语句可不加分号。

注释和C/C++类似。

Go中有如下关联字：

|          |             |        |           |        |
| -------- | ----------- | ------ | --------- | ------ |
| break    | default     | func   | interface | select |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |
\
有如下保留字：

|   |   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|---|
|append|bool|byte|cap|close|complex|complex64|complex128|uint16|
|copy|false|float32|float64|imag|int|int8|int16|uint32|
|int32|int64|iota|len|make|new|nil|panic|uint64|
|print|println|real|recover|string|true|uint|uint8|uintptr|

## 数据类型

Go类型：
- 布尔型
- 数字类型：
	- 整数型：`[int|uint][8|16|32|64]`
	- 实数型：`float[32|64]`
	- 复数型：`complex[32|64]`
	- 其他数字类型：`byte`（类似`uint8`）、`rune`（类似`int32`）、`int`（采用系统字长的带符号整数）、`uint`（不带符号整数）、`uintptr`（指针字面量）
- 字符串类型：UTF-8编码标识Unicode文本
- 派生类型：指针、数组、结构体、Channel、函数、切片、接口、Map

## 变量

定义：

```go
// 无初始值定义：默认为零值
var ident1 type
var ident1, ident2, ident3 type
// 有初始值定义：如果无类型限定，则会根据初始值推断
var ident1 type = value;
var ident1 = value;
// 简记法：左侧的变量不能是已声明的
ident1, ident2, _ := 3, 5, 6
// 多行声明：一般用于声明全局变量
var (
	vname1 v_type1
	vname2 v_type2
)
```

不同类型的零值：
- 布尔型：`false`
- 数字型：`0`、`0+0i`
- 字符串：`""`
- 指针、数组、函数等：`nil`

## 常量

常量声明时必须指定值，且不可修改。类型不必写明，可以由编译器自动推断。

```go
// 这两种写法都允许
const ident idtype = value;
const ident = value;

// 复合赋值也是允许的
const ident1, ident2 = val1, val2;
```

常量也允许多行声明，一般用于定义枚举：

```go
const (
	Informational = 1
	Success = 2
	Redirection = 3
	ClientError = 4
	ServerError = 5
)
```

`iota`是一种特殊常量，它用于为常量批量赋值。在多行常量声明内，如果一个常量被赋予`iota`表达式，在它后面、在下一个赋值常量前的所有常量都会采用该表达式。`iota`的值会从多行声明的首个变量开始，初试为0，每新定义一个变量递增1。

比较抽象，不如直接看这个示例：

```go
const (
	a = iota      // 0
	b             // 1
	c             // 2
	d = 1 << iota // iota=3,d=8
	e             // iota=4,e=16
	f = 3 * iota  // iota=5,f=15
	g             // iota=6,g=18
	h = 2         // iota=7,h=2
	i = "haha"    // iota=8,i="haha"
)
```

## 运算符

常用运算符：
- 算术运算符：四则、取模、自增、自减
- 关系运算符：6种
- 逻辑运算符：`&&`、`||`、`!`
- 位运算符：`&`、`|`、`^`、`&^`、`>>`、`<<`
- 赋值运算符：`=`、算术赋值、位运算赋值
- 其他运算符：取地址（`&`）、解引用（`*`）

运算符优先级：
- 5：乘除、取模、位移、按位与、按位与非
- 4：加减、按位或、按位异或
- 3：关系运算符
- 2：逻辑与
- 1：逻辑或

绝大部分运算符与C/C++比较类似，这里主要关注Go的取地址和解引用：

```go
package main

import "fmt"

func main() {
   var a int = 4
   var b int32
   var c float32
   var ptr *int

   /* 运算符实例 */
   fmt.Printf("第 1 行 - a 变量类型为 = %T\n", a ); // int
   fmt.Printf("第 2 行 - b 变量类型为 = %T\n", b ); // int32
   fmt.Printf("第 3 行 - c 变量类型为 = %T\n", c ); // float32

   /*  & 和 * 运算符实例 */
   ptr = &a     /* 'ptr' 包含了 'a' 变量的地址 */
   fmt.Printf("a 的值为  %d\n", a);    // 4
   fmt.Printf("*ptr 为 %d\n", *ptr);   // 4
}
```

## 流程控制

### if-else语句

Go的if-else语句格式十分像Rust：

```go
if condition {
	action1
} else if subcondition {
	action2
} else {
	action3
}
```

示例：

```go
func main() {
	var a int
	var b int
	fmt.Printf("请输入密码：   \n")
	fmt.Scan(&a)
	if a == 5211314 {
		fmt.Printf("请再次输入密码：")
		fmt.Scan(&b)
		if b == 5211314 {
			fmt.Printf("密码正确，门锁已打开")
		} else {
			fmt.Printf("非法入侵，已自动报警")
		}
	} else if a == 1919810 {
		fmt.Printf("哼哼哼，啊~啊，啊！你把门锁熏开了")
	} else {
		fmt.Printf("非法入侵，已自动报警")
	}
}
```

### switch语句

与C/C++的`switch`语句职能类似，但也有很大区别：
- 每个case不需要在末尾加break。
- 默认在执行一个case后，不会执行后面的case。如果要强制执行下去，需要加`fallthrough`声明。

格式：

```go
switch value {
	case val1: action1
	case val2: action2
	case val3, val4: action3
	...
	default: action4
}
```

示例：

```go
func main() {
   /* 定义局部变量 */
   var grade string = "B"
   var marks int = 90

   switch marks {
      case 90: grade = "A"
      case 80: grade = "B"
      case 50,60,70 : grade = "C"
      default: grade = "D"  
   }

   switch {
      case grade == "A" :
         fmt.Printf("优秀!\n" )     
      case grade == "B", grade == "C" :
         fmt.Printf("良好\n" )      
      case grade == "D" :
         fmt.Printf("及格\n" )      
      case grade == "F":
         fmt.Printf("不及格\n" )
      default:
         fmt.Printf("差\n" );
   }
   fmt.Printf("你的等级是 %s\n", grade );      
}
```

Go的switch语句有一个独特的功能：判断值的类型：

```go
func main() {
   var x interface{}
     
   switch i := x.(type) {
      case nil:  
         fmt.Printf(" x 的类型 :%T",i)                
      case int:  
         fmt.Printf("x 是 int 型")                      
      case float64:
         fmt.Printf("x 是 float64 型")          
      case func(int) float64:
         fmt.Printf("x 是 func(int) 型")                      
      case bool, string:
         fmt.Printf("x 是 bool 或 string 型" )      
      default:
         fmt.Printf("未知型")    
   }  
}
```

`fallthrough`是一种在case块执行结束后，特许控制流继续向下执行的机制。这一点和C/C++的默认继续向下执行非常不同：

```go
func main() {
    switch {
    case false:
            fmt.Println("1、case 条件语句为 false")
            fallthrough
    case true:
            fmt.Println("2、case 条件语句为 true")
            fallthrough
    case false:
            fmt.Println("3、case 条件语句为 false")
            fallthrough
    case true:
            fmt.Println("4、case 条件语句为 true")
    case false:
            fmt.Println("5、case 条件语句为 false")
            fallthrough
    default:
            fmt.Println("6、默认 case")
    }
}
```

### select语句（WIP）

比较玄学，涉及到通道的概念。

### for语句

Go中的for语句职能比较强大，相当于C/C++中的for、while和while(1)，也就是说这三种写法都是合法的：

```go
// 写法1：for
for init; cond; post {
	action1
}

// 写法2：while
for cond {
	action2
}

// 写法3：while(1)，一般必须配break
for {
	action3
}
```

for循环也支持针对容器的迭代循环语法：

```go
// 写法1：kv
for key, val := range oldMap {
	newMap[key] = val
}

// 写法2：k
for key := range oldMap {
	...
}

// 写法3：v
for _, val := range oldMap {
	...
} 
```

示例：

```go
func main() {
    map1 := make(map[int]float32)
    map1[1] = 1.0
    map1[2] = 2.0
    map1[3] = 3.0
    map1[4] = 4.0
    
    // 读取 key 和 value
    for key, value := range map1 {
      fmt.Printf("key is: %d - value is: %f\n", key, value)
    }

    // 读取 key
    for key := range map1 {
      fmt.Printf("key is: %d\n", key)
    }

    // 读取 value
    for _, value := range map1 {
      fmt.Printf("value is: %f\n", value)
    }
}
```

### 跳转语句

`break`用于跳出整个循环，`continue`用于跳出本次循环。

`goto`用于无条件跳转到某个标记位置：

```go
goto label;

label: statement;
```

## 函数

格式：

```
func func_name ([param_list]) [return_types] {
	[statements]
}
```

定义示例：返回两个整型参数的最大值

```go
/* 函数返回两个数的最大值 */
func max(num1, num2 int) int {
   /* 定义局部变量 */
   var result int

   if (num1 > num2) {
      result = num1
   } else {
      result = num2
   }
   return result
}
```

定义示例：返回多个值

```go
func swap(x, y string) (string, string) {
   return y, x
}
```

### 参数传递方式：值传递、引用传递

如果需要进行实际的变量交换值，则必须用变量的指针展开操作：

```go
/* 定义交换值函数*/
func swap(x *int, y *int) {
   var temp int
   temp = *x    /* 保持 x 地址上的值 */
   *x = *y      /* 将 y 值赋给 x */
   *y = temp    /* 将 temp 值赋给 y */
}
```

调用方则需要传入将交换的变量的地址：

```go
func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int= 200

   fmt.Printf("交换前，a 的值 : %d\n", a )
   fmt.Printf("交换前，b 的值 : %d\n", b )

   /* 调用 swap() 函数
   * &a 指向 a 指针，a 变量的地址
   * &b 指向 b 指针，b 变量的地址
   */
   swap(&a, &b)

   fmt.Printf("交换后，a 的值 : %d\n", a )
   fmt.Printf("交换后，b 的值 : %d\n", b )
}
```

### 闭包

Go支持匿名函数，支持动态定义函数，这使得闭包的实现成为可能。

示例：一个基于闭包的计数器

```go
package main

import "fmt"

func getSequence() func() int {
   i:=0
   return func() int {
      i+=1
     return i  
   }
}

func main(){
   /* nextNumber 为一个函数，函数 i 为 0 */
   nextNumber := getSequence()  

   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */
   fmt.Println(nextNumber()) // 1
   fmt.Println(nextNumber()) // 2
   fmt.Println(nextNumber()) // 3
   
   /* 创建新的函数 nextNumber1，并查看结果 */
   nextNumber1 := getSequence()  
   fmt.Println(nextNumber1()) // 1
   fmt.Println(nextNumber1()) // 2
}
```

包括闭包在内的函数也可以作为参数传入其他函数：

```go
package main

import "fmt"

func main() {
    // 定义一个匿名函数并将其赋值给变量add
    add := func(a, b int) int {
        return a + b
    }

    // 调用匿名函数
    result := add(3, 5)
    fmt.Println("3 + 5 =", result)

    // 将匿名函数作为参数传递给其他函数
    calculate := func(operation func(int, int) int, x, y int) int {
        return operation(x, y)
    }

    sum := calculate(add, 2, 8)
    fmt.Println("2 + 8 =", sum) // 2 + 8 = 10

    // 也可以直接在函数调用中定义匿名函数
    difference := calculate(func(a, b int) int {
        return a - b
    }, 10, 4)
    fmt.Println("10 - 4 =", difference) // 10 - 4 = 6
}
```

### 类型方法

Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。语法格式如下：

```go
func (variable_name variable_data_type) function_name() [return_type]{
   /* 函数体*/
}
```

示例：

```go
package main

import (
   "fmt"  
)

/* 定义结构体 */
type Circle struct {
  radius float64
}

func main() {
  var c1 Circle
  c1.radius = 10.00
  fmt.Println("圆的面积 = ", c1.getArea())
}

//该 method 属于 Circle 类型对象中的方法
func (c Circle) getArea() float64 {
  //c.radius 即为 Circle 类型对象中的属性
  return 3.14 * c.radius * c.radius
}
```

## 变量作用域

Go变量在作用域上分为全局变量和局部变量。

*全局变量*指在函数体外声明的变量，可以在整个包内使用，如果被导出，则可以在包外使用。

*局部变量*指在函数体内声明的变量，只能在定义变量的大括号内使用，离开大括号自动失效。

有些资料将*形式参数*作为一种特殊的作用域变量，个人认为它是在形参列表定义的、作用域为整个函数的局部变量。

## 数组

Go数组的语法比较诡异：

```go
var arrayName [size]dataType
```

定义Go数组的几种语法：

```go
// 默认初始化：成员全部为0
var numbers [5]int
// 列表初始化
var numbers [5]int {1, 2, 3, 4, 5}
// 简化初始化
numbers := [5]int {1, 2, 3, 4, 5}
```

如果数组长度不确定，则可以用省略号代替，长度会自动推断：

```go
numbers := [...]int {1, 2, 3, 4, 5, 6}
```

如果数组长度确定，对个别成员进行初始化也是允许的：

```go
numbers := [5]int {1:2, 3:7} // {0, 2, 0, 7, 0}
```

访问数组元素可直接用`arrname[idx]`的格式：

```go
package main

import "fmt"

func main() {
   var i,j,k int
   // 声明数组的同时快速初始化数组
   balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}

   /* 输出数组元素 */         ...
   for i = 0; i < 5; i++ {
      fmt.Printf("balance[%d] = %f\n", i, balance[i] )
   }
   
   balance2 := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
   /* 输出每个数组元素的值 */
   for j = 0; j < 5; j++ {
      fmt.Printf("balance2[%d] = %f\n", j, balance2[j] )
   }

   //  将索引为 1 和 3 的元素初始化
   balance3 := [5]float32{1:2.0,3:7.0}  
   for k = 0; k < 5; k++ {
      fmt.Printf("balance3[%d] = %f\n", k, balance3[k] )
   }
}
```

### 多维数组

以低维数组为元素的数组。

```go
var matrix [3][4]float64

var matrix2 [2][3]int {{1, 2, 3}, {4, 5, 6}}

matrix3 := [2][3]int {{1, 1, 4}, {5, 1, 4}}
```

多维数组允许各个维度的元素数量不一致，但需要定义为元素个数未定的数组：

```go
package main

import "fmt"

func main() {
    // 创建空的二维数组
    animals := [][]string{}

    // 创建三一维数组，各数组长度不同
    row1 := []string{"fish", "shark", "eel"}
    row2 := []string{"bird"}
    row3 := []string{"lizard", "salamander"}

    // 使用 append() 函数将一维数组添加到二维数组中
    animals = append(animals, row1)
    animals = append(animals, row2)
    animals = append(animals, row3)

    // 循环输出
    for i := range animals {
        fmt.Printf("Row: %v\n", i)
        fmt.Println(animals[i])
    }
}
```

### 数组作为参数

Go数组作为函数参数时，可指定数组大小，也可不指定。

示例：不指定数组大小，通过其他形参确定数组实际容量：

```go
func getAverage(arr []int, size int) float32
{
   var i int
   var avg, sum float32  

   for i = 0; i < size; ++i {
      sum += arr[i]
   }

   avg = sum / size

   return avg;
}
```

但和C/C++不同，Go内的数组参数是*传值*而非传址，不能修改调用方的数组内容。但可以使用数组指针作为函数参数，这种方式能够修改原始数组内容：

```go
package main

import "fmt"

// 函数接受一个数组作为参数
func modifyArray(arr [5]int) {
    for i := 0; i < len(arr); i++ {
        arr[i] = arr[i] * 2
    }
}

// 函数接受一个数组的指针作为参数
func modifyArrayWithPointer(arr *[5]int) {
    for i := 0; i < len(*arr); i++ {
        (*arr)[i] = (*arr)[i] * 2
    }
}

func main() {
    // 创建一个包含5个元素的整数数组
    myArray := [5]int{1, 2, 3, 4, 5}

    fmt.Println("Original Array:", myArray)

    // 传递数组给函数，但不会修改原始数组的值
    modifyArray(myArray)
    fmt.Println("Array after modifyArray:", myArray)

    // 传递数组的指针给函数，可以修改原始数组的值
    modifyArrayWithPointer(&myArray)
    fmt.Println("Array after modifyArrayWithPointer:", myArray)
}
```