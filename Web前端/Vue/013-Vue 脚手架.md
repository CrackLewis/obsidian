
Vue脚手架是Vue官方提供的标准化开发工具

资料：
- [Vue CLI](https://cli.vuejs.org/zh/)

安装步骤：
- （可选）换源：`npm config set registry xxx`
- 全局安装vue-cli：`npm install -g @vue/cli`

项目创建步骤：
- 创建项目：`vue create xxx`
- 选择使用的Vue版本
- 启动项目：`npm run serve`
- 打包项目：`npm run build`

## 脚手架项目结构

```
vue-cli-demo/
+ node_modules/             # node模块文件
+ public/
	+ favicon.ico           # 网页图标
	+ index.html            # 网页容器
+ src/
	+ assets/               # 静态资源
		+ logo.png          # 网站logo
	+ components/           # 组件目录
		+ HelloWorld.vue    
	+ App.vue               # 最高层次的Vue组件
	+ main.js               # 定义Vue实例，入口文件
+ package.json              # 应用包配置
+ package-lock.json         # 包版本控制
+ .gitignore                
+ babel.config.js           # babel配置文件
+ README.md
```

## ref属性

`ref`属性允许组件通过引用方式访问特定的DOM元素。

被引用的元素必须通过`ref`属性标记，属性值为*标记名*。元素可以是HTML元素，也可以是Vue组件实例。

Vue组件或实例内通过`this.$refs.name`访问标记名为`name`的DOM元素。

```vue
<template>
   <div>
     <h1 v-text="msg" ref="title"></h1>
     <button @click="showH">点我输出上方的dom元素</button>
     <School ref="sch"/>
   </div>
</template>

<script>
import School from "./components/School";

export default {
  name: "App",
  data(){
    return {
      msg: '欢迎学习Vue',
    }
  },
  methods:{
    showH(e){
      console.log(this.$refs.title); //this ==> vc(app组件)
      console.log(e.target); //发生事件的dom元素m
      console.log(this.$refs.sch); //可以是school组件加refs属性 获得的是组件事例对象vc
    }
  },
  components:{
    School,
  },
}
</script>
```

## props配置项

绝大部分Vue组件需要指定参数，以便实现自定义显示。支持这一机制的是组件的`props`配置项，它指定了组件创建时接受哪些参数。

`props`配置项有三种写法：
- 第一种写法是参数名到对象的字典，每个对象表示一个参数的属性。如：`props:{name:{type:String,required:true}}`
- 第二种写法是参数名到类型的字典。如：`props:{name:String}`
- 第三种写法是参数名列表。如：`props:['name','sex']`

第一种写法中对象的属性：
- `type`：参数类型。有`String`、`Number`等类型。
- `default`：参数默认值。
- `required`：参数是否必需。与`default`互斥。

在指定了`props`配置项的组件中，可以通过*模板语法*直接使用参数：

```vue
<template>
   <div class="demo">
     <!--注意props传递过来的值是不能改的(尽量避免去改，控制台会有警告)-->
     <h1>{{ msg }}</h1>
     <h2>姓名:{{ myName }}</h2>
     <h2>年龄: {{  age }}</h2>
     <h2>性别: {{ sex }}</h2>
     <button @click="updateName">尝试修改名字</button>
   </div>
</template>

<script>
export default {
  name: "Student",
  // props: ['name', 'sex', 'age'], //简单声明接收
  data(){
    console.log(this);
    return {
      //如果props和data存在同名的属性，会报错，但以props传递的属性值为主
      //注意props属性名不能是vue底层已征用的属性名(比如key, ref等等)
      msg: '我是一名牛马研究生',
      myName: this.name 
      //把props传递过来的值当成vc的状态，这样改name是不会出问题的，因为你没有直接去修改props
    }
  },
  methods:{
    updateName(){
      this.myName = 'sss';
    }
  },
  //接收时不仅限制类型还加上默认值的指定并指定它的必须性
  props:{
    name:{
      type: String, //类型
      required: true //必要的
    },
    age:{
      type: Number,
      default: 99 //默认值
    },
    sex:{
      type: String,
      required: true
    }
  }
}
</script>
```

在使用本组件的高级组件中，需要通过标签属性的方式指定参数的值：

```vue
<template>
   <div>
      <!---多个vc互不影响-->
      <!--v-bind的作用重要 获取后面表达式值的赋给props的属性-->
      <Student name="panyue" sex="男" :age='12'/>
      <hr/>
   </div>
</template>

<script>
import Student from "./components/Student";

export default {
  name: "App",
  components:{
    Student,
  },
}
</script>
```

注意：
- `props`是只读的。如果确实需要修改，那么需要先复制到`data`中再改。

## mixin混入对象

多个Vue组件可能有一些共性内容，这些内容如果不合并，可能会增加开发负担。

mixin可以把这种多个组件公用的配置提取成为一个混入对象。mixin可以混入局部的Vue组件或Vue实例，也可以混入Vue原型，使得所有的Vue对象都可以访问mixin。

mixin和Vue对象*合并规则*：
- 组件优先级更高：`data`（数据对象）、`props`
- 平等合并：`data`（返回数据对象的函数）、`methods`、生命周期函数、`components`、`directives`、`computed`、`watch`
- 如果生命周期函数合并，则来自mixin的函数先执行，来自组件的函数后执行。

定义mixin可以采取对象形式：

```js
// project/mixin.js
export const mixin = {
	data() { ... },
	methods: { ... },
	...
};
```

在局部使用mixin，需要将其放入实例或组件的`mixins`列表中：

```vue
<!-- project/components/MixinDemo.vue -->
<script>
// @表示从Vue项目的根目录算起，而非当前目录
import mixin from "@/mixin";

export default {
	name: "MixinDemo",
	mixins: [ mixin ]
}
</script>
```

在全局使用mixin，需要通过`Vue.mixin`方法：

```js
Vue.mixin(mixin);
```

实例：

```js
// mixin.js
export const mixin = {
    methods:{
        showName(){ alert(this.name) }
    },
    //挂载完毕就执行
    mounted() {
        console.log('你好啊')
    }
};

export const shareData = {
    data() { return { x:100, y:200 } }
};
```

```vue
<!-- components/School.vue -->
<template>
   <div >
     <!-- 这里使用了mixin的showName方法 -->
     <h2 @click="showName">学校名称:{{  name }}</h2>
     <h2>学校地址: {{ address }}</h2>
   </div>
</template>

<script>
//引入混合
import {  mixin, shareData } from "@/mixin";
export default {
  name: "School",
  data(){
    console.log(this);
    return {
       name: 'wust',
       address: '武汉科技大学'
    }
  },
  mixins:[ mixin, shareData ]
}
</script>
```

## plugin插件

Vue plugin是一种作用于全局的Vue插件，可以通过向Vue原型插入过滤器、自定义指令、mixin等方式增强Vue的功能。

*插件定义*：Vue plugin必须定义为一个*对象*，该对象需要具备`install`方法，第一个参数必须是`Vue`，后面带0至任意多个参数。

```js
// plugin.js：自定义的插件
export default {
	install(Vue, a, b) {
		...
	}
}
```

*插件使用*：推荐在`main.js`中引入插件JS文件，并执行`Vue.use(plugin, ...)`。`Vue.use`方法的参数个数必须与`install`方法的参数个数一致。

```js
// main.js
import Vue from "vue";
import App from './App';

// 引入插件
import plugin from './plugin';

// 关闭Vue的生产提示
Vue.config.productionTip = false;

// 将插件plugin应用于Vue实例
Vue.use(plugin, a, b); 

new Vue({
    el:'#app',
    render: h => h(App)
});
```

示例：

```js
//vm和vc都可以用
export default {
    install(Vue){
        // 全局过滤器
        Vue.filter('mySlice', function (val){
            return val.slice(0,4);
        });

        // 全局指令
        Vue.directive('fbind', {
            bind(el, binding){
                el.value = binding.value;
            },
            // 指令被插入页面时
            inserted(el, binding){
                el.focus();
            },
            // 指令所在模版被重新解析时
            update(el, binding){
                el.value = binding.value;
            }
        });


        // 全局mixin
        Vue.mixin({
            data: () => { x:1, y:2 };
        });

        // 给vue原型上添加一个方法 vc/vm都可以使用
        Vue.prototype.hello = () => { alert("Hello!"); };
    }
}
```

## scoped样式

Vue组件内可能自带一些样式。`scoped`标签确保这些样式不应用于组件外部。

```vue
<style scoped>
p {
	color: lightgrey;
	font-family: sans-serif;
}
</style>
```

## 案例一：TodoList

详见[[L01-Vue案例：TodoList]]。

## 本地存储

### WebStorage

WebStorage是一种浏览器本地的JS存储机制。

根据时效不同，分为两个容器：
- `Window.sessionStorage`：关闭窗口即毁灭
- `Windows.localStorage`：关闭窗口不会消失，必须手动清理缓存

相关API：
- `xxxStorage.setItem(k, v)`：设置一对键值
- `xxxStorage.getItem(k)`：获取键对应的值
- `xxxStorage.removeItem(k)`：将键值从存储中移除
- `xxxStorage.clear()`：清空存储中的所有数据

