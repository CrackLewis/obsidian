
## 线性回归问题

机器学习四象限：

| 问题类别 | 有监督学习 | 无监督学习 |
| ---- | ----- | ----- |
| 连续   | 回归    | 降维    |
| 离散   | 分类    | 聚类    |

线性回归问题：给定$X_{n\times d}$和$y_{n\times 1}$，求解最合适的$w_{d\times 1}$和$b$，使得：
$$
y_{n\times 1}=X_{n\times d}\cdot w_{d\times 1} + b_{n\times 1}
$$
*最合适*是指：损失函数$L(w,b)$最小：
$$
L(w,b)=\dfrac{1}{2}\sum_{i=1}^n \left(X_iw+b-y_i\right)^2
$$
想要寻找的$w^*,b^*$又可以记作：
$$
w^*,b^*=\underset{w,b}{\text{argmin}}\ L(w,b)
$$

### 解析解

求解线性回归问题的本质是，在N维空间里求解一个与所有点距离最小的超平面。对$L(w,b)$关于$w$求导，取偏导为0，得到$w$的解析解：
$$
w^*=(X^TX)^{-1} X^T y
$$

但不是所有回归问题都有解析解，有些回归则没有。

### 随机梯度下降

随机梯度下降（stochastic gradient descent）：迭代更新模型参数，使得参数逐渐趋近于损失函数最小的位置。

对$w,b$迭代执行如下计算：
$$
(w,b)\leftarrow (w,b)-\dfrac{\eta}{|B|}\sum_{i\in B} \left(\dfrac{\partial L(w,b)}{\partial w},\dfrac{\partial L(w,b)}{\partial b}\right)
$$

### 正态分布与平方损失

根据求出的$w^*,b^*$，规定$y$的预测值与实际值偏差为$\varepsilon$：
$$
y=w^Tx+b+\varepsilon
$$
对于足够庞大的样本$x$，必有$\varepsilon\sim N(0,\sigma^2)$近似成立。因此，可以写出通过$x$观测到特定$y$的似然：
$$
P(y|x)=\dfrac{1}{\sigma \sqrt{2\pi}} \exp\left(-\dfrac{1}{2\sigma^2}(y-w^T x-b)^2\right)
$$
根据极大似然估计法，$w,b$的最优值是使整个数据集的似然最大的值：
$$
P(y|X)=\prod_{i=1}^n p(y_i|X_i)
$$
取对数，得：
$$
-\log P(y|X)=\sum_{i=1}^n \dfrac{1}{2}\log(2\pi\sigma^2)+\dfrac{1}{2\sigma^2}\left(y_i-w^Tx_i-b\right)^2
$$
由于$\sigma$可以视作常数，所以$P(y|X)$最大等价于损失函数最小。

### 线性回归的神经网络描述

线性回归模型可以描述为一个包括$d$个输入结点和1个输出结点的神经网络模型。

![[Pasted image 20240826211728.png]]

该图忽略了一些细节：
- 只展示了连接关系，没有展示权重、偏置等细节。
- 没有描述梯度的反向传播机制。

## 线性回归实现

生成数据：

```python
def synthetic_data(w, b, num_examples):  #@save
    """生成y=Xw+b+噪声"""
    X = torch.normal(0, 1, (num_examples, len(w)))
    y = torch.matmul(X, w) + b
    y += torch.normal(0, 0.01, y.shape)
    return X, y.reshape((-1, 1))

true_w = torch.tensor([2, -3.4])
true_b = 4.2
features, labels = synthetic_data(true_w, true_b, 1000)
```

对数据进行可视化处理（生成散点图）：

```python
d2l.set_figsize()
d2l.plt.scatter(features[:, 1].detach().numpy(), labels.detach().numpy(), 1)
```

定义一个数据迭代器，可根据批次大小，逐批次读取数据集：
（*注意*：这里的迭代器并不高效。最好还是用框架自带的迭代器）

```python
def data_iter(batch_size, features, labels):
    num_examples = len(features)
    indices = list(range(num_examples))
    # 这些样本是随机读取的，没有特定的顺序
    random.shuffle(indices)
    for i in range(0, num_examples, batch_size):
        batch_indices = torch.tensor(
            indices[i: min(i + batch_size, num_examples)])
        yield features[batch_indices], labels[batch_indices]

batch_size = 10

for X, y in data_iter(batch_size, features, labels):
	print(X, '\n', y)
```

初始化模型参数$w,b$：

```python

```