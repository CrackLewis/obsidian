
## 图的基本概念

### 图的定义

图的定义：图$G$=顶点集$V$+边集$E$，记作$G=(V,E)$。

有向图：由有向边组成的图。
- 有向边（弧）：带有方向信息的边，记作$<u,v>$。

无向图：由无向边组成的图。
- 无向边（边）：记作$(u,v)$。

简单图、多重图：
- 简单图：不带**重边**和**自环**
- 多重图：允许重边和自环的图

完全图：任意两点都有一条边（或两条对向的弧）连接的图
- 边数：无向图$\dfrac{n(n-1)}{2}$，有向图$n(n-1)$。

**子图**：$G'=(V',E')$满足$V'\subset V$和$E'\subset E$。
- 生成子图：$V(G')=V(G)$。

### 图的连通概念

连通、连通图、连通分量：
- （顶点$u,v$）连通：在**无向图**$G$中，对于$v,w\in V(G)$，存在$v$到$w$的路径
- 连通图：$\forall u,v\in V(G)$，$u,v$连通
- 连通分量：**无向图中的极大连通子图**，任何连通分量加入图中的任何一个其余顶点，都不再连通。

强连通图、强连通分量：
- 强连通图：在**有向图**$G$中，对于$\forall v,w\in V(G)$，$u$到$v$和$v$到$u$的路径都存在
- 强连通分量：**有向图中的极大强连通子图**。

**讨论连通性都是在无向图，讨论强连通性都是在有向图。**

生成树、生成森林：
- 生成树：**连通图中**，包含图中全部顶点的极小连通子图，去除任何一条边都不再连通。
- 生成森林：**非连通图中**，所有连通分量生成树的集合。

### 图的疏密概念

顶点的度：
- 无向图：顶点$v$的度指依附于顶点$v$的边数，记作$TD(v)$。
- 有向图：
	- 入度：以顶点$v$为终点，$ID(v)$
	- 出度：以顶点$v$为起点，$OD(v)$
- 度和边数的关系：$\displaystyle TD(v)=\displaystyle ID(v)+\displaystyle OD(v)=2|E|$。

边的权和网：边的权值信息。
- 带权图：边带权值的图，又称网。

稠密图、稀疏图：$|E|-|V|\log |V|$。

### 图的路径概念

路径、路径长度、回路：
- 路径：由边直接相连的顶点组成的序列
- 路径长度：路径上边的数量
- 回路：第一个顶点和最后一个顶点相同的路径
- **简单路径**：顶点不重复出现的路径
- 简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的路径
- （顶点$u,v$之间的）距离：$u$到$v$的最短路径长度（如果存在），如不存在则为$\infty$。

有向树：一个顶点入度为0，其余顶点入度均为1。

## 图的存储和基本操作

存储方法：
- 邻接矩阵法：空间$O(n^2)$
- 邻接表法：无向图空间$O(n+2m)$，有向图空间$O(n+m)$
- 十字链表法：仅有向图，空间$O(n+m)$
- 邻接多重表法：仅无向图，空间$O(n+2m)$

### 邻接矩阵法

```cpp
struct MGraph {
	char Vex[100];
	int Edge[100][100];
	int vexnum, arcnum;
};
```

矩阵权值：
- 无权图：0（无边）/1（右边）
- 有权图：$\infty$或0（无边）/权值数（有边）

特点：
- 对无向图，矩阵必为对称矩阵
- 查某行（列）的边数即对应对应顶点的出度（入度）

### 邻接表法

```cpp
struct ArcNode {
	int adjvex; // 该弧指向哪个顶点
	ArcNode *next; // 该弧的后继弧指针
};
struct VNode {
	int data; // 顶点数据
	ArcNode *first; // 该顶点的第一条弧
}
struct ALGraph {
	VNode vertices[100];
	int vexnum, arcnum;
};
```

邻接表与[[#邻接矩阵法]]对比：
- 适用场合：邻接表更适合稀疏图，邻接矩阵更适合稠密图
- 运算时间：
	- 邻接表在找顶点的出边上有优势
	- 邻接矩阵在查边权值、确定连接关系上有优势
- 同一个图的邻接矩阵往往是唯一的，但邻接表往往不唯一。

### 十字链表法

**仅限有向图**，类似于邻接表。

```cpp
// 弧结点
struct ArcNode {
	int headvex; // 弧头顶点的编号
	int tailvex; // 弧尾顶点的编号
	ArcNode* hlink; // 弧头相同的下一条弧指针
	ArcNode* tlink; // 弧尾相同的下一条弧指针
	// 可以放弧数据
};
// 顶点结点
struct VNode {
	int data;
	ArcNode* firstin; // 第一条出边
	ArcNode* firstout; // 第一条入边
};
```

本质是邻接表的扩展，针对性解决邻接表难于遍历单一顶点所有入边的问题。空间上是$O(n+m)$。

### 临界多重表法

**仅限无向图**，类似于邻接表。

```cpp
// 弧结点
struct ArcNode {
	// 依附的一端顶点编号和下一条边
	int ivex;
	ArcNode* ilink;
	// 依附的另一端顶点编号和下一条边
	int jvex;
	ArcNode* jlink;
	// 可以放弧数据
};
// 顶点结点
struct VNode {
	int data;
	ArcNode* firstedge;
	// 因为是有向图，所以不区分出入边
};
```

本质是邻接表的扩展。空间上是$O(n+2m)$。

### 图的基本操作

近些年的DS大题也基本不让你有机会手写这些操作。这里只是列写一下：
- `Adjacent(G,x,y)`：判断是否存在边$<x,y>$或$(x,y)$。
- `Neighbors(G,x)`：列出图中$x$的邻边。
- `InsertVertex(G,x)`：插入顶点x。
- `DeleteVertex(G,x)`：删除顶点x。
- `AddEdge(G,x,y)`：如边$(x,y)$不存在，则加入该边。
- `RemoveEdge(G,x,y)`：如边$(x,y)$存在，则删除该边。
- `FirstNeighbor(G,x)`：返回x的第一个邻接点，如无邻接点则返回-1。
- `NextNeighbor(G,x,y)`：返回x的邻接点中，紧随y后的那一个，如果y不是x的邻接点或y是最后一个邻接点则返回-1。
- `Get_edge_value(G,x,y)`：获取$(x,y)$的权值。
- `Set_edge_value(G,x,y,v)`：将$(x,y)$的权值设置为$v$。

## 图的遍历

遍历方法及其复杂度：
- BFS：
	- 空间：均为$O(n)$，成本为辅助队列
	- 时间：
		- 邻接表法：$O(n+m)$，分别为访点和访边成本
		- 邻接矩阵法：$O(n^2)$，为每个顶点查找邻接点的成本
- DFS：
	- 空间：均为$O(n)$，成本为递归栈
	- 时间：复杂度组成与BFS相同。
		- 邻接表法：$O(n+m)$
		- 邻接矩阵法：$O(n^2)$

### 广度优先搜索（BFS）

```cpp
bool visited[100];
void bfs_traverse(Graph G) {
	for(i=0;i<G.vexnum;++i)
		visited[i]=false;
	init_queue(Q);
	for(i=0;i<G.vexnum;++i)
		if(!visited[i])
			bfs(G,i);
}
void bfs(Graph G, int v) {
	visit(v);
	visited[v]=true;
	enqueue(Q,v);
	while(!is_empty(Q)) {
		dequeue(Q,v);
		for(w=first_neighbor(G,v);w>=0;w=next_neighbor(G,v,w)){
			if(!visited[w]){
				visit(w);
				visited[w]=true;
				enqueue(Q,w);
			}
		}
	}
}
```

应用：
- 求无权图单源最短路
- 一些最优解问题

广度优先生成树：对于邻接矩阵表示的图，生成树唯一，对于邻接表表示的图则不唯一。

### 深度优先搜索（DFS）

```cpp
bool visited[100];
void dfs_traverse(Graph G) {
	for(v=0;v<G.vexnum;++v)
		visited[v]=false;
	for(v=0;v<G.vexnum;++v)
		if(!visited[v]) dfs(G,v);
}
void dfs(Graph G, int v){
	visit(v);
	visited[v]=true;
	for(w=first_neighbor(G,v);w>=0;w=next_neighbor(G,v,w)){
		if(!visited[w]) dfs(G,w);
	}
}
```

用途：
- 一些最优解问题

深度优先生成树：与BFS生成树类似，有唯一性方面的问题。

### 图的遍历和连通性

图的遍历算法可以判断图的连通性。

## 图的应用

汇总：
- 最小生成树问题：
	- Prim：时间$O(n^2)$
	- Kruskal：时间$O(m\log_2 m)$ 
- 最短路问题：
	- Dijkstra：时间$O(n^2)$（通过堆优化可以降到$O(n\log_2 n)$）
	- Floyd：时间$O(n^3)$。
- DAG表达式
- 拓扑排序：邻接表时间$O(n+m)$，邻接矩阵时间$O(n^2)$
- **关键路径问题**

### Prim

从初始点开始，对于当前的顶点集，选取一端连接集合内点、另一端连接集合外点的边权最短的边，将该边连接的集合外点加入到集合，最后扩展到包含图中所有顶点。

### Kruskal

从空集开始，从图中选取一条最短的、与当前所选边集不构成环的边，加入集合，直到边数为$n-1$。

### Dijkstra

从源点开始，对当前与源点距离最短的顶点逐个进行松弛，直到所有顶点与源点的距离都被确定为最短路径。

### Floyd

$n^3$暴力。
$$
D(i,j)=\min(D(i,j),D(i,k)+D(k,j)),k\neq i,j
$$

### DAG表达式

DAG：directed acyclic graph，有向无环图

将重复出现的表达式逐级向上合并。

### 拓扑排序

步骤：
- 从AOV网中选取一个没有前驱（入度为0）的结点并输出
- 删除该结点及其所有出边
- 重复上述步骤，直到没有满足要求的顶点
	- 顶点有剩余：有环，无法排序
	- 顶点无剩余：无环，排序完成

**逆拓扑排序**

### 关联路径问题

<p style="font-size: 48px">重要！</p>

AOE网：activities on edges，用边表示活动、用顶点表示事件的网络。
- 活动：一个过程，如：基于v1.4.0修bug
- 事件：一个状态，如：bug修完了，当前是v1.4.1
- 源点：工程的开始
- 汇点：工程的结束

**关键路径**：工程上来讲，只有一个事件的所有前置活动均完成，才能触发这个事件。所以事件的触发时间为所有前置活动完成时间的最大值。汇点事件的发生时间是从源点到汇点的最长路，任一符合要求的最长路均称为关键路径。

**关键活动**：关键路径上的所有活动。

#### 关键路径的事件参量

事件的**最早发生时间**$ve(k)$：事件$k$可能发生，即事件$k$的**所有前置活动全部进行完毕**的最早时刻：
$$
ve(k)=\left\{\begin{matrix}0, & k为源点\\ \max(ve(j)+w(j,k)),<j,k>\in G, & 其他\end{matrix}\right.
$$

事件的**最迟发生时间**$vl(k)$：事件$k$在不推迟工期的前提下发生的最晚时间：
$$
vl(k)=\left\{\begin{matrix}ve(k), & k为汇点\\ \min(vl(k)-w(k,j)),<k,j>\in G, & 其他\end{matrix}\right.
$$

事件的最早发生时间通过拓扑排序计算，最迟发生时间通过逆拓扑排序计算。

#### 关键路径的活动参量

活动的**最早开始时间**$e(i)$：设$i=<k,j>$，则$e(i)=ve(k)$。

活动的**最迟开始时间**$l(i)$：设$i=<k,j>$，则$l(i)=vl(j)-w(k,j)$。

活动的最迟开始时间和最早开始时间的**差额**$d(i)$：描述一个活动的时间余量，在不耽误工期的前提下，它能拖延多久。

性质：
- 关键活动满足$e(i)=l(i)$和$d(i)=0$。

### 求解关键路径的算法

- 从源点出发，按拓扑序计算各事件的最早发生时间$ve(k)$。
- 从汇点出发，按逆拓扑序计算各事件的最迟发生时间$vl(k)$。
- 根据$ve(k)$求所有活动的最早开始时间。
- 根据$vl(k)$求所有活动的最迟开始时间。
- 求出所有满足$e(i)=l(i)$的活动，并将其标记为关键活动。

