
## 概述

- 基本概念：静态查找、动态查找
- 线性结构：顺序、折半、分块查找
- 树形结构：二叉排序树、二叉平衡树、红黑树、B树、B+树
- 散列结构：散列表（性能分析、冲突处理）
- 效率指标：平均查找长度

## 查找的基本概念

查找：在数据集合中找符合特定条件的数据元素。
- 结果：查找成功（返回索引）、查找失败

查找结构（查找表）：用于查找的数据集合。
- 操作：增、删、访、查
- 静态查找结构（静态查找表）：不涉及增删的查找结构

关键字：查找结构中数据元素的唯一标识。

**平均查找长度**（ASL）：一次查找平均要进行的关键字比较次数，用于衡量查询时间效率。
- 定义：$ASL=\displaystyle\sum_{i=1}^n P_i C_i$，$P_i$为查找第$i$个元素的概率（随机查找满足$P_{i}=\dfrac{1}{n}$），$C_i$为查找第$i$个元素需要的关键字比较次数。
- **注意：计算平均查找长度不要拘泥于ASL公式。如果数据量特别小，一定要手算！**

## 顺序查找、折半查找和分块查找

讨论查找效率，我们不主要考察复杂度，而是考察ASL。

**ASL对比**：
- 一般线性表：
	- 顺序查找：成功$\dfrac{n+1}{2}$，不成功$n+1$。
	- 折半查找：不适用。
	- 分块查找：$\dfrac{s^2+2s+n}{2s}$（$s$为平均块长）。
- 有序表：
	- 顺序查找：成功$\dfrac{n+1}{2}$，不成功$\dfrac{n}{2}+\dfrac{n}{n+1}$。
	- 折半查找：$\log_2(n+1)-1$（仅顺序表）。
	- 分块查找：$\dfrac{s^2+2s+n}{2s}$。

### 顺序查找

字面意思。

为啥上面的ASL都是$n+1$：王道书上介绍，线性表进行顺序查找时，将被查找的元素放在表的头部或末尾，这样不必特殊处理查找失败的情形。

为啥要区分成功和不成功的结果：查找结构中的元素必会成功查找，所以按成功查找计算；不在查找结构中的元素必会查找不成功，所以按不成功查找分开计算。

有序表的顺序查找判定树：
![[Pasted image 20230604135736.png]]

### 折半查找（二分查找）

**注意**：王道书上给定的是**抠去中心点的二分查找**版本：

```cpp
int binary_search(L, key) {
	int low = 0, high = L.length - 1, mid;
	while (low <= high) {
		mid = (low + high) >> 1;
		if (L[mid] == key)
			return mid;
		else if (L[mid] > key)
			high = mid - 1;
		else
			low = mid + 1;
	}
	return -1;
}
```

**二分查找的判定树**：描述二分查找过程的二叉树，是一颗平衡二叉树。

![[Pasted image 20230604135842.png]]

### 分块查找（索引顺序查找）

将整个查找表分为若干子块，各块保证块间有序，块内可以无序。如：
```
[ [2 5 6 3] [8 7 14 7 9] [16 21 18 17] ]
```

建立一个索引表，记录各块的最大关键字和第一个元素的地址。

查找步骤：
- **索引查找**：依次比对各个索引的最大关键字，确定元素属于哪个索引
- **块内查找**：在索引内，执行顺序查找。

ASL分析：设分为$b$块，块的平均大小为$s$，满足$b=\dfrac{n}{s}$。
- 索引查找：$L_I=\dfrac{b+1}{2}=\dfrac{n+s}{2s}$。
- 块内查找：$L_S=\dfrac{s+1}{2}$。
- 综合ASL：$ASL=L_I+L_S=\dfrac{s^2+2s+n}{2s}$。

特别地，如果块长满足$s=\sqrt{n}$，则ASL取得理论最小值$ASL=\sqrt{n}+1$。

## 树型查找

**红黑树杀人事件**

汇总：
- 二叉排序树（BST）
- 平衡二叉树（AVL）
- 红黑树（RBT）
- B树和B+树

### 二叉排序树

定义：
- 空树是二叉排序树。
- 符合下列约束的二叉树是二叉排序树：
	- 左子树、右子树是二叉排序树。
	- 若左子树非空，则其所有元素小于根结点元素
	- 若右子树非空，则其所有元素大于根节点元素

查找：从根节点开始，沿某个分支向下查找。

插入：
- 当前子树为空则直接插入
- 否则，将插入值和根结点值比较：
	- 相等：朴素的二叉排序树不允许重复值，插入失败。
	- 插入值更大：进入右子树
	- 根节点值更大：进入左子树

构造：依次插入各初始元素即可。

**删除**：三种情形。
- 叶结点：直接删除。
- 只有一棵子树：让子树替代位置。
- 有两棵子树：**移除其后继结点**（右子树的最左结点），并让其替代位置。移除后继结点的过程转化为了前两种情况（因为一定没有左子树）。

查找效率分析：查找时间取决于树的高度。
- 理想的BST情形：$O(\log n)$。
- 糟糕的BST情形：$O(n)$。

### 平衡二叉树（AVL）

**全文高能，建议配合代码食用。**

AVL定义：
满足**平衡性质**的二叉排序树：任意时刻，左右子树的高度差（平衡因子）的绝对值不能超过1。

王道书中直接称AVL是平衡二叉树的缩写。但AVL事实上是自平衡的二叉树中的一种。

```cpp
struct AVLNode {
  int data_;
  AVLNode *parent_, *left_, *right_;
};
```

旋转：旋转是不平衡子树恢复平衡状态的手段。
- 左旋：某个BST的平衡因子达到了-2，则需要一次左旋，使平衡因子恢复为0。
- 右旋：某个BST的平衡因子达到了2，则需要一次右旋，使平衡因子恢复为0。

根据失衡情形，进一步细分为**LL、LR、RL、RR情形**。
![[Pasted image 20230604155128.png]]

- LL：对根右旋一次。
- RR：对根左旋一次。
- LR：先对左儿子左旋一次（转化为LL），再对根右旋一次。
- RL：先对右儿子右旋一次（转化为RR），再对根左旋一次。

插入操作：
插入结点后，如果出现失衡，调整结点的曾祖父结点（三代父结点）结点对应的子树即可。

删除操作：
删除结点后，如果出现失衡，则可能需要逐级向上调整，甚至要调整整棵AVL树的根结点。这是因为插入操作不改变除插入位置附近结点外的平衡性，而删除操作可能牵一发而动全身。

### 红黑树

红黑树是一种特殊的平衡二叉树。出于降低AVL因失衡而频繁改变形态的情形，它适当放宽了平衡条件。

性质：红黑树是满足如下性质的二叉排序树：
- 每个结点是红色的或黑色的。
- 根结点是黑色的。
- 叶结点（虚构的外部结点和NULL结点）都是黑色的。
- 不存在两个相邻的红色结点，即红色结点的父结点和子结点都是黑色结点。
- 对任一结点而言，从该结点到任一叶结点的简单路径中的黑色结点数目相同。

结论：
- 从根节点到叶结点的最长路径长度不超过最短路径长度的2倍。
- 有$n$个内部结点的红黑树的高度不超过$2\log_2(n+1)$。

与AVL的权衡利弊：
- 平衡性：红黑树主张适度平衡，AVL主张高度平衡
- 适用情形：
	- 增删密集情形：红黑树更佳，可以降低形态调整的频率。
	- 改查密集情形：AVL更佳，其ASL更低。

插入和删除：
**这块是个大坑，真题还没考过，有空再看罢。**

### B树和B+树

$m$路B树：
- 一句话定义：所有结点平衡因子均为0的$m$路平衡查找树。
- 特征：空树，或符合如下特性的$m$叉树：
	- 树中每个结点至多有$m$棵子树，即至多含有$m-1$个关键字。
	- 若根节点不是叶结点，则至少有两棵子树。
	- 除根结点外的所有非叶节点至少有$\left\lceil\dfrac{m}{2}\right\rceil$棵子树，即至少含有$\lceil m/2\rceil -1$个关键字。
	- 所有的非叶结点有$2n+2$个字段（$n$为结点关键字数量）：
		- 第一个字段：关键字个数
		- 随后的字段：$P_0,K_1,P_1,K_2,P_2,\cdots,K_n,P_n$。$P_{i-1}$表示索引小于$K_i$的子树，$P_n$表示索引大于$K_n$的子树。
	- 所有的叶结点都出现在同一层次上，不带任何信息。（实际可以被当空气）

性质：
![[Pasted image 20230604171516.png]]
上面是一个5阶B树的实例。
- 结点的孩子个数=结点的索引数量+1。
- 根节点无关键字，则B树为空，否则其子树个数不低于$\lceil m/2 \rceil$，本例对应为不低于3个子树。
- 结点内的关键字应满足**递增有序**。

**B树的高度**：
讨论度数$m$和总结点数$n$固定时，高度的上限和下限。这里的外部结点（叶结点）不算在内。

高度的下限情形：所有结点的度数最大（$m$），结点数满足：
$$
n\le (m-1)(1+m+m^2+\cdots +m^{h-1})=m^h-1
$$
即$h_{\min}=\log_m (n+1)$。

高度的上限情形：所有结点的度数最小（$\lceil m/2 \rceil$），结点数满足：
$$
n+1\ge 2(\lceil m/2 \rceil)^{h-1}
$$
即$h_{\max}=\log_{\lceil m/2 \rceil} ((n+1)/2)+1$。

**B树的查找**：多路分支，递归下降。
- 在B树内找结点：根据结点号，从磁盘取B树结点，读到内存。
- 在结点内找关键字：在B树结点内检索关键字，取得下一级B树结点的编号。
检索规则：
- 如果恰等于某一关键字，则返回当前结点
- 如果与所有关键字都不一致，则落到对应的子结点
- 如果落到叶结点（对应空指针），说明查找失败

**B树的插入**：
- 定位：通过查找，确定插入关键字的最底层的某个非叶节点。
- 插入：如果结点关键字个数少于$m-1$，可以直接插入。否则说明结点已满，需要通过**分裂**的方式为结点扩容。
- 分裂：如果结点已满，则需要开辟一个新结点，并对$m$个关键字进行如下操作：
	- 前$\lceil m/2 \rceil-1$个关键字：放在原结点
	- 后$\lfloor m/2 \rfloor$个关键字：放在新开的结点，新开的结点作为原结点的后继兄弟
	- 中间一个关键字：放在原结点父亲结点的后面。
	- 如果父结点也已满，则继续分裂。

![[Pasted image 20230604200817.png]]

**B树的删除**：被删关键字分为“在终端结点”和“不在终端结点”两种情形。
- 不在终端结点的情形：先删除被删关键字的前驱（前驱必在终端结点），再将被删关键字原位替换为前驱关键字。
- 在终端结点的情形：
	- 结点关键字有余：直接删除。
	- 结点关键字不足：关键字恰有$\lceil m/2 \rceil-1$个，不能直接删除。这时需要考虑“借”一个关键字，或者合并另一个结点。
		- 兄弟够借：左右至少一个兄弟有$\lceil m/2\rceil$个或更多结点，则考虑借一个过来。被借的结点缩小一个关键字位置，删除的关键字腾出位置，关键字直接平移。
		- 兄弟不够借：两侧（如果是边界结点，单侧）兄弟的关键字同样不足，则考虑合并一个结点，以及两个结点中间的关键字。新结点大小为$2\lceil m/2\rceil -2$，不会超出限制。如果由于合并，父结点的结点个数过少，则需要向上合并。

下面是删除关键字的示例，其中的B树为4阶。
![[Pasted image 20230604202523.png]]

**B+树**：跟B树区别挺大的。。。所幸只考概念。

定义：$m$阶的B+树应当满足下列要求：
- 一个分支结点（非叶结点）最多有$m$棵子树。
- 非叶根结点至少有两棵子树，其他分支结点至少有$\lceil m/2\rceil$棵子树。
- 结点的子树个数与关键字的个数**相等**。
- 所有叶结点包含**全部的关键字**及指向相应记录的指针，叶结点中将关键字按大小顺序排列，相邻叶结点按大小顺序相互链接。
- 所有分支结点中仅包含它的各个子结点中关键字的最大值及指向其子结点的指针。

**与B树的差异**：
- 子树个数（$n$个关键字）：B树为$n+1$棵子树，B+树为$n$棵。
- 关键字个数范围：B树（$\lceil m/2\rceil -1\le n\le m-1$），B+树（$\lceil m/2\rceil\le n\le m$）
- 关键字重复性：B树结点的关键字互不重复，B+树结点符合下一层包含上一层的特点
- 结点作用：B树的所有非叶结点都存储实际的数据。B+树只有终端结点存储数据，其余非叶结点只有索引作用。

## 散列表

基本概念：
- 散列函数：将查找结构内的关键字映射为关键字对应地址的函数，记作$H(key)=addr$。
	- **散列冲突**：散列函数存在将两个关键字（**同义词**）映射为同一个地址的可能情形。这种情形不可避免，但应当被降低和妥善处理。
- **散列表**：根据关键字直接进行访问的数据结构。
	- 查找时间：$O(1)$。

### 散列函数的构造方法

注意：
- 定义域必须包含所有关键字。
- 散列函数计算出来的地址应当等概率、均匀分布在地址空间，降低冲突概率。
- 散列函数应尽量简单，耗时应较低。

**直接定址法**：直接取关键字的某个线性函数值做地址：$H(x)=ax+b$。

**除留余数法**：设散列表容量为$m$，取一个离$m$近但不超过$m$的质数$p$。取关键字对该质数取模的结果作为地址：$H(x)=x\bmod p$。

**数字分析法**：该方法只适用于已知关键字集合或集合数字特征的情形。
分析各关键字的$r$进制表示。各个关键字在部分的$r$进制位上的分布足够均匀，但在另一些位则没那么均匀。选择关键字由分布均匀$r$进制位组成的值作为地址，会使均摊的哈希冲突概率最低。

一个简单的例子：$r=2$（二进制），关键字集合满足大部分关键字都是3的幂（指数分布均匀）。
观察二进制表示的最低两位，发现$n$为偶数时：
$$
3^n\equiv (2\cdot 4+1)^{\frac{n}{2}}\equiv 1\pmod 4
$$
而$n$为奇数时：
$$
3^n\equiv 3\cdot 3^{n-1}\equiv 3\pmod 4
$$
这说明大部分关键字的最低两位或为01，或为11。显然大部分关键字的最后一位都是1，不符合分布均匀的条件，不应作为关键字的组成部分；而倒数第二位的分布相对均匀，适合作为关键字的组成部分。

**平方取中法**：
如果关键字的每位都不够均匀，可以考虑取关键字**平方结果的中间几位**，具体取多少位取决于关键字的数字特征。

### 散列冲突的处理方法

冲突的一般解决方法：重新找一个未被占用的散列地址。

#### 开放定址法

可存放新表项的空闲地址既向它的同义词开放，也向它的非同义词开放。数学递推公式：
$$
H_i=(H(x)+d_i)\bmod m
$$
$H(x)$为使用的散列函数，$m$为散列表长，$d_i$为不同探测方法采用的增量序列，$H_i$（$i=0,1,2,\cdots,k$，$k\le m-1$）为散列的探测序列。

**线性探测法**：$d_i=0,1,2,\cdots,m-1$，$k=m-1$。
特点：简单，但可能造成有大量同义词的地址附近发生堆积，降低散列和查找效率。

**平方探测法**（**二次探测法**）：$d_i=0,1,-1,2^2,-2^2,3^2,-3^2,\cdots,k^2,-k^2$，$2k+1\le m$。
特点：
- $m$必须满足：存在$k$使得$m=4k+3$。
- 避免了堆积问题，但对散列表空间的利用率不高。

**双散列法**：使用另一个散列函数计算出探测序列：$d_i=i\cdot H'(x)$。具体散列函数满足：
$$
H_i=(H(x)+i\cdot H'(x))\bmod m
$$

**伪随机探测法**：$d_i$是伪随机树序列。

#### 拉链法

为了避免非同义词冲突，可以把所有的同义词存储在一个线性链表中。

示例：以关键字序列$[19,14,23,01,68,20,84,27,55,11,10,79]$按照散列函数$H(x)=x\bmod 13$，通过线性探测处理冲突构造得到的散列表：
![[Pasted image 20230605113005.png]]

### 散列查找和性能分析

查找步骤：
- 初始化：地址$y=H(x)$
- 根据散列地址查**查找表**：
	- 无记录：查找失败
	- 有记录，且匹配关键字：查找成功
	- 有记录，但不匹配关键字：进入下一步
- 不匹配关键字情形的处理：用给定的冲突解决方法计算下一个散列地址，重复上述步骤。

示例：以关键字序列$[19,14,23,01,68,20,84,27,55,11,10,79]$按照散列函数$H(x)=x\bmod 13$，通过线性探测处理冲突构造得到的顺序散列表：
![[Pasted image 20230605125013.png]]
查找关键字84：
- $H(84)=6$，但$L[6]=19\neq 84$，说明84可能在其他位置。
- $d_1=1$，$6+d_1=7$，$L[7]=20\neq 84$，说明84可能在其他位置。
- $d_2=2$，$6+d_2=8$，$L[8]=84$，查找完毕，关键字84在散列表中的下标为8。
查找关键字38：
- $H(38)=12$，$L[12]=10\neq 38$，继续探测。
- $d_1=1$，$12+d_1=13$，$L[13]=0$，说明38不存在。

**散列查找的性能分析**：
对每个散列表内的关键字执行查找，记录它们的比较次数，并求平均值。

同样是以上面的情形为例，计算ASL：
![[Pasted image 20230605125846.png]]
（感谢王道让我薅羊毛）

**结论**：
- 虽然散列表存储了关键字和记录的存储位置之间的一一关系，但由于散列冲突的存在，散列查找仍然是一个给定值和关键字的比较过程。
- 散列表的查找效率的影响因素可以归结为三个：
	- 装填因子：一个表的填满程度：$\alpha=\dfrac{记录数n}{表容量m}$
	- 散列函数
	- 处理冲突的方法

