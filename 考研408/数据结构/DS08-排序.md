
## 概述

考纲考察的内容：
- 排序的基本概念
- 插入排序：直接插入排序、折半排序、希尔排序
- 交换排序：冒泡排序、快速排序
- 选择排序：简单选择排序、堆排序
- 二路归并排序
- 基数排序
- 外部排序
- 排序算法的分析和应用

## 基本概念

**排序定义**：重排线性表中元素，使其按关键字有序。
- 输入：$n$个记录$R_1,R_2,\cdots,R_n$，关键字分别为$k_1,k_2,\cdots,k_n$。
- 输出：输入记录的重排$R_1',R_2',\cdots,R_n'$，使得$k_1'\le k_2'\le \cdots\le k_n'$。

**排序算法的稳定性**：如果任何操作前后，关键字相同的元素的相对顺序不改变，则称该排序算法是稳定的，否则是不稳定的。

按被排序记录的位置，可将排序算法分为两类：
- **内部排序**：所有被排序记录均驻在内存中。
	- 大部分内部排序算法都依赖比较、移动两种操作。
		- 一个例外是基数排序算法。
- **外部排序**：所有记录无法同时存储在内存中，必须在排序过程中将元素不断在内存、外存间移动。

## 插入排序

基本思想：每次将一个待排序的记录按关键字大小插入前面已排好序的子序列，直到全部记录插入完成。

三个插入排序算法：直接插入排序、折半插入排序、希尔排序。

### 直接插入排序

假设某一时刻的线性表状态：
![[Pasted image 20230616213057.png]]

要将`L[i]`插入左侧的有序序列，需要如下步骤：
- 查找出`L[i]`在`L[1...i-1]`中的插入位置`k`
- 将`L[k...i-1]`中的所有元素依次右移一个位置
- 将`L[i]`复制到`L[k]`

对一个线性表进行直接插入排序可以描述为：将`L[2]`到`L[n]`的所有元素依次插入到左侧。

王道给出的示例代码使用哨兵法，进行升序排序：
```cpp
void InsertSort(int A[], int n) {
	int i,j;
	//枚举待插入元素的位置
	for(i=2;i<=n;++i){
		//如果A[i]>=A[i-1]，不必参与插入
		if(A[i]<A[i-1]){
			//将当前待插入元素放入哨兵位置
			A[0]=A[i];
			//枚举到一个合适的插入位置
			for(j=i-1;A[0]<A[j];--j)
				A[j+1]=A[j];
			//将暂存于哨兵位置的待插入元素放回
			A[j+1]=A[0];
		}
	}
}
```

空间复杂度：$O(1)$。
时间复杂度：$O(n^2)$。
- 最好情形：$n$次操作
- 最坏情形：比较次数$\dfrac{n^2+n-2}{2}$，移动次数$\dfrac{n^2+3n-4}{2}$
稳定性：稳定。
适用性：顺序表、链表。

### 折半插入排序

直接插入排序中找插入位置的时间太慢，可以优化。

```cpp
void InsertSort(int A[], int n){
	int i,j,low,high,mid;
	for(i=2;i<=n;++i){
		if(A[i]>=A[i-1]) continue;
		A[0]=A[i];
		low=1,high=i-1;//初始化查找边界
		//折半查找得到插入位置
		while(low<=high){
			mid=(low+high)/2;
			if(A[mid]>A[0]) high=mid-1;
			else low=mid+1;
		}
		//插入位置为high+1，该位置及其右侧的元素右移
		for(j=i-1;j>=high+1;--j)
			A[j+1]=A[j];
		A[high+1]=A[0];
	}
}
```

空间复杂度：$O(1)$
时间复杂度：$O(n^2)$，主要是元素移动成本难于优化。
- 最好情形：$n$次操作
- 最坏情形：$n\log_2 n$次比较，约$\dfrac{n^2}{2}$次移动
稳定性：稳定。
适用性：顺序表。

### 希尔排序（缩小增量排序）

基本思想：
- 将待排序表分割为若干个形如$L[i,i+d,i+2d,\cdots,i+kd]$的特殊子表，即把相隔某个“增量”的记录组成一个子表。
- 对各个子表分别进行直接插入排序。
- 当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。

过程：
- 先取一个步长$d_1<n$，把表中的所有记录分为$d_1$组，所有距离为$d_1$的倍数的记录放在同一组，在各组内直接插入排序。
- 取第二个步长$d_2<d_1$，重复上述过程。
- 不断缩小步长，直到$d_t=1$，即所有记录在同一组。此时全表呈现高度的局部有序，可以较快地完成直接插入排序。

王道同样使用哨兵法：
```cpp
void ShellSort(int A[], int n){
	int dk,i,j;
	//枚举增量
	for(dk=n/2;dk>=1;dk/=2){
		//组内直接插入排序：这里将各组的排序过程合并了
		for(i=dk+1;i<=n;++i){
			if(A[i]<A[i-dk]){
				A[0]=A[i];//暂存哨兵位置
				//在组内依次右移元素
				for(j=i-dk;j>0&&A[0]<A[j];j-=dk)
					A[j+dk]=A[j];
				A[j+dk]=A[0];//填回元素
			}
		}
	}
}
```

空间复杂度：$O(1)$
时间复杂度：$O(n^2)$
- 最佳情形：$n$在某个特定范围时，复杂度满足$O(n^{1.3})$。
- 最坏情形：$O(n^2)$。
稳定性：不稳定。相同关键字的记录如果在不同组，可能会被改变相对次序。
适用性：顺序表。

## 交换排序

基本思想：根据序列中两个元素关键字的比较结果，对换两个记录在序列中的位置。

两种（考研会考的）交换排序算法：冒泡排序、快速排序。

### 冒泡排序

基本思想：从后往前（或从前往后）两两比较相邻元素的值，如果逆序则交换它们，直到序列比较完毕，称为一轮冒泡。序列完全有序需要至多$n$轮冒泡。

![[Pasted image 20230616221342.png]]

代码：
```cpp
void BubbleSort(int A[], int n){
	bool flag;
	//L[0..i]是已经有序的序列。
	for(i=0;i<n-1;++i){
		flag=false;
		//倒序枚举i之后的每个位置
		for(j=n-1;j>i;--j){
			if(A[j-1]>A[j]){
				swap(A[j-1],A[j]);
				flag=true;
			}
		}
		//优化：如果一轮下来没有对换，则说明已经有序
		if(flag==false)
			return;
	}
}
```

空间复杂度：$O(1)$
时间复杂度：$O(n^2)$
- 最佳情形（正序）：$O(n)$
- 最坏情形（逆序）：$\dfrac{n(n-1)}{2}$次比较，$\dfrac{3n(n-1)}{2}$次移动。
稳定性：稳定。
适用性：顺序表、链表（较麻烦）。

### 快速排序

基本思想：
- 在待排序表`L[1...n]`中任取一个元素`pivot`作为枢轴（通常取首元素）。
- 通过一趟排序，将待排序表划分为独立的两部分`L[1...k-1]`和`L[k+1...n]`，使得`L[1...k-1]`中所有元素小于`pivot`，`L[k+1...n]`中的所有元素大于或等于`pivot`，则`pivot`放在了其最终位置`L[k]`上，这个过程称为一趟快速排序。
- 对区间`L[1...k-1]`和`L[k+1...n]`递归运用上述排序方法，直到每部分只有一个元素或者为空。

一趟快速排序的过程是一个交替搜索和交换的过程。下面是一个实例：
![[Pasted image 20230616231423.png]]
![[Pasted image 20230616231459.png]]

快速排序算法：
```cpp
void QuickSort(int A[], int low, int high) {
	if(low<high){
		int pivotpos=Partition(A,low,high);
		QuickSort(A,low,pivotpos-1);
		QuickSort(A,pivotpos+1,high);
	}
}
```

快速排序算法使用的划分操作实现：假设每次总以表内第一个元素为枢轴划分，则将表中比枢轴大的元素向右移动，比枢轴小的元素向左移动，使得一趟划分操作之后，表中的元素被枢轴一分为二。
```cpp
int Partition(int A[], int low, int high) {
	int pivot=A[low];
	while(low<high){
		//在右半区间找一个小于枢轴的元素，填到左侧
		while(low<high&&A[high]>=pivot) --high;
		A[low]=A[high];
		//在左半区间找一个大于枢轴的元素，填到右侧
		while(low<high&&A[low]<=pivot) ++low;
		A[high]=A[low];
	}
	A[low]=pivot;
	return low;
}
```

空间复杂度：$O(\log_2 n)$，递归栈。
时间复杂度：平均$O(n\log_2 n)$。
- 最坏情况（两个区域分别为$n-1$和$0$个元素，即表内正序或逆序）：$O(n^2)$。
稳定性：不稳定。
适用性：顺序表。

## 选择排序

基本思想：
每一趟在后面$n-i+1$个待排序元素中选取关键字最小的元素，作为有序子序列的第$i$个元素，直到第$n-1$趟做完，待排序元素只剩下一个，就不用再选了。

两种（考研考察的）选择排序算法：简单选择排序、堆排序。

### 简单选择排序

基本思想：所有元素依次排列在线性表，从左端开始不断执行选取操作，使前缀序列始终有序。
假设排序表为`L[1...n]`，第$i$趟排序即从`L[i...n]`中选择关键字最小的元素与`L[i]`交换，每一趟排序可以确定一个元素的最终位置，最多$n-1$趟即可使整个排序表有序。

```cpp
void SelectSort(int A[], int n){
	int i,min;
	//向右枚举未排序序列的左端点i
	for(i=0;i<n-1;++i){
		//在未排序序列中，选取最小值
		min=i;
		for(j=i+1;j<n;++j)
			if(A[j]<A[min]) min=j;
		//将其放在位置i上，此时L[1...i]已有序
		if(min!=i) swap(A[i],A[min]);
	}
}
```

空间复杂度：$O(1)$
时间复杂度：$O(n^2)$
- 最佳情形：移动$0$次，比较$\dfrac{n(n-1)}{2}$次
- 最坏情形：移动$3(n-1)$次，比较$\dfrac{n(n-1)}{2}$次
稳定性：不稳定，元素交换过程可能会改变关键字相同元素的相对顺序。
适用性：顺序表、链表。

### 堆排序

**堆的定义**：$n$个关键字序列`L[1...n]`称为堆，当且仅当序列满足两种性质之一：
- 性质一：`L[i]>=L[2i]`且`L[i]>=L[2i+1]`，`1<=i<=n/2`
- 性质二：`L[i]<=L[2i]`且`L[i]<=L[2i+1]`，`1<=i<=n/2`
满足性质一的堆称为**大根堆**（**大顶堆**），满足性质二的堆称为**小根堆**（**小顶堆**）。

堆排序的思路：
- 首先将存放在`L[1...n]`中的$n$个元素建成初始堆，由于堆本身的性质，堆顶元素就是最大值（或最小值）。
- 输出堆顶元素后，将堆底元素送入堆顶，通过调整维护堆的性质。
- 堆的性质维护完毕后，重复执行上述操作，直至堆被清空。

关键问题：
- 如何从无序序列构造一个堆？
- 如何在输出堆顶元素后，将剩余元素调整成新的堆？

**初始堆的构造方法**：
堆的抽象结构是$n$个结点的完全二叉树，其中编号为`i`的结点必是编号为`i/2`的结点的子结点。
以大根堆为例，从`i=n/2`开始，依次调整以编号为`i`结点为根的子树：如果`L[2i]`和`L[2i+1]`中有元素比`L[i]`大，则交换`L[i]`和对应的元素。
依次调整以编号`n+1,n,n-1,...,2,1`为根的子树，调整完毕后，堆建立。

**堆的调整方法**：
输出堆顶元素后，将堆的最后一个元素放入堆顶，此时堆的性质被破坏，需要将该元素不断向下调整。

![[Pasted image 20230617084825.png]]

```cpp
//建大根堆
void BuildMaxHeap(int A[], int len){
	int i;
	for(i=len/2;i>0;--i)
		HeadAdjust(A,i,len);
}
//将元素k为根的子树进行调整
void HeadAdjust(int A[], int k, int len){
	A[0]=A[k];//A[0]暂存根结点
	//向下枚举
	for(i=2*k;i<=len;i*=2){
		//一共两路子结点，取子结点较大的一路
		if(i<len&&A[i]<A[i+1]) i++;
		//和暂存根结点比较，如果更大则换上去
		if(A[0]>=A[i]) break;
		else{
			A[k]=A[i];
			k=i;
		}
	}
	A[k]=A[0];//被筛选结点的值放入最终位置
}
```

调整的时间与树高有关，为$O(h)$。在建立堆的过程中，比较总次数不超过$4n$，时间复杂度为$O(n)$，这说明可以在线性时间内将一个无序数组建成一个堆。

**堆排序算法**：
```cpp
void HeapSort(int A[], int len){
	BuildMaxHeap(A,len);
	for(i=len;i>1;i--){
		swap(A[i],A[1]);
		HeadAdjust(A,1,i-1);
	}
}
```

**堆的插入操作**：该操作不涉及排序算法的内容。
插入操作时，将插入的元素放在堆的末尾，再对新结点逐级向上调整。
![[Pasted image 20230617085156.png]]

**堆排序的性能分析**：
空间复杂度：$O(1)$
时间复杂度：最好、最坏、平均均为$O(n\log_2 n)$
稳定性：不稳定。
适用性：顺序表。

## 归并排序和基数排序

### 归并排序

基本思想：将两个或两个以上的有序表组合成一个新的有序表。

**迄今为止我惟一一个能默写的`nlogn`排序算法。。。**

王道将归并操作和排序操作分开了，分别如下：
```cpp
//辅助数组
int *B=(int*)malloc((n+1)*sizeof(int));
//假设A[low...mid]和A[mid+1...high]有序，执行合并
void Merge(int A[], int low, int mid, int high) {
	//拷贝到辅助数组中
	for(int k=low;k<high;++k)
		B[k]=A[k];
	//边比较边归并
	for(i=low,j=mid+1,k=i;i<=mid&&j<=high;++k){
		if(B[i]<=B[j])
			A[k]=B[i++];
		else
			A[k]=B[j++];
	}
	//如果还有残存序列，填回去。注意最多只有一个while会被执行
	while(i<=mid) A[k++]=B[i++];
	while(j<=high) A[k++]=B[j++];
}

void MergeSort(int A[], int low, int high){
	if(low<high){
		int mid=(low+high)/2;
		MergeSort(A,low,mid);
		MergeSort(A,mid+1,high);
		Merge(A,low,mid,high);
	}
}
```

**二路归并排序的性能分析**：
空间复杂度：$O(n)$
时间复杂度：$O(n\log_2 n)$
稳定性：不稳定。
适用性：顺序表、链表（需要一些技巧）。

### 基数排序

基本思想：基于关键字各个数位的大小进行排序。每个数位的大小作为一个关键字，进行多关键字排序。

两种方法：
- 最高位优先（MSD）：根据高位划分为若干子序列，各子序列内按低位排序。
- 最低位优先（LSD）：先按低位排序，再按高位排序。

**以$r$为基数的最低位优先基数排序的过程**：
- 定义：$d$为关键字（数位）数量，$r$为基数。
- 辅助结构：$r$个队列$Q_0,Q_1,\cdots,Q_{r-1}$。
- 基本流程：对$i=0,1,\cdots,d-1$，依次做一次分配和收集操作。
	- 分配：所有队列置空，依次考察线性表中的每个结点$a_j$，若$a_j$的关键字$k_j^i$为$k$，则把$a_j$放入$Q_k$。
	- 收集：将$Q_0,Q_1,\cdots,Q_{r-1}$各个队列中的结点依次首尾相接，得到新的结点序列，组成新的线性表。

![[Pasted image 20230617091819.png]]
![[Pasted image 20230617091839.png]]

空间复杂度：$O(r)$，$r$个长度$n$的队列，会被各次排序分摊成本。
时间复杂度：$O(d(n+r))$
- 一趟分配：$O(n)$
- 一趟收集：$O(r)$
稳定性：稳定。
适用性：顺序表、链表。

## 各种内部排序算法的比较和应用

内部排序算法：
- [[#插入排序]]
	- [[#直接插入排序]]
	- [[#折半插入排序]]
	- [[#希尔排序（缩小增量排序）]]
- [[#交换排序]]
	- [[#冒泡排序]]
	- [[#快速排序]]
- [[#选择排序]]
	- [[#简单选择排序]]
	- [[#堆排序]]
- [[#归并排序和基数排序]]
	- [[#归并排序|二路归并排序]]
	- [[#基数排序]]

考察因素：
- 空间复杂度
- 时间复杂度
- 算法的稳定性
- 算法的过程特征

### 空间复杂度

- 简单选择、插入、冒泡、希尔、堆：$O(1)$
- 快速排序：$O(\log_2 n)$
- 二路归并：$O(n)$
- 基数排序：$O(r)$

### 时间复杂度

- 简单选择、直接插入、冒泡：$O(n^2)$
	- 直接插入、冒泡的最好情形为$O(n)$
	- 简单选择与序列状态无关
- 希尔排序：适用于大规模排序，但渐进复杂度依赖于增量函数，目前仍不可解
- 堆排序：$O(n\log_2 n)$
- 快速排序：平均$O(n\log_2 n)$，最坏$O(n^2)$
- 归并排序：$O(n\log_2 n)$，与序列形态无关
- 基数排序：$O(d(n+r))$

### 算法的稳定性

稳定的排序算法：
- 插入
- 冒泡
- 归并：是唯一$O(n\log_2 n)$的稳定排序算法
- 基数排序

不稳定的排序算法：
- 简单选择
- 快速排序
- 希尔排序
- 堆排序

### 算法的过程特征

不同的排序算法在关键字上排序的结果是一致的，但排序的中间序列可能有较大的区别。

![[Pasted image 20230617110435.png]]

### 内部排序算法的应用

**选取排序算法需要考虑的因素**：
- 待排序的元素数目。
- 元素本身信息量的大小。
- 关键字的结构和分布情况。
- 稳定性的要求。
- 语言工具的条件，存储结构和辅助空间大小等。

**排序算法小结**：
- 若$n$较小，可采用直接插入排序或简单选择排序。
- 若文件的初始状态已按关键字基本有序，则采用直接插入或冒泡排序。
- 若$n$较大，应采用$O(n\log_2 n)$算法，优先考虑快速排序。
	- 若要求稳定：归并排序（考虑在$n$足够小时用直接插入）。
- 在基于比较的排序算法中，每次比较两个关键字的大小之后，只出现两种可能的转移，因此可以用一棵二叉树描述判定过程。
- 若$n$很大，记录的关键字位数较少且可分解时，用基数排序。
- 当记录本身信息量较大时，考虑用支持链表的排序算法：
	- 直接插入、冒泡、简单选择、归并、基数排序

## 外部排序

主要内容：
- 外部排序指排序文件较大，内存一次放不下，需存放在外存的文件的排序。
- 为减少平衡归并中外存读写次数所采用的方法：增大归并路数和减小归并段个数。
- 利用败者树增大归并路数。
- 利用置换-选择排序增大归并段长度来减少归并段个数。
- 由长度不等的归并段，进行多路平衡归并，需要构造最佳归并树。

**外部排序基本概念**
待排序的记录由于内存容量限制，必须存放在外存，排序期间一部分一部分读入内存进行排序，并不断进行内外存交换。

**外部排序方法**
外部排序过程的时间代价主要考量访问磁盘的次数，即I/O次数。

外部排序一般用归并排序法：
- 第一阶段：根据内存缓冲区大小，将外存上的文件分为若干长度为$l$的子文件，依次读入内存并利用内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写回内存。这些有序子文件称为**归并段**或**顺串**。
- 第二阶段：对这些归并段进行逐趟合并，使归并段逐渐由小到大，直到得到整个有序文件为止。

例子：
磁盘内有2000条记录，每个磁盘块内可容纳125条记录（总共16个盘块），可用于排序的内存只能容纳375条记录。如果运用二路归并，则可划分为3个缓冲区：2个容量为125条记录的输入缓冲区，和1个容量为125条记录的输出缓冲区。

首先，利用内存空间进行内部排序，得到8个初始归并段`R1,R2,R3,R4,R5,R6,R7,R8`。成本是16次读入和16次写回。

其次，对每两个相邻的初始归并段进行二路归并，得到4个一级归并段`R1',R2',R3',R4'`。归并的过程包括依次读入被归并的两个段到输入缓冲区域，归并到输出缓冲区满时写回一次，清空输出缓冲区；输入缓冲区空时，读入下一个块，持续归并，直到所有记录归并完毕并全部被写回磁盘。这一步需要16次读入和16次写回，在顺序上，会先连续读入两块，排序后陆续写回两块。

再次，对4个一级归并段排序，得到2个二级归并段`R1'',R2''`。操作细节和上一步类似，也需要16次读入和16次写回。

最后，对2个二级归并段进行合并，得到最后的有序文件。这一步仍然需要16次读入和16次合并。
![[Pasted image 20230617123243.png]]

规律：
两两归并时，由于不可能将两个有序段及归并结果同时存放在内存中，因此需要不断地读出、写入磁盘，从而耗费大量的时间：
**外部排序时间=内部排序时间+外存信息读写时间+内部归并时间**
外存信息读写时间最显著，是需要重点减少的时间。

如果内存空间允许，可以采用**多路归并**提升外部排序的效率。如果内存支持625条记录，则可以采用四路归并，总耗时也会降低至48次读+48次写。基本原理在于，减少归并的轮数，从而减少盘块读入写回的次数。

另外，**减少初始归并段个数**也可以提升外部排序的效率，原理也是减少归并的轮数。

### 多路平衡归并与败者树

**背景**：
前文提到的多路归并算法确实可以减少磁盘读写的时间，但会大幅增加内部排序的时间。内部归并时，在$k$路元素中选择最小元素要做$k-1$次比较，每趟归并要做$(n-1)(k-1)$次比较，$S$趟归并总共需要的比较次数为：
$$
S(n-1)(k-1)=\lceil\log_k r\rceil(n-1)(k-1)=\dfrac{k-1}{\log_2 k}(n-1)\lceil\log_2 r\rceil
$$
随着$k$的增大，比较次数也会急剧增加，甚至抵消减少读入、读出次数的时间收益。因此需要对多路归并作适合外部排序的改进。

**败者树**：
一种（近似）完全二叉树结构，每个叶结点对应一路元素。
每个非叶结点记忆左右子树中的失败者，胜者会晋升到上一级结点比较。根结点会存储整棵树的胜者（最大或最小元素）。

![[Pasted image 20230617130720.png]]

实现原理上：有$n$路，就开$2n$个败者结点。每个叶结点填对应路的当前元素，非叶结点填当前子树败者的编号。

效率上：
原来的$k-1$次比较优化为$\lceil\log_2 k\rceil$次比较。总的比较次数优化为：
$$
S(n-1)\lceil\log_2 k\rceil=\lceil\log_k r\rceil(n-1)\lceil\log_2 k\rceil=(n-1)\lceil\log_2 r\rceil
$$
这样的优化使得内部归并的比较次数与$k$无关，从而保证了多路归并在降低I/O时间的同时不增加归并成本。

### 置换-选择排序（生成初始归并段）

**背景**：
通过内部排序直接生成初始归并段是可行的，但受到内存工作区限制。如果内存工作区容纳$l$条记录，则初始归并段长度不会超过$l$，而初始归并段的个数也不会低于$r=\lceil\dfrac{n}{l}\rceil$。

置换-选择算法可以产生更长的初始归并段，而不受内存工作区的直接限制。

**原理**：
设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状态为空，WA可容纳$w$个记录。算法步骤如下：
- 第一步：从FI输入$w$个记录到工作区WA。
- 第二步：从WA中选出关键字取最小值的记录，记作MINIMAX记录。
- 第三步：将MINIMAX记录输出到FO。
- 第四步：若FI不空，则从FI读入下一个记录到WA中。
- 第五步：从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。
- 第六步：重复第三到五步，直到WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO。
- 第七步：重复第二到六步，直到WA为空。由此得到全部初始归并段。

示例：
![[Pasted image 20230617132519.png]]

### 最佳归并树

**背景**：
文件经过置换-选择排序后，得到的初始归并段长度不等。这个时候，需要安排合理的初始归并段归并顺序，使得总I/O次数最少。

**归并树**描述的是各个归并段进行归并，最终得到有序文件的层级关系。**最佳归并树**是需要总I/O次数最少的那一棵归并树。我们需要特殊调整各个归并段的合并关系，从而达到最优归并耗时。

**各种归并关系的讨论**：
- 直接合并：对应图8.16，显然不是最优的。
- 哈夫曼树合并：对应图8.17，该思路将各个初始归并段拼成一棵严格$k$叉哈夫曼树。该思路只有在**初始归并段可组成严格$k$叉树**时，才是最优的，否则不是最优。
- 带虚段的哈夫曼树合并：对应图8.18，如果拿走长度为30的初始归并段，则剩下的初始归并段无法拼出严格$k$叉树。此时需要添加一个长度为0的**虚段**，该段在实际归并时不被处理。

![[Pasted image 20230617134707.png]]
![[Pasted image 20230617134713.png]]
![[Pasted image 20230617134721.png]]

**虚段个数的判定**：
- 设度数为0的结点有$n_0=n$个，度为$k$的结点有$n_k$个，则对严格$k$叉树有：$n_0=(k-1)n_k+1$，由此得$n_k=\dfrac{n_0-1}{k-1}$。
- 若$n_0-1\equiv 0\pmod{k-1}$，则说明叶结点可以直接组成严格$k$叉树，此时内结点有$n_k$个。
- 若$n_0-1=u\not\equiv 0\pmod{k-1}$，则说明$n_0$个叶结点中，有$u$个多余。为构造包含所有$n_0$个叶结点的$k$叉归并树，则需要在原有$n_k$个内结点的基础上增加一个内结点。它在归并树中替代了一个叶结点的位置，被代替的叶结点加上刚才多出的$u$个叶结点，再**加上$k-u-1$个虚段**（空归并段），即可建立归并树。

以图8.18的示例，$n_0=8$，$k=3$，则$u=1$，需要增加$k-u-1=3-1-1=1$个虚段。

## 后记

总算苟完数据结构了，然而还有三科LOL。
——230617