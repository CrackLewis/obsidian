
## 概述

考纲考察的内容：
- 排序的基本概念
- 插入排序：直接插入排序、折半排序、希尔排序
- 交换排序：冒泡排序、快速排序
- 选择排序：简单选择排序、堆排序
- 二路归并排序
- 基数排序
- 外部排序
- 排序算法的分析和应用

## 基本概念

**排序定义**：重排线性表中元素，使其按关键字有序。
- 输入：$n$个记录$R_1,R_2,\cdots,R_n$，关键字分别为$k_1,k_2,\cdots,k_n$。
- 输出：输入记录的重排$R_1',R_2',\cdots,R_n'$，使得$k_1'\le k_2'\le \cdots\le k_n'$。

**排序算法的稳定性**：如果任何操作前后，关键字相同的元素的相对顺序不改变，则称该排序算法是稳定的，否则是不稳定的。

按被排序记录的位置，可将排序算法分为两类：
- **内部排序**：所有被排序记录均驻在内存中。
	- 大部分内部排序算法都依赖比较、移动两种操作。
		- 一个例外是基数排序算法。
- **外部排序**：所有记录无法同时存储在内存中，必须在排序过程中将元素不断在内存、外存间移动。

## 插入排序

基本思想：每次将一个待排序的记录按关键字大小插入前面已排好序的子序列，直到全部记录插入完成。

三个插入排序算法：直接插入排序、折半插入排序、希尔排序。

### 直接插入排序

假设某一时刻的线性表状态：
![[Pasted image 20230616213057.png]]

要将`L[i]`插入左侧的有序序列，需要如下步骤：
- 查找出`L[i]`在`L[1...i-1]`中的插入位置`k`
- 将`L[k...i-1]`中的所有元素依次右移一个位置
- 将`L[i]`复制到`L[k]`

对一个线性表进行直接插入排序可以描述为：将`L[2]`到`L[n]`的所有元素依次插入到左侧。

王道给出的示例代码使用哨兵法，进行升序排序：
```cpp
void InsertSort(int A[], int n) {
	int i,j;
	//枚举待插入元素的位置
	for(i=2;i<=n;++i){
		//如果A[i]>=A[i-1]，不必参与插入
		if(A[i]<A[i-1]){
			//将当前待插入元素放入哨兵位置
			A[0]=A[i];
			//枚举到一个合适的插入位置
			for(j=i-1;A[0]<A[j];--j)
				A[j+1]=A[j];
			//将暂存于哨兵位置的待插入元素放回
			A[j+1]=A[0];
		}
	}
}
```

空间复杂度：$O(1)$。
时间复杂度：$O(n^2)$。
- 最好情形：$n$次操作
- 最坏情形：比较次数$\dfrac{n^2+n-2}{2}$，移动次数$\dfrac{n^2+3n-4}{2}$
稳定性：稳定。
适用性：顺序表、链表。

### 折半插入排序

直接插入排序中找插入位置的时间太慢，可以优化。

```cpp
void InsertSort(int A[], int n){
	int i,j,low,high,mid;
	for(i=2;i<=n;++i){
		if(A[i]>=A[i-1]) continue;
		A[0]=A[i];
		low=1,high=i-1;//初始化查找边界
		//折半查找得到插入位置
		while(low<=high){
			mid=(low+high)/2;
			if(A[mid]>A[0]) high=mid-1;
			else low=mid+1;
		}
		//插入位置为high+1，该位置及其右侧的元素右移
		for(j=i-1;j>=high+1;--j)
			A[j+1]=A[j];
		A[high+1]=A[0];
	}
}
```

空间复杂度：$O(1)$
时间复杂度：$O(n^2)$，主要是元素移动成本难于优化。
- 最好情形：$n$次操作
- 最坏情形：$n\log_2 n$次比较，约$\dfrac{n^2}{2}$次移动
稳定性：稳定。
适用性：顺序表。

### 希尔排序（缩小增量排序）

基本思想：
- 将待排序表分割为若干个形如$L[i,i+d,i+2d,\cdots,i+kd]$的特殊子表，即把相隔某个“增量”的记录组成一个子表。
- 对各个子表分别进行直接插入排序。
- 当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。

过程：
- 先取一个步长$d_1<n$，把表中的所有记录分为$d_1$组，所有距离为$d_1$的倍数的记录放在同一组，在各组内直接插入排序。
- 取第二个步长$d_2<d_1$，重复上述过程。
- 不断缩小步长，直到$d_t=1$，即所有记录在同一组。此时全表呈现高度的局部有序，可以较快地完成直接插入排序。

王道同样使用哨兵法：
```cpp
void ShellSort(int A[], int n){
	int dk,i,j;
	//枚举增量
	for(dk=n/2;dk>=1;dk/=2){
		//组内直接插入排序：这里将各组的排序过程合并了
		for(i=dk+1;i<=n;++i){
			if(A[i]<A[i-dk]){
				A[0]=A[i];//暂存哨兵位置
				//在组内依次右移元素
				for(j=i-dk;j>0&&A[0]<A[j];j-=dk)
					A[j+dk]=A[j];
				A[j+dk]=A[0];//填回元素
			}
		}
	}
}
```

空间复杂度：$O(1)$
时间复杂度：$O(n^2)$
- 最佳情形：$n$在某个特定范围时，复杂度满足$O(n^{1.3})$。
- 最坏情形：$O(n^2)$。
稳定性：不稳定。相同关键字的记录如果在不同组，可能会被改变相对次序。
适用性：顺序表。

## 交换排序

基本思想：根据序列中两个元素关键字的比较结果，对换两个记录在序列中的位置。

两种（考研会考的）交换排序算法：冒泡排序、快速排序。

### 冒泡排序

基本思想：从后往前（或从前往后）两两比较相邻元素的值，如果逆序则交换它们，直到序列比较完毕，称为一轮冒泡。序列完全有序需要至多$n$轮冒泡。

![[Pasted image 20230616221342.png]]

代码：
```cpp
void BubbleSort(int A[], int n){
	bool flag;
	//L[0..i]是已经有序的序列。
	for(i=0;i<n-1;++i){
		flag=false;
		//倒序枚举i之后的每个位置
		for(j=n-1;j>i;--j){
			if(A[j-1]>A[j]){
				swap(A[j-1],A[j]);
				flag=true;
			}
		}
		//优化：如果一轮下来没有对换，则说明已经有序
		if(flag==false)
			return;
	}
}
```

空间复杂度：$O(1)$
时间复杂度：$O(n^2)$
- 最佳情形（正序）：$O(n)$
- 最坏情形（逆序）：$\dfrac{n(n-1)}{2}$次比较，$\dfrac{3n(n-1)}{2}$次移动。
稳定性：稳定。
适用性：顺序表。

### 快速排序

基本思想：
- 在待排序表`L[1...n]`中任取一个元素`pivot`作为枢轴（通常取首元素）。
- 通过一趟排序，将待排序表划分为独立的两部分`L[1...k-1]`和`L[k+1...n]`，使得`L[1...k-1]`中所有元素小于`pivot`，`L[k+1...n]`中的所有元素大于或等于`pivot`，则`pivot`放在了其最终位置`L[k]`上，这个过程称为一趟快速排序。
- 对区间`L[1...k-1]`和`L[k+1...n]`递归运用上述排序方法，直到每部分只有一个元素或者为空。

一趟快速排序的过程是一个交替搜索和交换的过程。下面是一个实例：
![[Pasted image 20230616231423.png]]
![[Pasted image 20230616231459.png]]

快速排序算法：
```cpp
void QuickSort(int A[], int low, int high) {
	if(low<high){
		int pivotpos=Partition(A,low,high);
		QuickSort(A,low,pivotpos-1);
		QuickSort(A,pivotpos+1,high);
	}
}
```

快速排序算法使用的划分操作实现：假设每次总以表内第一个元素为枢轴划分，则将表中比枢轴大的元素向右移动，比枢轴小的元素向左移动，使得一趟划分操作之后，表中的元素被枢轴一分为二。
```cpp
int Partition(int A[], int low, int high) {
	int pivot=A[low];
	while(low<high){
		//在右半区间找一个大于枢轴的元素
		while(low<high&&A[high]>=pivot) --high;
		//
		A[low]=A[high];
		//在左半
		while(low<high&&A[low]<=pivot) ++low;
		A[high]=A[low];
	}
	A[low]=pivot;
	return low;
}
```