
## 概述

考纲考察的内容：
- 排序的基本概念
- 插入排序：直接插入排序、折半排序、希尔排序
- 交换排序：冒泡排序、快速排序
- 选择排序：简单选择排序、堆排序
- 二路归并排序
- 基数排序
- 外部排序
- 排序算法的分析和应用

## 基本概念

**排序定义**：重排线性表中元素，使其按关键字有序。
- 输入：$n$个记录$R_1,R_2,\cdots,R_n$，关键字分别为$k_1,k_2,\cdots,k_n$。
- 输出：输入记录的重排$R_1',R_2',\cdots,R_n'$，使得$k_1'\le k_2'\le \cdots\le k_n'$。

**排序算法的稳定性**：如果任何操作前后，关键字相同的元素的相对顺序不改变，则称该排序算法是稳定的，否则是不稳定的。

按被排序记录的位置，可将排序算法分为两类：
- **内部排序**：所有被排序记录均驻在内存中。
	- 大部分内部排序算法都依赖比较、移动两种操作。
		- 一个例外是基数排序算法。
- **外部排序**：所有记录无法同时存储在内存中，必须在排序过程中将元素不断在内存、外存间移动。

## 插入排序

基本思想：每次将一个待排序的记录按关键字大小插入前面已排好序的子序列，直到全部记录插入完成。

三个插入排序算法：直接插入排序、折半插入排序、希尔排序。

### 直接插入排序

假设某一时刻的线性表状态：
![[Pasted image 20230616213057.png]]

要将`L[i]`插入左侧的有序序列，需要如下步骤：
- 查找出`L[i]`在`L[1...i-1]`中的插入位置`k`
- 将`L[k...i-1]`中的所有元素依次右移一个位置
- 将`L[i]`复制到`L[k]`

对一个线性表进行直接插入排序可以描述为：将`L[2]`到`L[n]`的所有元素依次插入到左侧。

王道给出的示例代码使用哨兵法，进行升序排序：
```cpp
void InsertSort(int A[], int n) {
	int i,j;
	//枚举待插入元素的位置
	for(i=2;i<=n;++i){
		//如果A[i]>=A[i-1]，不必参与插入
		if(A[i]<A[i-1]){
			//将当前待插入元素放入哨兵位置
			A[0]=A[i];
			//枚举到一个合适的插入位置
			for(j=i-1;A[0]<A[j];--j)
				A[j+1]=A[j];
			//将暂存于哨兵位置的待插入元素放回
			A[j+1]=A[0];
		}
	}
}
```

空间复杂度：$O(1)$。
时间复杂度：$O(n^2)$。
- 最好情形：$n$次操作
- 最坏情形：比较次数$\dfrac{n^2+n-2}{2}$，移动次数$\dfrac{n^2+3n-4}{2}$
稳定性：稳定。
适用性：顺序表、链表。

### 折半插入排序

直接插入排序中找插入位置的时间太慢，可以优化。

```cpp
void InsertSort(int A[], int n){
	int i,j,low,high,mid;
	for(i=2;i<=n;++i){
		if(A[i]>=A[i-1]) continue;
		A[0]=A[i];
		low=1,high=i-1;//初始化查找边界
		//折半查找得到插入位置
		while(low<=high){
			mid=(low+high)/2;
			if(A[mid]>A[0]) high=mid-1;
			else low=mid+1;
		}
		//插入位置为high+1，该位置及其右侧的元素右移
		for(j=i-1;j>=high+1;--j)
			A[j+1]=A[j];
		A[high+1]=A[0];
	}
}
```

空间复杂度：$O(1)$
时间复杂度：$O(n^2)$，主要是元素移动成本难于优化。
- 最好情形：$n$次操作
- 最坏情形：$n\log_2 n$次比较，约$\dfrac{n^2}{2}$次移动
稳定性：稳定。
适用性：顺序表。

### 希尔排序（缩小增量排序）

基本思想：
- 将待排序表分割为若干个形如$L[i,i+d,i+2d,\cdots,i+kd]$的特殊子表，即把相隔某个“增量”的记录组成一个子表。
- 对各个子表分别进行直接插入排序。
- 当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。

过程：
- 先取一个步长$d_1<n$，把表中的所有记录分为$d_1$组，所有距离为$d_1$的倍数的记录放在同一组，在各组内直接插入排序。
- 取第二个步长$d_2<d_1$，重复上述过程。
- 不断缩小步长，直到$d_t=1$，即所有记录在同一组。此时全表呈现高度的局部有序，可以较快地完成直接插入排序。

王道同样使用哨兵法：
```cpp
void ShellSort(int A[], int n){
	int dk,i,j;
	//枚举增量
	for(dk=n/2;dk>=1;dk/=2){
		//组内直接插入排序：这里将各组的排序过程合并了
		for(i=dk+1;i<=n;++i){
			if(A[i]<A[i-dk]){
				A[0]=A[i];//暂存哨兵位置
				//在组内依次右移元素
				for(j=i-dk;j>0&&A[0]<A[j];j-=dk)
					A[j+dk]=A[j];
				A[j+dk]=A[0];//填回元素
			}
		}
	}
}
```

空间复杂度：$O(1)$
时间复杂度：$O(n^2)$
- 最佳情形：$n$在某个特定范围时，复杂度满足$O(n^{1.3})$。
- 最坏情形：$O(n^2)$。
稳定性：不稳定。相同关键字的记录如果在不同组，可能会被改变相对次序。
适用性：顺序表。

## 交换排序

基本思想：根据序列中两个元素关键字的比较结果，对换两个记录在序列中的位置。

两种（考研会考的）交换排序算法：冒泡排序、快速排序。

### 冒泡排序

基本思想：从后往前（或从前往后）两两比较相邻元素的值，如果逆序则交换它们，直到序列比较完毕，称为一轮冒泡。序列完全有序需要至多$n$轮冒泡。

![[Pasted image 20230616221342.png]]

代码：
```cpp
void BubbleSort(int A[], int n){
	bool flag;
	//L[0..i]是已经有序的序列。
	for(i=0;i<n-1;++i){
		flag=false;
		//倒序枚举i之后的每个位置
		for(j=n-1;j>i;--j){
			if(A[j-1]>A[j]){
				swap(A[j-1],A[j]);
				flag=true;
			}
		}
		//优化：如果一轮下来没有对换，则说明已经有序
		if(flag==false)
			return;
	}
}
```

空间复杂度：$O(1)$
时间复杂度：$O(n^2)$
- 最佳情形（正序）：$O(n)$
- 最坏情形（逆序）：$\dfrac{n(n-1)}{2}$次比较，$\dfrac{3n(n-1)}{2}$次移动。
稳定性：稳定。
适用性：顺序表。

### 快速排序

基本思想：
- 在待排序表`L[1...n]`中任取一个元素`pivot`作为枢轴（通常取首元素）。
- 通过一趟排序，将待排序表划分为独立的两部分`L[1...k-1]`和`L[k+1...n]`，使得`L[1...k-1]`中所有元素小于`pivot`，`L[k+1...n]`中的所有元素大于或等于`pivot`，则`pivot`放在了其最终位置`L[k]`上，这个过程称为一趟快速排序。
- 对区间`L[1...k-1]`和`L[k+1...n]`递归运用上述排序方法，直到每部分只有一个元素或者为空。

一趟快速排序的过程是一个交替搜索和交换的过程。下面是一个实例：
![[Pasted image 20230616231423.png]]
![[Pasted image 20230616231459.png]]

快速排序算法：
```cpp
void QuickSort(int A[], int low, int high) {
	if(low<high){
		int pivotpos=Partition(A,low,high);
		QuickSort(A,low,pivotpos-1);
		QuickSort(A,pivotpos+1,high);
	}
}
```

快速排序算法使用的划分操作实现：假设每次总以表内第一个元素为枢轴划分，则将表中比枢轴大的元素向右移动，比枢轴小的元素向左移动，使得一趟划分操作之后，表中的元素被枢轴一分为二。
```cpp
int Partition(int A[], int low, int high) {
	int pivot=A[low];
	while(low<high){
		//在右半区间找一个小于枢轴的元素，填到左侧
		while(low<high&&A[high]>=pivot) --high;
		A[low]=A[high];
		//在左半区间找一个大于枢轴的元素，填到右侧
		while(low<high&&A[low]<=pivot) ++low;
		A[high]=A[low];
	}
	A[low]=pivot;
	return low;
}
```

空间复杂度：$O(\log_2 n)$，递归栈。
时间复杂度：平均$O(n\log_2 n)$。
- 最坏情况（两个区域分别为$n-1$和$0$个元素，即表内正序或逆序）：$O(n^2)$。
稳定性：不稳定。
适用性：顺序表。

## 选择排序

基本思想：
每一趟在后面$n-i+1$个待排序元素中选取关键字最小的元素，作为有序子序列的第$i$个元素，直到第$n-1$趟做完，待排序元素只剩下一个，就不用再选了。

两种（考研考察的）选择排序算法：简单选择排序、堆排序。

### 简单选择排序

基本思想：所有元素依次排列在线性表，从左端开始不断执行选取操作，使前缀序列始终有序。
假设排序表为`L[1...n]`，第$i$趟排序即从`L[i...n]`中选择关键字最小的元素与`L[i]`交换，每一趟排序可以确定一个元素的最终位置，最多$n-1$趟即可使整个排序表有序。

```cpp
void SelectSort(int A[], int n){
	int i,min;
	//向右枚举未排序序列的左端点i
	for(i=0;i<n-1;++i){
		//在未排序序列中，选取最小值
		min=i;
		for(j=i+1;j<n;++j)
			if(A[j]<A[min]) min=j;
		//将其放在位置i上，此时L[1...i]已有序
		if(min!=i) swap(A[i],A[min]);
	}
}
```

空间复杂度：$O(1)$
时间复杂度：$O(n^2)$
- 最佳情形：移动$0$次，比较$\dfrac{n(n-1)}{2}$次
- 最坏情形：移动$3(n-1)$次，比较$\dfrac{n(n-1)}{2}$次
稳定性：不稳定，元素交换过程可能会改变关键字相同元素的相对顺序。
适用性：顺序表、链表。

### 堆排序

**堆的定义**：$n$个关键字序列`L[1...n]`称为堆，当且仅当序列满足两种性质之一：
- 性质一：`L[i]>=L[2i]`且`L[i]>=L[2i+1]`，`1<=i<=n/2`
- 性质二：`L[i]<=L[2i]`且`L[i]<=L[2i+1]`，`1<=i<=n/2`
满足性质一的堆称为**大根堆**（**大顶堆**），满足性质二的堆称为**小根堆**（**小顶堆**）。

堆排序的思路：
- 首先将存放在`L[1...n]`中的$n$个元素建成初始堆，由于堆本身的性质，堆顶元素就是最大值（或最小值）。
- 输出堆顶元素后，将堆底元素送入堆顶，通过调整维护堆的性质。
- 堆的性质维护完毕后，重复执行上述操作，直至堆被清空。

关键问题：
- 如何从无序序列构造一个堆？
- 如何在输出堆顶元素后，将剩余元素调整成新的堆？

**初始堆的构造方法**：
堆的抽象结构是$n$个结点的完全二叉树，其中编号为`i`的结点必是编号为`i/2`的结点的子结点。
以大根堆为例，从`i=n/2`开始，依次调整以编号为`i`结点为根的子树：如果`L[2i]`和`L[2i+1]`中有元素比`L[i]`大，则交换`L[i]`和对应的元素。
依次调整以编号`n+1,n,n-1,...,2,1`为根的子树，调整完毕后，堆建立。

**堆的调整方法**：
输出堆顶元素后，将堆的最后一个元素放入堆顶，此时堆的性质被破坏，需要将该元素不断向下调整。

![[Pasted image 20230617084825.png]]

```cpp
//建大根堆
void BuildMaxHeap(int A[], int len){
	int i;
	for(i=len/2;i>0;--i)
		HeadAdjust(A,i,len);
}
//将元素k为根的子树进行调整
void HeadAdjust(int A[], int k, int len){
	A[0]=A[k];//A[0]暂存根结点
	//向下枚举
	for(i=2*k;i<=len;i*=2){
		//一共两路子结点，取子结点较大的一路
		if(i<len&&A[i]<A[i+1]) i++;
		//和暂存根结点比较，如果更大则换上去
		if(A[0]>=A[i]) break;
		else{
			A[k]=A[i];
			k=i;
		}
	}
	A[k]=A[0];//被筛选结点的值放入最终位置
}
```

调整的时间与树高有关，为$O(h)$。在建立堆的过程中，比较总次数不超过$4n$，时间复杂度为$O(n)$，这说明可以在线性时间内将一个无序数组建成一个堆。

**堆排序算法**：
```cpp
void HeapSort(int A[], int len){
	BuildMaxHeap(A,len);
	for(i=len;i>1;i--){
		swap(A[i],A[1]);
		HeadAdjust(A,1,i-1);
	}
}
```

**堆的插入操作**：该操作不涉及排序算法的内容。
插入操作时，将插入的元素放在堆的末尾，再对新结点逐级向上调整。
![[Pasted image 20230617085156.png]]

**堆排序的性能分析**：
空间复杂度：$O(1)$
时间复杂度：最好、最坏、平均均为$O(n\log_2 n)$
稳定性：不稳定。
适用性：顺序表。

## 归并排序和基数排序

### 归并排序

基本思想：将两个或两个以上的有序表组合成一个新的有序表。

**迄今为止我惟一一个能默写的`nlogn`排序算法。。。**

王道将归并操作和排序操作分开了，分别如下：
```cpp
//辅助数组
int *B=(int*)malloc((n+1)*sizeof(int));
//假设A[low...mid]和A[mid+1...high]有序，执行合并
void Merge(int A[], int low, int mid, int high) {
	//拷贝到辅助数组中
	for(int k=low;k<high;++k)
		B[k]=A[k];
	//边比较边归并
	for(i=low,j=mid+1,k=i;i<=mid&&j<=high;++k){
		if(B[i]<=B[j])
			A[k]=B[i++];
		else
			A[k]=B[j++];
	}
	//如果还有残存序列，填回去。注意最多只有一个while会被执行
	while(i<=mid) A[k++]=B[i++];
	while(j<=high) A[k++]=B[j++];
}

void MergeSort(int A[], int low, int high){
	if(low<high){
		int mid=(low+high)/2;
		MergeSort(A,low,mid);
		MergeSort(A,mid+1,high);
		Merge(A,low,mid,high);
	}
}
```

**二路归并排序的性能分析**：
空间复杂度：$O(n)$
时间复杂度：$O(n\log_2 n)$
稳定性：不稳定。
适用性：顺序表、链表（需要一些技巧）。

### 基数排序

基本思想：基于关键字各个数位的大小进行排序。每个数位的大小作为一个关键字，进行多关键字排序。

两种方法：
- 最高位优先（MSD）：根据高位划分为若干子序列，各子序列内按低位排序。
- 最低位优先（LSD）：先按低位排序，再按高位排序。

**以$r$为基数的最低位优先基数排序的过程**：
- 定义：$d$为关键字（数位）数量，$r$为基数。
- 辅助结构：$r$个队列$Q_0,Q_1,\cdots,Q_{r-1}$。
- 基本流程：对$i=0,1,\cdots,d-1$，依次做一次分配和收集操作。
	- 分配：所有队列置空，依次考察线性表中的每个结点$a_j$，若$a_j$的关键字$k_j^i$为$k$，则把$a_j$放入$Q_k$。
	- 收集：将$Q_0,Q_1,\cdots,Q_{r-1}$各个队列中的结点依次首尾相接，得到新的结点序列，组成新的线性表。

![[Pasted image 20230617091819.png]]
![[Pasted image 20230617091839.png]]

空间复杂度：$O(r)$，$r$个长度$n$的队列，会被各次排序分摊成本。
时间复杂度：$O(d(n+r))$
- 一趟分配：$O(n)$
- 一趟收集：$O(r)$
稳定性：稳定。
适用性：顺序表、链表。

## 各种内部排序算法的比较和应用

内部排序算法：
- [[#插入排序]]
	- [[#直接插入排序]]
	- [[#折半插入排序]]
	- [[#希尔排序（缩小增量排序）]]
- [[#交换排序]]
	- [[#冒泡排序]]
	- [[#快速排序]]
- [[#选择排序]]
	- [[#简单选择排序]]
	- [[#堆排序]]
- [[#归并排序和基数排序]]
	- [[#归并排序|二路归并排序]]
	- [[#基数排序]]

考察因素：
- 空间复杂度
- 时间复杂度
- 算法的稳定性
- 算法的过程特征

### 空间复杂度

- 简单选择、插入、冒泡、希尔、堆：$O(1)$
- 快速排序：$O(\log_2 n)$
- 二路归并：$O(n)$
- 基数排序：$O(r)$

### 时间复杂度

- 简单选择、直接插入、冒泡：$O(n^2)$
	- 直接插入、冒泡的最好情形为$O(n)$
	- 简单选择与序列状态无关
- 希尔排序：适用于大规模排序，但渐进复杂度依赖于增量函数，目前仍不可解
- 堆排序：$O(n\log_2 n)$
- 快速排序：平均$O(n\log_2 n)$，最坏$O(n^2)$
- 归并排序：$O(n\log_2 n)$，与序列形态无关
- 基数排序：$O(d(n+r))$

### 算法的稳定性

稳定的排序算法：
- 插入
- 冒泡
- 归并：是唯一$O(n\log_2 n)$的稳定排序算法
- 基数排序

不稳定的排序算法：
- 简单选择
- 快速排序
- 希尔排序
- 堆排序

### 算法的过程特征

不同的排序算法在关键字上排序的结果是一致的，但排序的中间序列可能有较大的区别。

![[Pasted image 20230617110435.png]]

### 内部排序算法的应用

**选取排序算法需要考虑的因素**：
- 待排序的元素数目。
- 元素本身信息量的大小。
- 关键字的结构和分布情况。
- 稳定性的要求。
- 语言工具的条件，存储结构和辅助空间大小等。

**排序算法小结**：
- 若$n$较小，可采用直接插入排序或简单选择排序。
- 若文件的初始状态已按关键字基本有序，则采用直接插入或冒泡排序。
- 若$n$较大，应采用$O(n\log_2 n)$算法，优先考虑快速排序。
	- 若要求稳定：归并排序（考虑在$n$足够小时用直接插入）。
- 在基于比较的排序算法中，每次比较两个关键字的大小之后，只出现两种可能的转移，因此可以用一棵二叉树描述判定过程。
- 若$n$很大，记录的关键字位数较少且可分解时，用基数排序。
- 当记录本身信息量较大时，k