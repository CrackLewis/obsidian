
## 框架

- 内存管理基础
	- 基本原理和要求
	- 连续分配管理方式：单一连续分配、固定分区分配、动态分区分配
	- 基本分页存储管理
	- 基本分段存储管理
	- 段页式管理
- 虚拟内存管理
	- 基本概念
	- 请求分页管理方式
	- 页框分配
	- 页面置换算法
	- 抖动和工作集
	- 内存映射文件
	- 虚拟存储器性能影响因素
	- 地址翻译

## 四种动态分区分配算法

- 首次适应：链首开始找，找第一个可容纳分区。最简单、最好、最快，但低地址碎片太多。
- 临近适应：上次查找位置开始找，找第一个可容纳分区。总体碎片比首次适应多。
- 最佳适应：按**容量递增次序**排列分区，取最小的可容纳分区。外部碎片最多，性能差。
- 最坏适应：按**容量递减次序**排列分区，取最大的可容纳分区。缺少大块内存，性能也差。

## 三种存储管理方式

**分页存储的基本概念**：
- 页面和页面大小
- 地址结构：页号+页内偏移量
- 页表：进程内置的、逻辑页面到物理页框的映射表

**快表（TLB）**：一组最近访问的页面映射关系。

**两级页表**：逻辑地址=一级页号+二级页号+页内偏移

## 页框分配策略

**内存分配策略**：
- 固定分配局部置换
- 可变分配全局置换
- 可变分配局部置换

**物理块调入算法**：按比例分配算法、优先权分配算法。

**从何处调换页面**：
- 对换区空间足够：全部从对换区调入。
- 对换区空间不够：只读文件会从文件区调入。
- UNIX方式：区分文件区和对换区。

## 四种页面置换算法

### 最佳置换算法（OPT）

一种无法实现的理想化算法，总是淘汰最长时间内不再被访问的页面。

### FIFO

优先淘汰最早进入内存的页面。

基于队列实现。

**Belady异常**：只会在FIFO算法中出现的一种异常，成因：设页面数量为4，则如果刻意构造周期为5的循环访问页面序列，则会导致缺页异常反复出现，而其他调度算法没有这种现象。

### LRU

优先淘汰最长时间未访问过的页面。

基于堆栈实现，需要相关的硬件支持。

### CLOCK

**简单CLOCK**：设访问位，根据访问位的取值决定行为：
- 被调入时：设访问位为1。
- 被扫描但不匹配：
	- 访问位为1：设访问位为0。
	- 访问位为0：调出。

**改进CLOCK**：增加修改位。
- 换出优先级：`(A=0,M=0)>(A=0,M=1)>(A=1,M=0)>(A=1,M=1)`。

### 对比

WIP

## 虚拟存储器性能影响因素

**主要因素**：缺页率。

**影响因素**：
- 页面大小：页面较大则缺页率较低，页面较小则内存利用率高、碎片小。
- 分配进程的物理块数：块数越多，缺页率越低。
- 页面置换算法。
- 写回磁盘的频率：写回频率越高，效率越低。

## 真题选择错题

![[Pasted image 20230909233051.png]]

46：
答案是B。
注意最佳适配要从上一次查完的位置开始找。
![[Pasted image 20230909234125.png]]

47：
易错选A，答案是B。
原因在于，每个页面可以存储512个页表项，一个页面的大小是1024B。说明整个系统的二级页表有：
$$
(2^{26}/2^{10})/2^9=2^7=128
$$
张。因此需要128个一级页表项。

![[Pasted image 20230909233117.png]]

52：
注意各个分区并非按照始址顺序排列的。因此回收`[60,200)`分区后，它会连接`[20,60)`和`[200,400)`两个分区，最终分区数量是3个，表内首个分区是合并后分区链内的最小者`[500,580)`。答案选B。

![[Pasted image 20230909234045.png]]

56：
一级页表即页目录。

![[Pasted image 20230910122749.png]]

当时错选了B，答案是A。

抖动是一种进程间对内存的竞争激烈现象。主要矛盾在于物理内存不足，而非交换区不足，因此应当通过撤销进程的方式腾出一些物理内存。

![[Pasted image 20230910122930.png]]

当时错选了A，答案是C。

页表常驻内存可以避免将页表调入内存的成本。尽管PCB一般不会换出内存，但页表存在这种可能。

![[Pasted image 20230910123045.png]]

工作集包含最近k次访存所访问的页面集合，k为窗口大小。因此答案选A。

## 真题大题

### 2013：页式存储

![[Pasted image 20230909235916.png]]

当时做对了。

### 2009：访存耗时分析

![[Pasted image 20230910130809.png]]

**第一问**：
注意访问一个虚拟地址的时间包括两部分：第一部分是找到其物理地址，第二部分是访问物理地址对应的内存单元。

地址2362H：TLB未命中（10ns），访问页表命中（100ns），访问物理地址（100ns），总成本210ns。

地址1565H：TLB、页表未命中（110ns），处理缺页中断（10^8ns），TLB命中（10ns），访问物理地址（100ns），总成本10000220ns。

地址25A5H：TLB命中（10ns），访问物理地址（100ns），总成本110ns。

第二问：
物理地址为101565H。

### 2010：页面置换算法

![[Pasted image 20230910135501.png]]
![[Pasted image 20230910135508.png]]

第一问，页号是5。

**第二问**：
若根据FIFO算法，则淘汰原0号逻辑页面，新页面使用7号页框，物理地址为1FCAH。

若根据Clock算法，则从2号页框开始，顺时针旋转一圈，所有页面访问位清零，回到2号页框并将其淘汰，新页面使用2号页框，物理地址为0BCAH。

### 2012：页面置换策略、局部性原理

![[Pasted image 20230910142133.png]]

虚拟页为`<0,4>`时，分配21号页框；虚拟页为`<1,11>`时，使用之前分配的32号页框；虚拟页为`<2,14>`时，分配41号页框。

适合时间局部性好的程序，原因是程序及时调回被回收页面的概率大。

### 2015：二级页表

![[Pasted image 20230910144749.png]]

前两问送分，页和页框均为4KB，虚拟地址空间大小为2^20页，进程的页目录和页表总共有1025页。

第三问，由于两个地址有相同的页目录号，所以访问一个二级页表。

### 2017：

![[Pasted image 20230910145258.png]]
![[Pasted image 20230910145307.png]]

注1：2017年题43
![[Pasted image 20230910145500.png]]

2017年题44的代码部分
![[Pasted image 20230910145519.png]]

第一问，`f1`的机器指令在一页内。

第二问，页目录第1项对应的页表中的第1项。

第三问，P等待输入，进入阻塞态；输入结束时，转为就绪态；被调度上台，转为运行态。会进入内核态。

### 2018：二级页表、CLOCK算法

![[Pasted image 20230911193838.png]]

第一问，01806008H。

第二问，物理地址；进程切换时，PDBR会变化，因为不同进程一般采用不同页表；同一进程的线程切换时，PDBR一般不改变。

第三问，需要设置物理页框号、访问位、存在位等，如果是改进CLOCK则需要修改位。

### 2020：二级页表

![[Pasted image 20230911193848.png]]
![[Pasted image 20230911193855.png]]

第一问，`a[1,2]`的虚拟地址为10801008H。页目录号为66，页表号为1。页目录项的物理地址为00201108H，页表项的物理地址为00301004H。

第二问，在虚拟空间内数组`a`必须连续，在物理空间内不必连续。

第三问，按行遍历的局部性更好。

