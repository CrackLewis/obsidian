
## 框架

- 进程和线程的概念
	- 进程的概念和特征
	- 进程的状态和转换
	- 进程的组成：PCB、程序、数据
	- 进程控制：创建、终止、阻塞、唤醒
	- 进程通信：共享存储、消息传递、管道通信
	- 线程和多线程模型
		- 基本概念：处理机的最小分配单元（资源分配单元是进程）
		- 与进程的比较：调度、并发性、拥有资源、独立性、系统开销、多处理器系统
		- 线程属性
		- 线程状态和转换
		- 线程组织和控制
		- 线程实现方式：内核级线程、用户级线程
		- 多线程模型：多对一、一对一、多对多
- 处理机调度
	- 概念、目标
	- 实现：调度器、调度时机和过程、调度方式
	- 调度算法：FCFS、SJF、优先级调度、高响应比优先调度、时间片轮转调度、多级队列调度、多级反馈队列调度
	- 进程切换
- 同步和互斥
	- 基本概念：临界资源、同步（直接制约）、互斥（间接制约）
	- 临界区互斥实现方法
		- 软件方法：单标志法、双标志法先检查、双标志法后检查、Peterson算法
		- 硬件方法：TestAndSet、中断屏蔽
	- 互斥锁
	- 信号量
	- 管程
	- 经典同步问题：生产者-消费者问题、读者-写者问题、哲学家进餐问题、吸烟者问题
- 死锁
	- 概念
		- 必要条件：互斥、不剥夺、请求并保持、循环等待
		- 处理策略：预防、避免、检测
	- 死锁预防：破坏不剥夺、破坏请求并保持、破坏循环
	- 死锁避免：系统安全状态、银行家算法、安全性算法
	- 死锁检测和解除：资源分配图、死锁解除

## 调度算法的评价指标

CPU利用率：有效工作时间占总时间的比率，总时间包括有效工作时间和空闲等待时间。

系统吞吐量：单位时间CPU完成作业的数量。

周转时间：作业从提交到完成经历的时间。
- 作业周期：提交时刻-（响应时间）-开始时刻-（执行时间1）-暂停-（等待时间1）-恢复-（执行时间2）-暂停-（等待时间2）-……-恢复-（执行时间N）-执行完成。
- 多作业指标：
	- 平均周转时间：多个作业周转时间平均值。
	- 带权周转时间：作业周转时间和实际运行时间的比值。
	- 平均带权周转时间：多个作业带权周转时间
- 等待时间：进程等处理机的时间总和，包括响应时间和暂停后的等待时间。
- 响应时间：从用户提交到系统首次响应的时间。

## 调度时机和调度方式

**应当调度的情形**：
- 当前进程无法继续运行，并发生引起调度条件。
- 中断处理或自陷结束，返回现场前请求调度。

**不应调度的情形**：
- 中断处理过程中。
- 内核临界区中。
- 其他需要完全屏蔽中断的原子操作过程中。

**调度方式**：非剥夺方式、剥夺方式。

## 七种调度算法

### FCFS

先提交的，先服务，不可剥夺。

特点：算法简单、效率低，对短作业不利，有利于CPU繁忙型作业，不利于I/O繁忙型作业。

### SJF

短作业优先。可为可剥夺，也可为不可剥夺。

特点：对长作业不利（**饥饿现象**，和死锁问题中的饥饿现象不同），未考虑作业的紧迫程度，不一定切合最优的短作业优先调度情形。

### 优先级调度算法

优先级高的优先执行。可为可剥夺，也可为不可剥夺。

两类进程优先级：静态优先级、动态优先级。

一般的进程优先级比较规律：
- 系统进程>用户进程。
- 交互型进程>非交互型进程。
- I/O密集型进程>CPU密集型进程。

### 高响应比优先调度算法

**响应比**：
$$
R_P=\dfrac{T_w+T_r}{T_r}
$$
$T_w$表示作业已经等待的时间，$T_r$表示作业的要求服务时间。

原理：响应比高的优先执行。可为可剥夺，也可为不可剥夺。

特点：
- 等待时间相同时，要求服务的时间越短，响应比越高，类似SJF。
- 要求服务时间相同时，等待时间越长，响应比越高，类似FCFS。
- 克服了饥饿现象。

### 时间片轮转调度算法

必须是可剥夺。

**时间片大小的确定因素**：系统响应时间、队列内进程数目、系统处理能力。

### 多级队列调度算法

根据作业或进程类型或性质的不同，设置多个就绪队列，每个队列可采用不同的调度算法。

### 多级反馈队列调度算法

设置若干级FIFO队列和一级轮转队列。上一级队列的进程用完时间片后，进入下一级，最后一级队列的进程采用时间片轮转法。

时间片长度一般随着队列级数增加而倍增。

### 比较

![[Pasted image 20230906152735.png]]

不利于长作业：SJF

不利于短作业：FCFS

必须是不可抢占：FCFS

必须是可抢占：时间片轮转

## 多线程模型

**线程实现方式**：
- 用户级线程（ULT）：由应用程序在用户空间维护，对内核透明。
- 内核级线程（KLT）：由内核分配线程控制块并实施管理。

## 临界区互斥的四种软件实现方法

**同步机制准则**：空闲让进、忙则等待、有限等待、让权等待。

### 单标志法

用turn变量指示允许进入临界区的编号。

P0进程：等待turn=0的时机，执行后置turn=1。
```cpp
while(turn!=0);//依赖其他进程将turn调至0
work();
turn=1;
afterwork();
```

P1进程：等待turn=1的时机，执行后置turn=0。
```cpp
while(turn!=1);
work();
turn=0;
afterwork();
```

缺点：进程必须交替进入临界区，否则如果某个进程不进，其他进程也不会进。
### 双标志法先检查

置一个flag数组表示各进程是否进入临界区。每个进程会在进入前等待一个其他进程均未进入的时机进入，进入后置flag=1，离开时置flag=0。

Pi进程：
```cpp
while(flag[j]);//两个进程可能同时到达并进入，不符合互斥要求
flag[i]=1;
work();
flag[i]=0;
afterwork();
```

Pj进程：
```cpp
while(flag[i]);
flag[j]=1;
work();
flag[j]=0;
afterwork();
```

缺点：进程可能同时进入。

### 双标志法后检查

Pi进程：
```cpp
flag[i]=1;
while(flag[j]);//多个互斥进程会等对方将flag[j]调为0，造成饥饿
work();
flag[i]=0;
afterwork();
```

Pj进程：
```cpp
flag[j]=1;
while(flag[i]);
work();
flag[j]=0;
afterwork();
```

缺点：如果进程同时到达，它们会互相谦让，导致没有进程进入临界区，是另一种**饥饿现象**。

### Peterson算法

既设置flag数组，也设置turn。既不会饥饿，也可以互斥访问。

Pi进程：
```cpp
flag[i]=1;turn=j;//turn的设置明确了只有一个flag有意义，避免了饥饿
while(flag[j]&&turn==j);//flag的设置明确了谁能进入互斥区
work();
flag[i]=0;
afterwork();
```

Pj进程：
```cpp
flag[j]=1;turn=i;
while(flag[i]&&turn==i);
work();
flag[j]=0;
afterwork();
```

## 临界区互斥的其他实现方法

### 硬件方法

- 中断屏蔽
- 硬件指令方法：TestAndSet指令、Swap指令。

### 互斥锁

```cpp
acquire() {
	while(!available);
	available=false;
}
release() {
	available=true;
}
```

### 信号量

```cpp
wait(S) { //请求一个信号量
	while(S<=0);
	S--;
}
signal(S) { //释放一个信号量
	S++;
}
```

如果为整形信号量，`wait`又称P操作，`signal`又称V操作。

### 管程

```cpp
monitor Demo {
	data_structure S;
	condition x;
	init_code() { //...
	}
	take_away() {
		if(S<=0) x.wait();
		//allocate on S
	}
	give_back() {
		//deallocate on S
		if(有进程等待) x.signal();
	}
}
```

## 死锁问题

**四个条件**：互斥、不剥夺、请求保持、循环等待。

**死锁预防措施**：破坏除了互斥以外的条件。

**死锁检测措施**：

### 死锁避免措施

**安全状态**：系统可以通过某种特定的进程推进顺序，避免死锁情形的发生。

**安全性算法概念描述**：
- Available（可利用资源向量）：含有`m`个元素的数组，每个元素表示系统内一类资源的剩余数量。
- Max（最大需求矩阵）：`n*m`矩阵，表示`n`个进程在生命期内对每类资源的最大需求。
- Allocation（分配矩阵）：`n*m`矩阵，表示`n`个进程分别已取得的每类资源数目。
- Need（需求矩阵）：`n*m`矩阵，表示`n`个进程所需要的剩余资源。恒有`Need[i,j]=Max[i,j]-Allocation[i,j]`成立。
- Work（工作向量）：在算法执行中的某个时刻，系统内各资源的数量。初始时，`Work=Available`。

**安全性算法举例**：
![[Pasted image 20230909155834.png]]

假设系统的可利用资源向量为`[3,3,2]`。

一种可行的进程推进顺序：
- `P1`：`[3,3,2]=>[5,3,2]`
- `P3`：`[5,3,2]=>[7,4,3]`
- `P4`：`[7,4,3]=>[7,4,5]`
- `P2`：`[7,4,5]=>[10,4,7]`
- `P0`：`[10,4,7]=>[10,5,7]`

### 死锁处理策略对比

![[Pasted image 20230909145023.png]]

## 四个经典同步问题

WIP

## 真题选择题错题

![[Pasted image 20230906161616.png]]

答案选D。线程拥有的资源仅限于寄存器组、PC、堆栈和线程ID，其中栈指针是不共享的。

![[Pasted image 20230906161738.png]]

答案选C。管道为空时，读管道操作会被阻塞。

![[Pasted image 20230906154902.png]]

答案选D。时间片轮转并非综合考虑的结果。

![[Pasted image 20230906154755.png]]

答案选D。之前选了两次C，原因是：执行P2之前有一次调度，那个1微秒没算。

![[Pasted image 20230906182006.png]]

答案选B。

A项唤醒的进程处于就绪态（进程卡在循环语句，并未放弃处理机）。

C项，由于进程等待期间占据处理机，不符合让权等待的原则。

D项，操作不能关中断，否则系统可能终止。

![[Pasted image 20230906182050.png]]

答案选D、C、C。

47题，`x.wait()`方法只有在资源不足时会被调用，进程会被挂到`x`对应的阻塞队列，直到其他进程调用`x.signal()`将进程唤醒。

48题，硬件方法和软件方法都是占处理机等待，不是让权等待，信号量方法是让权等待。

49题，原则上互斥机制下的空闲资源必须是可被访问的。

![[Pasted image 20230909160541.png]]

32题，先满足一个进程的资源需求，再看其他进程是否死锁。比如先满足P4的请求，则P1、P2、P3会竞争三个资源。只有两种可能的死锁情形，均涉及3个进程：
- P1持有R1，请求R2。
- P2持有R2，请求R3。
- P3持有R3，请求R1。
因此至少涉及3个进程。

![[Pasted image 20230909160948.png]]

37题，可行方案有`P0->P2->P1`和`P0->P1->P2`两种。

## 真题大题

这部分每年几乎稳定一道。

### 2016：调度算法问题

**调度算法问题**：

![[Pasted image 20230908140626.png]]
![[Pasted image 20230908140633.png]]

第一问，如果低优先级的进程持续出现，则高优先级的进程可能一直得不到执行。

第二问：
$$
priority=nice+k_1\cdot cpuTime-k_2\cdot waitTime
$$
执行时间越长，动态优先级越低；等待时间越长，动态优先级越高。

### 2009&2011

**同步和互斥问题**：

![[Pasted image 20230906184206.png]]

18题：
```cpp
semaphore mutex=1; //缓冲区的互斥锁
semaphore odd=0,even=0;
semaphore empty=N;

cobegin {

Process P1() {
	while (true) {
		int x=produce(); //生成随机数
		P(empty);
		P(mutex);
		put(x); //将x放入缓冲区
		V(mutex);
		if(x%2==0) V(even); //如果是偶数，则释放even信号量
		else V(odd); //如果是奇数，则释放odd信号量
	}
}

Process P2() {
	while (true) {
		P(odd);
		P(mutex);
		getodd();
		V(mutex);
		V(empty);
		countodd();
	}
}

Process P3() {
	while (true) {
		P(even);
		P(mutex);
		geteven();
		V(mutex);
		V(empty);
		counteven();
	}
}

} coend
```

19题：
- 叫号需要一个信号量，用于实现客户和服务员的同步。

```cpp
semaphore mutex=1; //取号机的互斥锁
semaphore empty=10,full=0; //空座位和被占座位
semaphore service=0; //叫号

cobegin {
	Process Customer_i {
		P(empty); //等空位
		P(mutex); //开始取号
		assign(); //取号
		V(mutex); //取号完毕
		V(full); //通知营业员有新顾客
		P(service); //等待服务员叫号
		service();
	}

	Process Staff {
		while(true) {
			P(full); //没有顾客则阻塞
			//有顾客，叫号并释放其座位
			V(empty); 
			V(service); //叫号
			serve();
		}
	}
}
```

### 2013&2014

![[Pasted image 20230906184222.png]]

20题：
- 入口和出口使用同一个互斥锁。
- 容量初始值为500，在最外层加锁。

```cpp
semaphore mutex=1;
semaphore cap=500;

cobegin {
	Process Visitor_i() {
		P(cap);
		P(mutex);
		enter();
		V(mutex);
		visit();
		P(mutex);
		exit();
		V(mutex);
		V(cap);
	}
} coend
```

21题：
- 题目要求消费者要一次连续取10件，10次取操作不能被打断，所以除了缓冲区本身的互斥锁外，还需要为十次操作添加一个**外部互斥锁**。

```cpp
semaphore empty=1000,full=0;
semaphore mutex1=1; //缓冲区的外部互斥锁
semaphore mutex2=1; //缓冲区的内部互斥锁

cobegin {
	Process Producer_i() {
		while(1) {
			produce();
			P(empty);
			P(mutex2);
			put();
			V(mutex2);
			V(full);
		}
	}

	Process Consumer_j() {
		while(1) {
			P(mutex1); //外部锁定，其他消费者进程不能打断
			for(int i=0;i<10;++i) {
				P(full);
				P(mutex2);
				fetch();
				V(mutex2);
				V(empty);
				consume();
			}
			V(mutex1); //外部解锁，允许其他消费者进程取操作
		}
	}
} coend
```

### 2015

![[Pasted image 20230906184238.png]]

22题：
- 注意full、empty信号量放在mutex外部的设计，这是为了防止在A邮箱为空的情形下，A进程取得`mutex_A`之后阻塞，B进程无法取得`mutex_A`，也无法放入新邮件，造成死锁现象。

```cpp
semaphore full_A=x,empty_A=M-x,mutex_A=1;
semaphore full_B=y,empty_B=N-y,mutex_B=1;

cobegin {
	Process A {
		while(true) {
			//从A信箱里取信件
			P(full_A);
			P(mutex_A);
			fetch_from_A();
			V(mutex_A);
			V(empty_A);
			//回答并提出新问题
			answer_and_ask();
			//放入B信箱
			P(empty_B);
			P(mutex_B);
			put_into_B();
			V(mutex_B);
			V(full_B);
		}
	}

	Process B {
		//与A对称，将A/B对调即可
	}
} coend
```

### 2017&2019&2020

![[Pasted image 20230906184301.png]]

**23题**：
读写关系如下：
- `x`：thread1读。
- `y`：thread1、2、3读，thread3写。
- `z`：thread2、3读，thread3写。

基本的设计是对`y`和`z`分别加锁，但题目要求最大限度并发，如果`y`只设一个锁，则一个周期的执行时间为`T1+T2+T3`。如果对`y`设两个锁，让只读取不写入`y`的thread1、thread2同步执行，则执行时间可降低为`T3+min(T1,T2)`。

```cpp
semaphore mutex_y1=1,mutex_y2=1,mutex_z=1;

thread1 {
	cnum w;
	P(mutex_y1);
	w=add(x,y);
	V(mutex_y1);
	// ...
}

thread2 {
	cnum w;
	P(mutex_y2);
	P(mutex_z);
	w=add(y,z);
	V(mutex_z);
	V(mutex_y2);
	// ...
}

thread3 {
	cnum w = {.a=1,.b=1};
	P(mutex_z);
	z=add(z,w);
	V(mutex_z);
	// 注意要嵌套两个锁，起到同步t1,t2的作用
	P(mutex_y1);
	P(mutex_y2);
	y=add(y,w);
	V(mutex_y2);
	V(mutex_y1);
	// ...
}
```

**24题**：
- 筷子要用信号量数组，初始值设置为1。
- 碗的信号量值取（人数-1）和碗数的最小值，原因：
	- 碗的数量不能超过`m`，这是资源限制。
	- 碗的数量也不宜超过`n-1`，否则可能出现所有哲学家同时持有一只筷子和一个碗，但拿不到其他筷子的死锁情形。

```cpp
semaphore bowl=min(n-1,m); 
semaphore chopsticks[n];
for(int i=0;i<n;++i) chopsticks[i]=1;

cobegin {
	while(true) {
		think();
		P(bowl);
		//取筷子
		P(chopsticks[i]);
		P(chopsticks[(i+1)%n]);
		eat();
		V(chopsticks[i]);
		V(chopsticks[(i+1)%n]);
		V(bowl);
	}
} coend
```

**25题**：
比较简单，为每对约束关系设置一个信号量，通过信号量约束先后顺序即可。

### 2021&2022

![[Pasted image 20230906184322.png]]
![[Pasted image 20230906184337.png]]

**26题**：
第一问，因为多个进程可以通过调用`wait(S)`和`signal(S)`对`S`进行修改，所以`wait`和`signal`对`S`的访问必须互斥。

第二问，方法一是错误的，方法二是正确的。方法一中`wait(S)`内的循环一直处于关中断状态，进程无法响应中断，其他进程无法修改`S`的值解除这种局面，造成死循环。方法二中的循环内部会开关中断，给予其他进程被调度上台的机会，不会造成死循环。

第三问，不能。开关中断是特权指令，不能在用户态下执行。

**27题**：
交错约束问题。

```cpp
semaphore AC=0,CE=0;

T1() {
	A();
	V(AC); //->T2
	P(CE); //<-T2
	E();
	F();
}

T2() {
	B();
	P(AC); //<-T1
	C();
	V(CE); //->T1
	D();
}
```
