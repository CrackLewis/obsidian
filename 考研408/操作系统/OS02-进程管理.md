
## 框架

- 进程和线程的概念
	- 进程的概念和特征
	- 进程的状态和转换
	- 进程的组成：PCB、程序、数据
	- 进程控制：创建、终止、阻塞、唤醒
	- 进程通信：共享存储、消息传递、管道通信
	- 线程和多线程模型
		- 基本概念：处理机的最小分配单元（资源分配单元是进程）
		- 与进程的比较：调度、并发性、拥有资源、独立性、系统开销、多处理器系统
		- 线程属性
		- 线程状态和转换
		- 线程组织和控制
		- 线程实现方式：内核级线程、用户级线程
		- 多线程模型：多对一、一对一、多对多
- 处理机调度
	- 概念、目标
	- 实现：调度器、调度时机和过程、调度方式
	- 调度算法：FCFS、SJF、优先级调度、高响应比优先调度、时间片轮转调度、多级队列调度、多级反馈队列调度
	- 进程切换
- 同步和互斥
	- 基本概念：临界资源、同步（直接制约）、互斥（间接制约）
	- 临界区互斥实现方法
		- 软件方法：单标志法、双标志法先检查、双标志法后检查、Peterson算法
		- 硬件方法：TestAndSet、中断屏蔽
	- 互斥锁
	- 信号量
	- 管程
	- 经典同步问题：生产者-消费者问题、读者-写者问题、哲学家进餐问题、吸烟者问题
- 死锁
	- 概念
		- 必要条件：互斥、不剥夺、请求并保持、循环等待
		- 处理策略：预防、避免、检测
	- 死锁预防：破坏不剥夺、破坏请求并保持、破坏循环
	- 死锁避免：系统安全状态、银行家算法、安全性算法
	- 死锁检测和解除：资源分配图、死锁解除

## 调度算法的评价指标

CPU利用率：有效工作时间占总时间的比率，总时间包括有效工作时间和空闲等待时间。

系统吞吐量：单位时间CPU完成作业的数量。

周转时间：作业从提交到完成经历的时间。
- 作业周期：提交时刻-（响应时间）-开始时刻-（执行时间1）-暂停-（等待时间1）-恢复-（执行时间2）-暂停-（等待时间2）-……-恢复-（执行时间N）-执行完成。
- 多作业指标：
	- 平均周转时间：多个作业周转时间平均值。
	- 带权周转时间：作业周转时间和实际运行时间的比值。
	- 平均带权周转时间：多个作业带权周转时间
- 等待时间：进程等处理机的时间总和，包括响应时间和暂停后的等待时间。
- 响应时间：从用户提交到系统首次响应的时间。

## 调度时机和调度方式

**应当调度的情形**：
- 当前进程无法继续运行，并发生引起调度条件。
- 中断处理或自陷结束，返回现场前请求调度。

**不应调度的情形**：
- 中断处理过程中。
- 内核临界区中。
- 其他需要完全屏蔽中断的原子操作过程中。

**调度方式**：非剥夺方式、剥夺方式。

## 七种调度算法

### FCFS

先提交的，先服务，不可剥夺。

特点：算法简单、效率低，对短作业不利，有利于CPU繁忙型作业，不利于I/O繁忙型作业。

### SJF

短作业优先。可为可剥夺，也可为不可剥夺。

特点：对长作业不利（**饥饿现象**，和死锁问题中的饥饿现象不同），未考虑作业的紧迫程度，不一定切合最优的短作业优先调度情形。

### 优先级调度算法

优先级高的优先执行。可为可剥夺，也可为不可剥夺。

两类进程优先级：静态优先级、动态优先级。

一般的进程优先级比较规律：
- 系统进程>用户进程。
- 交互型进程>非交互型进程。
- I/O密集型进程>CPU密集型进程。

### 高响应比优先调度算法

**响应比**：
$$
R_P=\dfrac{T_w+T_r}{T_r}
$$
$T_w$表示作业已经等待的时间，$T_r$表示作业的要求服务时间。

原理：响应比高的优先执行。可为可剥夺，也可为不可剥夺。

特点：
- 等待时间相同时，要求服务的时间越短，响应比越高，类似SJF。
- 要求服务时间相同时，等待时间越长，响应比越高，类似FCFS。
- 克服了饥饿现象。

### 时间片轮转调度算法

必须是可剥夺。

**时间片大小的确定因素**：系统响应时间、队列内进程数目、系统处理能力。

### 多级队列调度算法

根据作业或进程类型或性质的不同，设置多个就绪队列，每个队列可采用不同的调度算法。

### 多级反馈队列调度算法

设置若干级FIFO队列和一级轮转队列。上一级队列的进程用完时间片后，进入下一级，最后一级队列的进程采用时间片轮转法。

时间片长度一般随着队列级数增加而倍增。

### 比较

![[Pasted image 20230906152735.png]]

不利于长作业：SJF

不利于短作业：FCFS

必须是不可抢占：FCFS

必须是可抢占：时间片轮转

## 多线程模型

**线程实现方式**：
- 用户级线程（ULT）：由应用程序在用户空间维护，对内核透明。
- 内核级线程（KLT）：由内核分配线程控制块并实施管理。

## 临界区互斥的四种软件实现方法

**同步机制准则**：空闲让进、忙则等待、有限等待、让权等待。

### 单标志法

用turn变量指示允许进入临界区的编号。

P0进程：等待turn=0的时机，执行后置turn=1。
```cpp
while(turn!=0);
work();
turn=1;
afterwork();
```

P1进程：等待turn=1的时机，执行后置turn=0。
```cpp
while(turn!=1);
work();
turn=0;
afterwork();
```

缺点：进程必须交替进入临界区，否则如果某个进程不进，其他进程也不会进。
### 双标志法先检查

置一个flag数组表示各进程是否进入临界区。每个进程会在进入前等待一个其他进程均未进入的时机进入，进入后置flag=1，离开时置flag=0。

Pi进程：
```cpp
while(flag[j]);
flag[i]=1;
work();
flag[i]=0;
afterwork();
```

Pj进程：
```cpp
while(flag[i]);
flag[j]=1;
work();
flag[j]=0;
afterwork();
```

缺点：进程可能同时进入。

### 双标志法后检查

Pi进程：
```cpp
flag[i]=1;
while(flag[j]);
work();
flag[i]=0;
afterwork();
```

Pj进程：
```cpp
flag[j]=1;
while(flag[i]);
work();
flag[j]=0;
afterwork();
```

缺点：如果进程同时到达，它们会互相谦让，导致没有进程进入临界区，是另一种**饥饿现象**。

### Peterson算法

既设置flag数组，也设置turn。既不会饥饿，也可以互斥访问。

Pi进程：
```cpp
flag[i]=1;turn=j;
while(flag[j]&&turn==j);
work();
flag[i]=0;
afterwork();
```

Pj进程：
```cpp
flag[j]=1;turn=i;
while(flag[i]&&turn==i);
work();
flag[j]=0;
afterwork();
```

## 临界区互斥的其他实现方法

### 硬件方法

- 中断屏蔽
- 硬件指令方法：TestAndSet指令、Swap指令。

### 互斥锁

```cpp
acquire() {
	while(!available);
	available=false;
}
release() {
	available=true;
}
```

### 信号量

```cpp
wait(S) { //请求一个信号量
	while(S<=0);
	S--;
}
signal(S) { //释放一个信号量
	S++;
}
```

如果为整形信号量，`wait`又称P操作，`signal`又称V操作。

### 管程

```cpp
monitor Demo {
	data_structure S;
	condition x;
	init_code() { //...
	}
	take_away() {
		if(S<=0) x.wait();
		//allocate on S
	}
	give_back() {
		//deallocate on S
		if(有进程等待) x.signal();
	}
}
```

## 四个经典同步问题

WIP

## 真题选择题错题

![[Pasted image 20230906161616.png]]

答案选D。线程拥有的资源仅限于寄存器组、PC、堆栈和线程ID，其中栈指针是不共享的。

![[Pasted image 20230906161738.png]]

答案选C。管道为空时，读管道操作会被阻塞。

![[Pasted image 20230906154902.png]]

答案选D。时间片轮转并非综合考虑的结果。

![[Pasted image 20230906154755.png]]

答案选D。之前选了两次C，原因是：执行P2之前有一次调度，那个1微秒没算。

![[Pasted image 20230906182006.png]]

答案选B。

A项唤醒的进程处于就绪态（进程卡在循环语句，并未放弃处理机）。

C项，由于进程等待期间占据处理机，不符合让权等待的原则。

D项，操作不能关中断，否则系统可能终止。

![[Pasted image 20230906182050.png]]

答案选D、C、C。

47题，`x.wait()`方法只有在资源不足时会被调用，进程会被挂到`x`对应的阻塞队列，直到其他进程调用`x.signal()`将进程唤醒。

48题，硬件方法和软件方法都是占处理机等待，不是让权等待，信号量方法是让权等待。

49题，原则上互斥机制下的空闲资源必须是可被访问的。

## 真题大题

这部分每年几乎稳定一道。

**调度算法问题**：

![[Pasted image 20230908140626.png]]
![[Pasted image 20230908140633.png]]

**同步和互斥问题**：

![[Pasted image 20230906184206.png]]
![[Pasted image 20230906184222.png]]
![[Pasted image 20230906184238.png]]
![[Pasted image 20230906184301.png]]
![[Pasted image 20230906184322.png]]
![[Pasted image 20230906184337.png]]

