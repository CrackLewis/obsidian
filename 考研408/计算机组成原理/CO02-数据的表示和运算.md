
## 框架

- 数制与编码
	- 进位计数制及其相互转换
	- BCD码（略）
	- 定点数的编码表示：原码、反码、补码、移码
	- 整数的表示
- 运算方法和运算电路
	- 基本运算部件
	- 定点数的移位运算
	- 定点数的加减运算
	- 定点数的乘除运算
	- C语言中的整数类型及类型转换
	- 数据的存储和排列
- 浮点数的表示与运算
	- 浮点数的表示
	- 浮点数的加减运算

## 定点数的编码表示

**定点表示**：
- 定点小数：`A.XXXX`，A为符号位。
- 定点整数：`AXXXX`，A为符号位。

| 表示法 | `x1=+0.1101` | `x2=-0.1101` | 0的表示 | 优点 | 缺点 |
| --- | --- | --- | --- | --- | --- |
| 原码 | `0.1101` | `1.1101` | 不唯一 | 与真值的对应关系直观 | 0的表示不唯一，计算复杂 |
| 补码 | `0.1101` | `1.0011` | `0.0000` | 计算简便 | 无 |
| 反码 | `0.1101` | `1.0010` | 不唯一 | 无 | 0的表示不唯一，表示范围少一个负数 |
| 移码 | `1.1101` | `0.0011` | `1.0000` | 无 | 欠直观 |

## 加法运算部件

**一位全加器**：
- 输入：加数$A_i,B_i$和前一位进位$C_{i-1}$。
- 输出：本位和$S_i$和进位$C_i$。

$$
S_i=A_i\oplus B_i\oplus C_{i-1}, C_i=A_i B_i+(A_i\oplus B_i)C_{i-1}
$$

![[Pasted image 20230922211834.png]]

**串行进位加法器**：多个一位全加器串联。

**并行进位加法器**：
令进位产生函数$G_i=A_i B_i$，进位传递函数$P_i=A_i\oplus B_i$，则全加器的进位表达式为：
$$
C_i=G_i+P_i C_{i-1}
$$
对于4位全加器，有：
$$
C_4=G_4+P_4C_3=G_4+P_4G_3+P_4P_3G_2+P_4P_3P_2G_1+P_4P_3P_2P_1C_0
$$

逻辑线路表示：
![[Pasted image 20230922212733.png]]

## 定点数的乘法运算

### 原码一位乘法

设被乘数为$x_S. x_1x_2\cdots x_n$，乘数为$y_S.y_1y_2\cdots y_n$，运算规则：
- 符号位不参加运算，乘积符号位为$x_S\oplus y_S$，乘数取绝对值参加运算，以原码形式表示。
- **生成部分积**：部分积是乘法过程的中间结果。乘数的每一位$y_i$乘以被乘数得$X\cdot y_i$后，将该结果和之前的结果累加，得到部分积，初值为0。
- **部分积右移**：从乘数的最低位$y_n$开始判断：若$y_n=1$，则部分积加上被乘数$|x|$，然后右移一位；若$y_n=0$，则部分积加上0，然后右移一位。
- 重复步骤，判断$n$次。

![[Pasted image 20230922230510.png]]

### 补码一位乘法（Booth算法）

设$[X]_{补}=x_s.x_1x_2\cdot x_n$，$[Y]_{补}=y_s.y_1y_2\cdots y_n$，运算规则：
- 符号位参加运算，运算结果均通过补码表示。
- 被乘数和部分积取双符号位，初值为0，乘数取单符号位。
- 乘数末位增设附加位$y_{n+1}$，初值为0。
- **根据尾数加或减**：根据$(y_n,y_{n+1})$的当前取值情况，分别采取不同操作：
	- $(0,0)$、$(1,1)$：不进行操作。
	- $(0,1)$：部分积加$[X]_{补}$。
	- $(1,0)$：部分积加$[-X]_{补}$。
- 如果当前是第$n+1$次操作，则结束运算；否则部分积**整体右移一位**。这意味着整个运算包括$n+1$次操作和$n$次移位。
- 细节：
	- 部分积包括左侧的高位部分积和右侧的低位部分积，高位部分积的初始值为$x_sx_s.x_1x_2\cdots x_n$，低位部分积的初始值为$y_s.y_1y_2\cdots y_ny_{n+1}$。
	- 运算在左侧的高位部分积上进行。
	- 移位操作会将左侧高位部分积的最右一位移出，移到右侧低位部分积的最左侧，右侧部分积的小数点不动。最左侧补位采用符号补位。
	- 运算结束时，$y_n$和$y_{n+1}$应恰在小数点两侧。运算结果取左侧部分积全部和右侧部分积的高$n$位。

![[Pasted image 20230922232613.png]]

最终结果：$[x\cdot y]_{补}=-0.01110001$。

## 定点数的除法运算

### 原码除法运算（不恢复余数法）

设被除数$[X]_{原}=x_s.x_1x_2\cdots x_n$，除数$[Y]_{原}=y_s.y_1y_2\cdots y_n$。

运算规则：
- 商的符号$Q_s=x_s\oplus y_s$，符号位不参与计算。
- 先用被除数减去除数。根据余数的正负采取不同行动：
	- 余数为正：商1，余数和商左移一位，减去除数。
	- 余数为负：商0，余数和商左移一位，加上除数。
- 上述步骤执行$n+1$步，若第$n+1$步余数为负，则需要加除数得到正确的余数。

![[Pasted image 20230922233730.png]]
![[Pasted image 20230922233744.png]]

### 补码除法运算（加减交替法）

运算规则：
- 符号位参加运算，除数与被除数均用补码表示，商和余数也用补码表示。
- 若被除数和除数同号，则被除数减去除数；若被除数和除数异号，则被除数加上除数。
- 根据余数和除数的符号情况，操作$n$轮：
	- 若两者同号，则商1，余数左移一位，减去除数。
	- 若两者异号，则商0，余数左移一位，加上除数。
- 若对商的精度没有特别要求，则一般末位恒置1。

![[Pasted image 20230923014902.png]]
![[Pasted image 20230923014914.png]]

## 状态位（CF、OF、ZF）在运算中的变化



## 选择题整理-非真题

![[Pasted image 20230923094111.png]]

17题选D。x为0或正数时都满足条件。

![[Pasted image 20230923094122.png]]

20题选A。如果整数表示法区分+0和-0，说明只能是原码或反码的一种。由于原码的-0表示为10000000，反码的-0表示为11111111，所以题中的表示为原码表示。

21题选D。原码、反码、补码的+127表示为01111111，只有移码的符号位为1。

![[Pasted image 20230923095412.png]]

3题选C。虽然A、B、D也是影响因素，但对于串行进位的加法器而言，C项会直接决定加法器的运算速度，因此最为关键。

![[Pasted image 20230923095422.png]]

10题选C。容易忽视不带进位位这一提示而误选A。在不带进位位的循环左移中，最高位会同时送入CF和最低位。

![[Pasted image 20230923095446.png]]

15题选B。**模4补码**即双符号位补码，模2补码即单符号位补码。

A项说法有误，应该是更易检查加减运算中的溢出问题。

B项是正确的，只有操作模4补码时需要用到两个符号位，而在存储期间不需要，可以只存储一位。同理，C项是错误的。

D项错误，在ALU中操作模4补码需要两个符号位。

![[Pasted image 20230923095543.png]]

22题选B。运算结果的符号位直接通过乘数符号位决定。

![[Pasted image 20230923095723.png]]

24题选D。乘积包括符号位，因此总共2N+1位。

![[Pasted image 20230923095735.png]]

![[Pasted image 20230923095744.png]]

## 选择题整理-真题

![[Pasted image 20230923095829.png]]

## 大题整理

