
## 框架

- 指令系统
	- 指令的基本格式
	- 定长操作码指令格式
	- 扩展操作码指令格式
	- 指令的操作类型
- 指令的寻址方式
	- 指令寻址和数据寻址
	- 常见的数据寻址方式
- 程序的机器级代码表示
- CISC和RISC的基本概念

## 指令的寻址方式

![[Pasted image 20230925192826.png]]

## 程序的机器级代码表示（x86）

### 寄存器组

- 通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP
- 标志寄存器：EFLAGS
- 指令寄存器：EIP
- 段寄存器：CS、DS、SS、ES、FS、GS
- 控制寄存器：CR0（CPU控制）、CR2（页错误地址）、CR3（页目录地址寄存器）、CR4（当前任务）
- 调试寄存器：DR0-DR7
- 描述符寄存器：GDTR、LDTR、IDTR
- 任务寄存器：TR
- 模型特定寄存器

### 汇编语言的寻址方式

| 寻址方式 | AT&T | Intel |
| --- | --- | --- |
| 立即数寻址 | `$100` | `100` |
| 寄存器寻址 | `%eax` | `eax` |
| 寄存器间接寻址 | `(%eax)` | `[eax]` |
| 基址寻址 | `-8(%ebp)` | `[ebp-8]` |
| 变址寻址 | `8(%edx,%eax,2)` | `[edx+eax*2+8]` |

### 常用指令

**数据传送指令**：
- mov
- push
- pop
- lea

**算术和逻辑运算指令**：
- add、sub
- inc、dec
- imul
- idiv
- and、or、xor
- not：对寄存器或存储单元取反并写回
- neg：对寄存器或存储单元取负并写回
- shl、shr、sar

**控制流指令**：
- jmp
- 条件跳转指令
- cmp、test
- call、ret

### 过程调用的机器级表示

![[Pasted image 20230927150501.png]]

**用例分析**：
- 进入阶段（2-4）：设置本栈帧的基址，保存实参到栈帧内。
- 运算阶段（5-10）：根据实参计算y的值。
- 结果存储阶段（11）：将y的值存储在栈帧的对应位置。
- 返回阶段（12-14）：将返回值装在eax中，恢复前一帧的栈帧，跳转回调用处。

**过程调用步骤**：P为调用者，Q为被调用者。
- P将入口参数放在Q能访问的地方。
- P将返回地址存到特定地方，向Q移交控制。
- Q保存P的现场，为自己的局部变量分配空间。
- 执行Q。
- Q恢复P的现场，将结果放到P能访问的地方，释放空间。
- Q取出返回地址，将控制转移到P。

**调用与被调用者保存协议**（了解）

## RISC和CISC对比

![[Pasted image 20230927195122.png]]
![[Pasted image 20230927195134.png]]

## 选择题整理-非真题

### 4.1-指令系统

![[Pasted image 20230925171350.png]]

5题选C。中断隐指令是硬件指令。

![[Pasted image 20230925171411.png]]

7题选C。基于堆栈的零地址指令一般是向栈压入一个数，或是弹出一个数。所以操作数一般来源于栈顶的两个数。

8题选B。即使是单地址指令也可能由于单地址的寻址方式不同而导致指令长度不同。

9题选B。不指明第二个操作数，而是隐含在指令中的寻址方式称为隐含寻址。

### 4.2-指令的寻址方式

![[Pasted image 20230926091214.png]]

1题选B。采用不同寻址方式可以缩短指令字长，扩大寻址空间，提高编程的灵活性。

![[Pasted image 20230926091251.png]]

10题选D，易错选C。注意取指阶段，PC已经变为下一条指令的地址，所以译码和执行阶段使用的是以**下条指令**在内存中首地址为基准位置的偏移量。

![[Pasted image 20230926092814.png]]

14题选B。指令寄存器的位数不一定等于机器字长，但一定等于指令字长。程序计数器的位数一般取存储器的字数。

![[Pasted image 20230926094802.png]]

16题选A。注意题目问的是操作数的有效地址，而非操作数本身，所以查8号寄存器的值即可。

### 4.3-程序的机器级代码表示

WIP

### 4.4-CISC和RISC

![[Pasted image 20230927194929.png]]

3题选D。C项说法是错的，RISC减少指令数的目标是对的，但不完全是通过增加每条指令的功能实现的。

## 选择题整理-真题

![[Pasted image 20230925172355.png]]

15题选B。加法器的进位方式不是体系结构规定的内容，属于电路设计内容。

![[Pasted image 20230926095913.png]]
![[Pasted image 20230926095923.png]]

26题选B。注意double变量占据8个字节。

27题选D。

28题选A。需要注意两点：
- 指令需要6位操作码字段和2位**寻址特征位**。
- 主存地址不能为负，所以可寻址范围是`0~255`。

## 大题整理

### 2010：双地址指令系统

![[Pasted image 20230926100941.png]]

第一问，最多16条指令。最多8个通用寄存器。MAR至少需要16位，MDR至少需要16位。

第二问，0000H\~FFFFH。

第三问，二进制表示为0010 001 100 010 101B，十六进制表示为2315H。该指令执行后，R5会改变，首先是自增，其次是存储和R4相加的结果：R5=5679H，R5=(R5)+(R4)=68ACH。（自增结果被覆盖）

### 2013：转移指令

![[Pasted image 20230926100957.png]]

第一问，按字节编址。最多反向跳转127条指令。

第二问：
- PC=200CH-56=200CH-38H=1FD4H。
- PC=200EH。

第三问，C=1，Z=1，N=0。

第四问：
- 1是指令寄存器。
- 2是**移位寄存器**，将输入左移一位。
- 3是加法器。

### 2015：结合CPU结构的指令周期分析

（2015年43题，题中有44题的补充信息）
![[Pasted image 20230927160722.png]]
![[Pasted image 20230927160737.png]]

（2015年44题）
![[Pasted image 20230926101018.png]]

第一问，128条指令。

第二问：
- 0240H。
- 0000 010 0 10 0 01 0 00B：0488H。
- 0000 011 0 11 1 01 0 10B：06EAH。

第三问：本题和43题联系紧密。
![[Pasted image 20230927171019.png]]
- 1：0
- 2：mov
- 3：mova
- 4：left
- 5：read
- 6：sub
- 7：mov
- 8：SRout

第四问：
- 4个周期。R2间接取址2个周期，计算1个周期，回写1个周期。
- 2个周期。计算1个周期，回写2个周期。

### 2021：指令集

![[Pasted image 20230926101035.png]]
![[Pasted image 20230926101046.png]]

第一问，8位。可寻址主存空间为1048576B。MAR应当有20位，MDR应当有8位。

第二问：
- R型最多有16种操作。
- I和J型最多有63种操作。（**注意**：两种指令的操作码不能重复，且全0要预留给R型操作）
- 通用寄存器最多4个。

第三问：
- 将R1和R2的内容相减，结果存储在R3中。
- 执行01B2H后，R3的内容是B04AH，结果不溢出；执行01B3H后，R3的内容是8290H，结果溢出。

第四问，符号扩展。

第五问，J格式。

### 2017：汇编程序分析

![[Pasted image 20230927183817.png]]
![[Pasted image 20230927183828.png]]

第一问，CISC。各条指令不等长是CISC的典型特征。

第二问，指令代码共有96B。

第三问，CF=1。

第四问，不能，因为浮点数并不支持左移操作，左移会破坏浮点数的内部结构。

### 2019：汇编程序分析、Cache

![[Pasted image 20230927183902.png]]
![[Pasted image 20230927183916.png]]
![[Pasted image 20230927183933.png]]

本题是2019年的43、44题。43题之前做过，错了第三、五问。

第三问，第17行的虚拟地址是40102AH，注意不是401030H。

第五问，在imul指令后应该加一个条件自陷指令。

44题做对了，这里不再详细描述。