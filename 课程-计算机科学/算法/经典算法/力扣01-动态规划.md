
## 22-括号生成

[link](https://leetcode.cn/problems/generate-parentheses/description/)

数字 `1<=n<=8` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**思路**：
- 暴力法：生成所有`1<=n<=8`的括号序列逐个检查，检查规则是任意前缀的右括号数不多于左括号，且左右括号总数一致。时间复杂度$O(2^{2n}\cdot n)$，空间复杂度$O(n)$。
- 搜索法：维护一个括号栈，在左括号大于右括号时允许添加右括号，左括号少于`n`时允许添加左括号。时间复杂度$O(\dfrac{C_{2n}^{n}}{n+1})\sim O\left(\dfrac{4^n}{n\sqrt{n}}\right)$，空间复杂度$O(n)$。
- 按长度搜索法：将括号串分解为`(a)b`的形式，其中`a,b`都是合法括号串，这样便将问题分解为规模为`i`和`n-i-1`的子问题。

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        return sol3(n);
    }
    vector<string> sol1(int n){
        vector<string> ret;
        for(int bm=0;bm<(1<<(2*n));++bm){
            //string check
            int valid=1,bal=0;
            for(int bi=2*n-1;bi>=0;bi--){
                if(bm&(1<<bi)) bal++; // 1:(
                else bal--; // 0:)
                if(bal<0) {valid=0;break;}
            }
            if(valid&(bal==0)) {
                string s;
                for(int bi=2*n-1;bi>=0;--bi) 
                    if(bm&(1<<bi)) s.push_back('(');
                    else s.push_back(')');
                ret.emplace_back(s);
            }
        }
        return ret;
    }
    vector<string> sol2(int n){
        vector<string> ret;
        string s;
        sol2_trav(ret,s,0,0,n);
        return ret;
    }
    void sol2_trav(vector<string>& ret,string& s,int lp,int rp,int n){
        if(lp==n&&rp==n){
            ret.emplace_back(s);
            return;
        }
        if(lp>rp){
            s.push_back(')');
            sol2_trav(ret,s,lp,rp+1,n);
            s.pop_back();
        }
        if(lp<n){
            s.push_back('(');
            sol2_trav(ret,s,lp+1,rp,n);
            s.pop_back();
        }
    }
    vector<string> sol3(int N){
        vector<vector<string>> ans;
        ans.emplace_back(vector<string>({""})); //ans[0]=[]
        ans.emplace_back(vector<string>({"()"})); // ans[1]=["()"]
        for(int n=2;n<=N;++n){
            ans.emplace_back(vector<string>());
            for(int i=0;i<=n-1;++i){
                for(auto& A:ans[i]){
                    for(auto& B:ans[n-i-1]){
                        ans[n].emplace_back('('+A+')'+B);
                    }
                }
            }
        }
        return ans[N];
    }
};
```

## 42-接雨水

作为ACM选手不会接雨水，惭愧。

`h[i]`表示路面高度，问最大总积水多少。

每个位置的最大积水高度由两个量决定：设左侧的最大高度$A$和右侧的最大高度$B$，则最大积水高度：
$$
w_i=\max(\min(A_i,B_i)-h_i,0)
$$
- 如果两侧有任意一侧完全低于当前位置，则积水量为0。
- 如果两侧均高于当前位置，则由最大高度较低的一侧决定。

维护$A_i,B_i$可借助单调栈实现。

AC代码：

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n=height.size();
        vector<int> stk,lmax(n),rmax(n);
        //calc lmax
        if(1){
            for(int i=0;i<n;++i){
                while(stk.size()&&stk.back()<height[i]) stk.pop_back();
                if(stk.size()) lmax[i]=stk[0];
                stk.emplace_back(height[i]);
            }
        }
        stk.clear();
        //calc rmax
        if(1){
            for(int i=n-1;i>=0;--i){
                while(stk.size()&&stk.back()<height[i]) stk.pop_back();
                if(stk.size()) rmax[i]=stk[0];
                stk.emplace_back(height[i]);
            }
        }
        //calc res
        int res=0;
        for(int i=0;i<n;++i){
            res+=max(min(lmax[i],rmax[i])-height[i],0);
        }
        return res;
    }
};
```

## 198-打家劫舍

给你一个正整数数组`a[i]`，可以选取其中的部分元素，要求选取的元素不能相邻。求选取元素的最大可能总和。

*思路*：
对于$a[k]$，选择：
- 选取$a[k]$，那么不能选$a[k-1]$，从$a[0\ldots k-2]$选取尽可能大的和。
- 不选$a[k]$，那么从$a[0\ldots k-1]$选取尽可能大的和。

状态转移方程：
$$
dp[k]=\max(a[k]+dp[k-2],dp[k-1])
$$
可应用状态压缩。最终实现：

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n=nums.size();
        if(n==1) return nums[0];
        if(n==2) return max(nums[0],nums[1]);
        int fir=nums[0],sec=max(nums[0],nums[1]);
        for(int i=2;i<n;++i){
            int tmp=sec;
            sec=max(fir+nums[i],sec);
            fir=tmp;
        }
        return sec;
    }
};
```

## 740-删除并获得点数

给你一个整数数组 `nums` ，你可以对它进行一些操作。

每次操作中，选择任意一个 `nums[i]` ，删除它并获得 `nums[i]` 的点数。之后，你必须删除 **所有** 等于 `nums[i] - 1` 和 `nums[i] + 1` 的元素。

开始你拥有 `0` 个点数。返回你能通过这些操作获得的最大点数。

**思路**：

总体上是[[#198-打家劫舍]]的变形。因为取任意一个数`x`都会删除`x-1,x+1`，所以每个`nums[i]`值域内部的值，都对应那道题的一个数组元素（元素值为`num[i]`乘以出现次数）。

首先需要将`nums`进行计数排序，将其转化为奖励值的数组，随后跑一遍那道题的DP即可。