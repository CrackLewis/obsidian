
## 84-柱状图最大矩形

给定$1\le n\le 10^5$个非负整数，用来表示柱状图中各个柱子的高度。每个柱子相邻，宽度为1。

求柱状图内的最大矩形。

示例：$a=[2,1,5,6,2,3]$，最大面积为10：

![](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

*思路*：

暴力做法为$O(n^2)$，肯定超时。

考虑对每个位置计算其*两侧最近的小于当前位置值的数组坐标*：
- 左侧符合条件的坐标：$lp=[-1,-1,1,2,1,4]$。
- 右侧符合条件的坐标：$rp=[1,6,4,4,6,6]$。

对每个位置$x$，其当前高度对应的最大矩形大小为：
$$
S[x]=a[x]\cdot (rp[x]-lp[x]-1)
$$
因此：$S=[2,6,10,6,8,3]$，故最大面积是10。

求$lp,rp$可依赖*单调栈*：
- 求$lp$：从左到右扫一遍，维护一个递增栈。每个元素位置$x$的$lp[x]$为插入时的栈顶位置$y$
- 求$rp$：
	- 普通做法：从右到左扫一遍，维护一个递增栈。每个元素位置$x$的$rp[x]$为插入时的栈顶位置$y$
	- *常数优化*：每个被弹出元素$y$的$rp$恰好是当前元素$x$，即$rp[y]=x$。

[85-最大矩形](https://leetcode.cn/problems/maximal-rectangle/description/)是本题的改编题。

AC代码：

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n=heights.size();
        vector<int> stk;
        vector<int> left(n),right(n,n);
        // 为啥right要初始化为全n，因为right不会全体赋值
        for(int i=0;i<n;++i){
            while(stk.size()&&heights[stk.back()]>=heights[i]){
	            right[stk.back()]=i;
	            stk.pop_back();
            } 
            left[i]=stk.size()?stk.back():-1;
            stk.push_back(i);
        }
        long long ans=0;
        for(int i=0;i<n;++i) ans=max(ans,1ll*heights[i]*(right[i]-left[i]-1));
        return ans;
    }
};
```

## 321-拼接最大数

给定两个大数$a_i$（$1\le i\le n\le 500$）和$b_j$（$1\le j\le m\le 500$）。指定$k>0$，要求从$a,b$中共选取$1\le k\le m+n$位组成一个新的大数，要求：
- 组成的大数尽可能大。
- 新数中原数各数位的相对顺序不可改变。

*思路*：
注意到如果从两个大数同时选数位，状态数将十分巨大（$O(nmk)$）。考虑转化为分别从两个大数中选取$i$位和$(k-i)$位，再将它们组合。

接下来的任务是枚举$i$。$i$需要满足：
$$
\max(0,k-m)\le i\le \min(k,n)
$$
在长为$p$的大数$c$中选取最大的$q$位的过程，记作$\text{select}(c,p,q)$：
- 设可丢弃的剩余位数$r=p-q$，设一个单调栈记录选取的位数
- 遍历大数，对每一位：
	- 如果栈顶数位比当前小且余位$r>0$，则弹出栈顶且$r$减一，直到栈空、栈顶不小于当前位、或$r=0$
	- 如果栈内数位不足$q$个，则入栈，否则丢弃且$r$减一

对每个合法的$i$，分别运行一次$\text{select}(a,n,i)$和$\text{select}(b,m,k-i)$，从其中选出总计$k$位，再将它们合并为新的大数。合并过程如下：
- 对每个代填位置，比较$a,b$剩余部分的大小，取

合并后的大数将作为一个备择答案，而最终答案是所有备择答案中的最大者。

时间复杂度：$O(k(n+m)+k^3)$

C++实现：

```cpp
class Solution {
public:
    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
        int n=nums1.size(),m=nums2.size();
        vector<int> res(k,0);
        int is=max(0,k-m),it=min(k,n);
        for(int i=is;i<=it;++i){
            auto&& s1=select(nums1,i);
            auto&& s2=select(nums2,k-i);
            auto&& curmax=merge(s1,s2);
            if(compare(curmax,0,res,0)>0) res=curmax;
        }
        return res;
    }
private:
    vector<int> select(vector<int>& a,int p){
        int n=a.size(),top=-1,rem=n-p;
        vector<int> stk(p,0);
        for(int i=0,num;i<n;++i){
            num=a[i];
            //pop lower digits as top and rem allow
            while(top>=0&&stk[top]<num&&rem>0) top--,rem--;
            //push or discard
            if(top<p-1) stk[++top]=num;
            else rem--;
        }
        return stk;
    }
    vector<int> merge(vector<int>& a,vector<int>& b){
        int n=a.size(),m=b.size();
        int tot=n+m;
        vector<int> res(tot);
        int p1=0,p2=0;

        if(n==0) return b;
        if(m==0) return a;
        for(int i=0;i<tot;++i){
            res[i]=compare(a,p1,b,p2)>0?a[p1++]:b[p2++];
        }
        return res;
    }
    int compare(vector<int>& a,int p1,vector<int>& b,int p2){
        int n=a.size(),m=b.size(),diff;
        while(p1<n&&p2<m){
            diff=a[p1]-b[p2];
            if(diff) return diff;
            p1++,p2++;
        }
        return (n-p1)-(m-p2);
    }
};
```

## 330-按要求补齐数组

给定一个*非递减*数组$a_i$（$1\le i\le m\le 10^4,1\le a_i\le 10^4$）和整数$n$（$1\le n\le 2^{31}-1$）。求最少需要向$a$中多补充多少个数，才能使$a$“*覆盖*“$[1,n]$内所有整数。

$a$“覆盖”$x$是指：从$a$中选取若干个数字，总和恰等于$x$。

*思路*：

假设对所有的$1\le i\le k-1$，$a_i$能够覆盖$[1,x-1]$。

假设$a_k\le x$，则对所有的$1\le i\le k$，$a_i$能够覆盖$[1,x-1+a_k]$。

但如果$a_k>x$，则$x$无法被覆盖，此时需要补充一个数，使$a_i$与这个数能够覆盖到$x$。注意到这个数恰好取$x$时，覆盖区间扩大得最大，可扩大到$[1,2x-1]$。

因此计算出补充数字的流程如下：
- 设$x=1$，表示希望覆盖到的区间右端点；$t=0$，表示补充的数个数。
- 遍历每个$a_i$，直到序列结束或$x>n$：
	- 若$a_i\le x$，则$x\leftarrow x+a_i$。
	- 否则：需要补充一个数，$x\leftarrow 2x$，$t\leftarrow t+1$。
- 遍历完成后，若$x\le n$（覆盖不完整）：
	- 反复执行补充步骤，直至$x>n$：$x\leftarrow 2x$，$t\leftarrow t+1$。

时间复杂度：$O(m+\log n)$。

C++实现：

```cpp
class Solution {
public:
    int minPatches(vector<int>& nums, int n) {
        long long x=1;
        int ans=0,m=nums.size(),idx=0;
        while(x<=n){
            if(idx<m&&nums[idx]<=x) x+=nums[idx++];
            else x<<=1,ans++;
        }
        return ans;
    }
};
```

