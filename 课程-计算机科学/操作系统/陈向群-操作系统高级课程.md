
基本信息：
- 主课+课程实验+xv6源码分析+课堂讨论
- 课程：
	- PKU课程：
	- mooc：
	- GitHub仓库：[repo](https://github.com/wuhao9714/myNachos3.4)
- 参考资料：[OSTEP](https://pages.cs.wisc.edu/~remzi/OSTEP/)、《现代操作系统》、《》
- 课程评定：60平时（35课程实验+10源码阅读+15课堂互动）+40考试=100

xv6：
- src: MIT
- 支持对称多处理器（SMP）和RISC-V架构

读代码：
- kernel/entry.S, kernel/start.c, kernel/memlayout.h, kernel/main.c
- kernel/trap.c, kernel/trampoline.S, kernel/syscall.h, kernel/syscall.c, kernel/kernelvec.S, kernel/console.c, kernel/uart.c

lab:
- lab评测平台已导入各位同学的账号，请访问course.educg.net登录，账号为pku+你的学号，例如pku2400011223，初始密码为pku123456。
- 其他有关平台提交lab的使用方式和注意事项请参考本文档：[文档](https://oyer359xyx.feishu.cn/docx/HUOldvsKvojKq4xFGGPc8n42nPc)
- 简单写了下本课程使用的lab的环境配置等问题的指导，9月27日课程上也会讲解lab环境配置和提交方式。有时间精力的同学可以参照本文档开始在本地做lab了：[文档](https://oyer359xyx.feishu.cn/docx/SGDNdxCkuoMSV6xUgX5cPJCTnMe)

这个RISC-V中断机制讲的不错：[lnk](https://gitee.com/hustos/pke-doc/blob/master/chapter1_riscv.md#14-%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86)

## OS实验

不知为何，默认SBI可以启动，但rustsbi启动不了：

```sh
make run SBIPATH=default # OK
make run SBI=sbi-qemu-2 # fail
```

UPD: 实锤是辣鸡clab主机的锅，换Docker就好了（

基于QEMU和GDB的调试：
- 首先在QEMUOPTS中加`-s`，表示在默认端口1234上调试（自定义端口`-s tcp::<port>`）
- 启动`gdb-multiarch`或交叉编辑器的`gdb`，目标程序为内核
- GDB内执行`target remote:<port>`，如为默认端口则port为1234
- 设置必要的断点，如`b consoleread`等

## sec02-中断异常机制

ECF=异常控制流

outline：
- 运行环境：
	- 处理器和寄存器
	- 中断机制
	- 存储系统
	- I/O系统
	- 时钟
- 运行机制：系统调用
- 重要设计思想：机制与策略

questions：
- ICS对异常的描述及分类
- 怎样理解“OS是由中断/异常/事件驱动的”这句话
- 中断异常的来源有什么不同？处理方式是一样的吗
- 中断异常机制中，哪些是硬件（体系结构）负责的？哪些是软件（操作系统）负责的？
- 从中断响应（硬件）到中断处理程序（软件）执行结束，计算机系统经过了哪些流程
- 操作系统 初始化与中断 异常有哪些关联
- 怎样理解应用程序是如何与操作系统交互的
- 什么是软件异常？它是如何工作的
- X86 有哪些寄存器？寄存器的作用是什么？
- X86在PentiumII 300之后提供了sysenter、sysexit指令，为什么？与int 0x80/ iret 有什么不同
- 关于基于x86的Linux系统调用实现：
	- 系统调用入口程序 system_call 与中断描述符表是什么关系？与系统调用表是什么关系
	- 系统调用处理结束后，处理器转去执行哪个模块
- 系统调用与C函数调用的区别？系统调用与API的关系？

*操作系统运行环境*：
- CPU：运算器、控制器
- 寄存器：
	- 用户可见寄存器：数据/地址/条件码寄存器
	- 控制和状态寄存器：PC/IR/PSW等

操作系统的需求之一——保护：OS与用户程序隔离

处理器的状态：程序状态字PSW

x86特权级别：内核=R0>R3=用户

RISC-V特权级别：
- Machine：机器模式，权限最高
- Supervisor：监管模式
- User：用户模式，权限最低

CPU状态转换机制：中断/异常/自陷

（P14）

中断机制作用：
- 及时处理设备请求/用户程序服务请求
- 中断引入：支持CPU/设备并行
- 异常引入：表示CPU执行指令时出现的问题

中断异常概念：CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点继续执行被打断的程序
- 特点：随机发生、自动处理、可恢复
- 事件：
	- 外中断：I/O、时钟、硬件故障
	- 内中断：系统调用、页错误、保护性异常、断点，etc.

中断/异常工作原理：

WIP

## sec05-虚拟内存管理

思考题：

### 1. 交换技术的思想

交换技术（Swapping）是操作系统内存管理的一种方法，它通过将进程或程序的部分或全部从主内存移动到磁盘交换区来释放内存资源。当需要执行某个进程时，操作系统会将进程的部分或全部加载回主内存。交换技术的主要思想是：

- **内存空间的有效利用**：通过将暂时不需要的进程数据交换到磁盘，腾出内存给其他进程，从而支持多任务操作。
- **进程的执行不中断**：虽然进程数据被交换出内存，但操作系统可以控制进程的执行，确保进程在需要时可以被及时调回内存继续执行。
- **磁盘和内存的协作**：磁盘作为辅存，提供了较大的存储空间，虽然存取速度比内存慢，但为操作系统提供了更大的内存管理空间。

### 2. 程序中指令或数据地址绑定的时机

程序中的地址绑定是将程序中的虚拟地址转换为物理地址的过程。地址绑定的时机通常可以分为以下几种：

- **编译时绑定**：在程序编译时，所有的地址都已经确定，并且在程序运行时不会发生变化。适用于静态数据和代码的场景。
- **加载时绑定**：在程序加载到内存时，操作系统为程序分配物理地址空间。操作系统会在程序加载时确定数据和指令的实际物理地址。
- **运行时绑定**：程序在运行过程中，操作系统会动态地为程序分配内存空间，常见于动态加载的库或堆栈等。虚拟地址会被转换为物理地址，通常通过内存管理单元（MMU）来完成。

### 3. 虚拟页式管理机制总结

虚拟页式管理机制是一种通过将虚拟地址空间划分为固定大小的页进行管理的技术。关键的概念包括：

- **MMU（内存管理单元）**：硬件组件，负责虚拟地址到物理地址的转换，并进行访问控制。MMU根据页表（Page Table）来完成地址映射。
- **TLB（快表）**：高速缓存，用于存储最近使用的页表项。TLB加速了地址转换过程，减少了内存访问的延迟。
- **页面错误异常（Page Fault）**：当程序访问一个尚未加载到内存中的页面时，MMU会触发页面错误异常。操作系统会处理这一异常，将缺失的页面从磁盘加载到内存。
- **页表**：存储虚拟地址和物理地址映射关系的数据结构。常见的页表类型有：
    - **多级页表**：为了解决单级页表的空间浪费问题，虚拟地址被分成多个部分，采用多级结构。这样可以有效减少内存的占用。
    - **反转页表**：与传统页表不同，反转页表只记录物理页帧和对应的虚拟页面，因此可以节省内存空间，尤其适用于大虚拟地址空间的系统。
- **页表项（PTE）**：页表中的每一项，包含虚拟页面到物理页框的映射信息，可能还包括访问权限等控制信息。
- **地址保护**：通过页表项中的标志位（如读/写权限、用户/内核模式）来保护内存地址，防止非法访问。
- **放置策略（Placement Policy）**：指如何选择物理内存中的空闲页框来放置虚拟页。常见策略有首次适应、最佳适应等。
- **清除策略（Clearing Policy）**：指如何管理被换出的页面，确保不会有无用数据留在内存中。清除策略通常与内存管理和页面交换算法有关。
- **置换策略（Replacement Policy）**：当内存满了时，操作系统需要选择一个页面来替换。常见的置换策略有最近最少使用（LRU）、先进先出（FIFO）等。
- **预取策略（Prefetching Policy）**：通过预测未来可能使用的页面并提前加载来提高性能。
- **驻留集（Residency Set）**：当前驻留在内存中的页面集合，驻留集的大小与操作系统的页面调度策略有关。
- **工作集（Working Set）**：指程序在一定时间内活跃使用的页面集合。合理的工作集管理可以提高程序的执行效率和系统的整体性能。

### 4. 反转页表与普通页表空间对比

- **普通页表**：对于每一个虚拟页，需要一个页表项来存储其对应的物理地址。假设虚拟地址空间为 2482^{48}248，页面大小为 4KB，则虚拟页数为： 248212=236页\frac{2^{48}}{2^{12}} = 2^{36} \text{页}212248​=236页 每个页表项的大小通常为 8 字节（64 位），因此页表占用的空间为： 236×8字节=239字节=512GB2^{36} \times 8 \text{字节} = 2^{39} \text{字节} = 512 \text{GB}236×8字节=239字节=512GB
- **反转页表**：反转页表为每个物理页帧记录一个映射，而非每个虚拟页。假设物理内存为 4GB，页面大小为 4KB，则物理页帧数为： 4GB4KB=220页帧\frac{4 \text{GB}}{4 \text{KB}} = 2^{20} \text{页帧}4KB4GB​=220页帧 反转页表需要为每个物理页帧存储一个映射项，每个映射项的大小通常为 8 字节，因此反转页表占用的空间为： 220×8字节=8MB2^{20} \times 8 \text{字节} = 8 \text{MB}220×8字节=8MB 相比之下，反转页表节省了 512GB - 8MB = 511.992GB 的空间。

### 5. Windows 自映射机制的实现原理

Windows 的自映射机制主要用于内核模块和用户空间程序之间的内存映射，它允许操作系统将内存映射到进程的地址空间。这一机制在操作系统加载和运行时非常重要：

- **内存映射文件**：Windows 操作系统使用 `MapViewOfFile` 等 API 来将文件映射到进程的虚拟地址空间。
- **自映射机制**：操作系统通过将文件或内存区域直接映射到进程的虚拟地址空间，实现了进程和操作系统内核之间的直接内存访问。这种映射可以使得进程能够直接读写文件或设备，而无需显式地通过 I/O 系统调用。

### 6. Windows 的物理内存管理

Windows 操作系统采用了分层的内存管理模型：

- **虚拟内存管理**：通过 MMU 和页表机制，Windows 可以将虚拟地址映射到物理内存，实现了虚拟内存的空间隔离和保护。
- **分页管理**：Windows 使用分页机制管理物理内存，每个进程都有独立的虚拟地址空间，通过分页机制提供了内存的按需分配。
- **内存池和堆**：Windows 管理着系统和应用程序的内存池，分配和回收内存时使用堆管理技术。
- **内存分页和交换**：当物理内存不足时，Windows 会将不常用的页面换出到磁盘，释放内存空间供其他进程使用。

## 2019秋-考题

一

1. 中断与异常差别，举例说明
2. 以时钟中断为例，说明中断处理过程（包括硬件和OS的处理）
3. 系统调用的设计和实现

二

1. 进程PCB的作用，创建PCB的过程，Linux加快此过程的技术
2. 进程的调度切换与PCB的关联
3. 基于多级反馈调度队列设计一个调度算法。说明你的算法怎么让IO进程优先？怎么防止饥饿？

三

1. 48位虚拟地址空间，一页4KB，设计页表结构，并画出地址转换的流程。
2. 关于页缓冲技术的一道题，里面的图没法回忆了

四

8GB U盘，一簇512B，FAT16格式，文件系统分成了5部分

| ① | ② | ③ | ④ | ⑤ |

1. ①-⑤分别是什么
2. 用什么管理空闲区？如何知道根目录的位置？
3. FAT1占多少簇
4. 给了你一堆创建文件/目录的操作，画文件系统分布，这个课上讲过
5. 现在要读4里面某个文件的第2600字节，说明过程

五

1. 锁，信号量，管程的联系与区别
2. 用管程解决问题。超市100辆推车，进来要先刷卡扣押金来领取推车，如果没车了只能等，离开要刷卡退押金，归还推车。