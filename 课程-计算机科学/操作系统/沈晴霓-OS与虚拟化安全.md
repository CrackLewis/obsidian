
OS安全分级：1-4？

课程简介：
- os
- 虚拟化安全理论技术、方法、应用

内容：
- 预备知识
- 安全概念与标准
- 安全机制
- 安全模型
- 安全体系结构
- 安全开发方法
- os与虚拟化安全实践

网课：[link](https://www.bilibili.com/video/BV18x411U7MW/)

考核方法：30平时成绩+30 project+40考试=100
- 项目：论文报告/技术项目二选一
- 平时：作业+实验

参考书目：
- 黑皮书《操作系统安全设计》
- 《Linux内核安全模块深入剖析》

## sec0-预备知识

### 0.1-os原理概述

宏vs微：
- 微内核：Windows/Minix/MacOS
- 宏内核：Linux/Unix

os特性：并发/共享/异步

os引导过程：上电-BIOS自检-加载引导扇区-加载OS-运行OS

cpu管理：
- 中断
- 调度：进程、线程、调度算法

进程vs线程：
- 上下文切换：线程更快
- 并发性：线程更高
- 系统开销：进程更大
- 地址空间和其他资源：进程间互斥，同进程内线程共享
- 通信：进程通过socket/pipe/ipc/信号等，线程通过进程数据段

cpu调度层次：作业调度>进程调度>内存调度

调度算法目标：资源利用率、公平性、均衡性、策略强制执行

调度算法：SJF、HRRN、FIFO、时间片轮转、优先权（抢占/非抢占）

### 0.2-os设计技术

os层次：
- 用户级：用户程序、程序库
- 内核级：
	- 系统调用接口
	- 文件子系统、进程控制子系统等
	- 存储管理系统、驱动程序等
	- 硬件控制逻辑
- 硬件级

os子系统：
- 文件子系统：外存空间管理、文件存取、数据检索
- 进程控制子系统：同步/互斥、IPC、MM、调度
- 硬件控制：处理中断、与硬件通信

文件内部表示：
- 索引结点表（inode table）
	- 磁盘索引结点
	- 内存索引结点：额外记录锁、文件引用数等信息
- 文件表（file table）：系统全局记录所有打开的文件
- 用户文件描述符表（user fd table）：每进程一个，Linux中为`file_struct`和`fs_struct`

建议看P15/38的图

虚拟文件系统VFS：
- 统筹外存、设备等为虚拟文件
- `struct file_operations`

进程结构：
- 数据结构：PID、状态、调度信息、IPC信息、链接信息、时间相关、文件系统信息、上下文信息
- 进程树：0生1、1生万物
- 上下文：用户上下文（程序+数据+堆栈）、寄存器上下文、系统级上下文
- u区：内核操纵的进程数据区
- 系统段表、进程段表：地址映射，便于对段共享

进程间通信（IPC）：
- 基本机制：PIPE/FIFO/软中断/Sockets
- UNIX V机制：消息队列（`struct msg`）、共享存储区（`struct shm`）、信号量（`struct sem`）
	- 对应的系统调用：P31-33/38

I/O子系统：
- 块设备、字符设备
- 每个设备对应一个文件

### 0.3-虚拟化技术概述

- 数据中心现状/趋势
- 虚拟化定义
- 虚拟化类型
- 服务器虚拟化关键技术
- 主流虚拟化软件/技术实践

数据中心现状/趋势（P3-9/65）：
- 烟囱式结构：使用率低、部署不灵活、管理成本巨大
- 冰山模式：表面（小额新设施建设）+深层（大额人员支出/设施维护）
- IT基础架构发展的*三个阶段*：
	- 整合：降本增效
	- 虚拟化：增加弹性/效率和使用
	- 自动化：支持业务

虚拟化定义（P10-11/65）：
- 表示计算机资源的抽象方法

虚拟化的常见类型（P12-18/65）：
- 常见类型：
	- 基础设施虚拟化：网络虚拟化（VLAN/VPN/SDN）、存储虚拟化（基于存储设备：磁盘阵列；基于网络：NAS/SAN/Hadoop）
	- 系统虚拟化：虚拟机（服务器虚拟化/桌面虚拟化）
	- 软件虚拟化：高级语言虚拟化（JVM）、应用程序虚拟化（App与OS解耦）
- 技术分类：应用程序级/编程语言级/程序库级/OS级/指令级/硬件级

服务器虚拟化关键技术（P19-/65）：
- since 1960'（利用珍贵的计算资源）->80'/90'（暂冷）->now（重新火热）
- 体系结构（P25）
- 虚拟机系统=裸机+VMM层：VMM（虚拟机监控软件）、VM（虚拟机软件）、host OS（宿主机）
- 实现技术分类：
	- 全虚拟化：特权指令拦截机制，开销大
	- 泛虚拟化：修改内核使其支持VM运行在机器级，需要改内核
	- 硬件辅助虚拟化：添加权限更高的根模式，依赖硬件支持
- VMM分类（P30）：
	- 宿主型：VMWare Workstation、KVM
	- 独立监控型：Xen
- VMM实现技术（P33）：
	- CPU虚拟化：仿真执行特权指令
		- 硬件CPU虚拟化：硬件完成ring切换，如Intel VT-x、AMD-V
	- 内存虚拟化：VMM必须直接控制物理内存
		- 影子页表
	- I/O虚拟化

主流虚拟化软件/技术实践（P43-/65）：
- 主流虚拟化软件：
	- VMWare
	- Xen VMM：完全/半虚拟化
- 硬件虚拟化支持：
	- Intel：VT-x（处理器辅助）、VT-d（直接I/O）、VT-c（网络辅助）、TXT（可信执行）

### 0.4-虚拟化关键技术

- 系统虚拟化主要作用
- CPU虚拟化
- 内存虚拟化
- I/O虚拟化

虚拟化主要作用：隔离、合并、迁移、个性化

CPU虚拟化（P2-15/35）：
- 本质：每个虚拟机使用一或多个vCPU，vCPU使用CPU
- *Xen Credit额度调度算法*：
	- 威胁：拒绝服务攻击、信息泄露
	- 软件解决：客户端降权
- 虚拟化挑战：机内对外不知情、VMM提供接口/保护虚拟机/使虚拟机彼此独立
- 硬件辅助CPU虚拟化：引入新指令和CPU运行模式，使VMM与guest OS在不同模式运行
- Intel VT-x：
	- VMX root模式：拥有全部权限，运行VMM
	- VMX non-root模式：运行guest OS，权限受限
	- VMX指令集
	- 虚拟机控制结构（VMCS）

内存虚拟化（P16-25/35）：
- 三层地址结构：机器地址（真实地址）-物理地址（VMM抽象的伪物理地址）-虚拟地址（guest OS提供程序的地址）
- 页表虚拟化：
	- MMU泛虚拟化：直接将复合映射写入guest OS页表
	- 影子页表：guest OS的页表对应一个影子页表
- 内存虚拟化优化机制：
	- 按需取页与虚拟存储：两种方案
		- VMM层实现内存换页
		- 虚拟机间实现气球驱动（balloon driver），动态调控guest OS可用的物理内存
	- 内存共享（页面写时复制）：共享页面只读，修改前必须复制
	- 内存可写工作集：频繁被修改的内存作为工作集
	- 硬件辅助内存虚拟化：
		- Intel VPIDs（虚拟处理器标识）：在TLB中添加vCPU编号标记不同的CPU地址空间，避免VM切换时TLB大规模失效
		- Intel EPT（扩展页表）：从硬件上进行页表再映射，解决x86只能映射一次页表的缺陷，允许影子页表实现

I/O虚拟化（P26-35/35）：
- 两种方式：
	- 模拟I/O设备：对VM模拟I/O设备行为，兼容强性能差
	- 额外软件接口：对VM提供直通设备接口，性能高兼容差
- Intel VT-d：
	- 解决问题：提供guest OS直接访问硬件的机制，降低物理CPU负载
	- 优势：几乎完全消除了VMM中运行驱动程序的需求
	- 设计：
		- 关键：解决DMA和IRQ中断请求
		- DMA重映射：实现IOMMU用于保护多个DMA区域
		- 中断重映射：通过重新定义MSI（消息终端）解决中断隔离问题，MSI中现在指定DMA区域ID而非物理地址，避免未授权的内存写入

乐。——241029

## sec1-安全概念和标准

### 1.1-os安全的重要性

计算机系统安全性要求=法律法规+人身安全+信息/资产保护

系统面临的威胁：
- 客观：软件漏洞、未授权访问、硬件错误
- 主观：恶意用户、人员错误

系统面临的攻击：
- 攻击：恶意代码、拒绝服务
- 窃取：系统渗透、网络嗅探、信息泄露
- 其他：中间人、社会工程

安全性的两个方面：
- 计算机安全
- 通信安全（网络安全）

系统安全问题多来自于os的安全脆弱性。

安全性原则：
- 安全性必须逐层建立
- 每一层的安全性都必须建立在底层可信的前提上
- 安全应用不应建立在不可信层上

安全系统的定义：自可信状态出发，不会停留于不可信状态

安全VS可信：
- 安全是绝对、二元的概念，是系统的目标
- 可信是相对、分级的评估结果，是系统的特点

### 1.2-国内外技术现状

- 60s：美国开始os安全的研究
- 70s：军方和gov开始使用安全系统
- 80-90s：TCSEC标准，B1、B2、B3、A1级
- 2001-now：EAL4/EAL5评估级别产品

国外知名项目：

| 名称                    | 时间/开发者                  | 特点                              |
| --------------------- | ----------------------- | ------------------------------- |
| Multics               | 1965，Bell Lab & MIT MAC | 并发访问信息存储系统时的高安全性                |
| Adept-50              | 1969，美国军方               | 第一个实用分时安全系统，以高水印模型为基础，提供形式化解决方案 |
| J. P. Anderson Report | 1972, J. P. Anderson    | 提出引用监控、引用验证、安全内核和安全建模思想         |
| PSOS                  | 1973-80                 | 层次化、基于权能的安全os，分解系统的安全性论证问题      |
| KSOS                  | 1977，Ford               | 高安全可信性                          |
| LOCK                  | 1987-92，美国国家安全计算中心      | 达到或超过TCSEC A1级安全的系统             |
| XENIX                 | 1986-94，IBM/TIS         | TCSEC B2-A1级的安全操作系统             |
| TMach/DTMach          | 1987-93，TIS             | B3级系统，基于Mach和LOCK               |
| DTOS                  | 1997                    | 安全微内核                           |
| TUNIS                 | 1989                    | 实现BLP模型，重写UNIX                  |
| ASOS                  | 1990，TRW                | 基于访问控制列表、BLP模型、Biba模型的安全机制      |
| STOP                  | 1985，Honeywall          | A1级系统，安全仲裁机制                    |
| SELinux               | 2001，美国NSA              | 基于Flask体系结构的强制访问控制策略            |

### 1.3-国内外相关标准

标准：
- TCSEC：Trusted Computer System Evaluation Criteria
- ITSEC：Information Technology Security Evaluation Criteria
- FC
- CC
- etc.

彩虹系列丛书：
- [link](www.chinacissp.com/knowledge/Rainbow/rainbow_series.htm)
- [link2](www.governmentsecurity.org/articles/RainbowSeriesLibraryTheOneTheOnly.php)

*TCSEC等级*：

![[Pasted image 20241105190604.png]]

TCSEC评估的产品：P7/46

ITSEC标准：
- since 1990，1991发布1.2版本
- 首次提出保密性、完整性、可用性和ST（安全目标）的改变
- 安全性分为：
	- 功能要求：为满足安全需求采取的技术措施，如访问控制、审计、鉴别等
	- 保证要求：确保功能有效实现的安全措施，如渗透测试、安全脆弱性分析等
- 安全功能等级（F1-F10）、安全保证等级（E0-E6）
- 定义产品/系统的评估目标（TOE，target of evaluation），并声明：
	- 安全策略/原则、功能/规范
	- 安全机制的定义/强度
	- 功能和有效性的目标评估等级
- 评估者需要判定：
	- 功能的适当性/有效性、易用性
	- 机制强度和脆弱性

CC（Common Criteria）标准：
- 1991（指定）-1996（v1.0）-1997（v2.0）-1999（ISO/IEC 15408）
- 三种角色：消费者、开发者、评估者
- 三个方面考量：一般模型、安全功能要求、安全保证要求
- 关键概念：![[Pasted image 20241105195137.png]]
	- 评估对象（TOE）：受评估的主体
	- 保护轮廓（PP）：与实现无关的安全要求
	- 安全目标（ST）：作为既定TOE评估基础使用的一组安全要求/规范
	- TOE安全策略（TSP）：TOE种管理资产的一组规则
	- TOE安全功能（TSF）：正确执行TOE所必需的所有部件集合
	- 见P21/56
	- 用户方-Profile Prot.-ST-设计文档-TOE-开发者
- 核心内容：
	- 简介及一般模型（P23-26）
	- 安全功能要求（P27-28）
	- 安全保证要求（P29-39）

CC/TCSEC/ITSEC对比：
- CC级别：EAL0-EAL7
- ITSEC级别：E0-E6
- TCSEC级别：D/C1/C2/B1/B2/B3/A1

我国标准：P43

### 1.4-安全概念和设计思想

安全概念：
- 引用监控器
- 安全内核及其设计原则
- 可信计算基
- 系统边界和安全周界
- 可信软件与不可信软件

设计思想：
- 主体、客体、访问控制矩阵
- 安全策略与安全建模
- 安全功能与安全保证
- 安全体系结构

访问控制思想：
- 主体+客体+访问控制矩阵

*主体*（subjects）：引起信息在客体之间流动的实体，如人、进程、设备等。

*客体*（objects）：一个被动实体，如数据文件等

访问控制：
- 定义：存在于系统中的，授予或撤销用户访问、修改某些数据权限的机制
- 分类：文件权限、执行权限、数据库权限

访问控制矩阵（access control matrix）：不同用户访问不同资源的权限表

*通用安全需求*：（P6/44）
- 机密性：加密、访问控制
- 完整性：访问控制
- 可追究性：标识、鉴别、审计
- 可用性

*安全三要素*（P7）：
- 安全策略（P8）：做什么
- 安全机制（P30）：怎么做
- 安全保证（P40）：效果如何

*安全策略*（P8）：
- 定义：一种将系统状态划分为安全和不安全状态集合的方法
- 类型：
	- 机密性策略：防止未授权访问
	- 完整性策略：防止未授权修改

*策略语言*（P11）：
- 定义：描述安全策略的语言
- 分类：
	- 高级策略语言：描述每个域的详细权限规则
	- 低级策略语言：简单/二元权限规则

*安全建模思想*（P14）：
- 不安全性：安全控制漏洞+安全定义缺陷

*安全模型*（sec' policy model，P15）：
- 定义：系统执行的安全策略的清晰表述
- 特点：精确无歧义、简单抽象、只涉及安全性质
- 作用：
	- 明确安全性定义，指导os设计和实现
	- 为安全测试提供上下文，提供论证保障

安全模型实例*HRU Model*（P17）

*安全机制*（P30）：实现安全策略的手段
- 分类：预防（最常用）、检测、恢复
- *引用监控器*：对主体对客体访问行为进行监控的机制
	- *引用验证机制*（RVM）：
		- 安全内核方法（P34）
		- 三个设计原则：完整性、隔离性、可验证性
- 系统边界与安全周界
- 可信计算基
- 可信软件与不可信软件

*安全功能、安全保证*（P40）：
- 安全功能（提供什么保护功能？）、安全保证（保护功能多强？）
- 信任：任何安全策略/机制都基于某种假设/信任
- 安全体系结构：描述系统达到安全要求必需的组织方式。

### 1.5-TCG可信计算技术

#### 引言

可信计算概念和需求：
- 安全vs可信（P4）
- 层次由高到低：进不去-拿不到-看不懂-改不了-瘫不成-赖不掉
- *可信*：针对某个特定目的，实体的行为与预期行为相符
- 可信计算环境需求（P6-7）
- *可信计算*（P8）：
	- 四个方面：用户身份认证、平台软硬件配置正确、应用程序完整合法、平台间可验证
	- 三个属性：可鉴别、完整性、私密性
- 可信计算的机遇：基于标准化、受到更多信任、扩展信任到其他平台

#### TCG组织介绍

*TCG*（可信计算组织，trusted computing group）：
- since 1999，HP, IBM, Intel, Microsoft, etc.
- 目的：在计算和通信系统中广泛使用基于硬件安全模块支持下的可信计算平台，提高整体安全性
- 使命：发展并推动开放的、厂商中立的、多平台间可信计算构造单元及软件接口的业界标准规范

TCG解决方案：
- 解决方案：TPM，详见P15
- 当前应用：带TPM的PC、Server、IoT设备、第三方软件等

*工作组*：具有不同职能的TPM分组（P18-19）

#### TCG现有标准规范介绍

*TCG规范设计原则*：（P22）
- 安全性、私密性、可互操作性、数据可移植性、可控性、易用性原则

TCG文档路线图（P23）

TCG现有规范（P24-26）：
- TCG体系结构规范：TCG技术的体系结构、产品评估模型、生产要求
- TPM主规范：TPM基本概念、功能相关信息+4部分
- TSS规范：TCG软件栈的分层结构、关键数据结构
- PC客户平台规范
- 服务器规范
- 移动电话使用场景规范
- 基础设施规范
- 可信网络连接规范

#### TPM核心功能介绍

TPM=trusted platform module

*TPM简介*（P29）：TCG技术的核心内容就是为计算平台提供了一整套基于TPM及平台中TBB（平台可信构造块）的信任建立及可信性证实方法和机制
- CRTM（*可信度量根*）：boot ROM内的一个受保护部件，对后续指令进行完整性度量
- 可信平台模块TPM：
	- 是拥有受保护的独立执行/存储能力的芯片，是可信平台核心
	- 包括RTR（可信报告根）和RTS（可信存储根）
	- *四个主要功能*：对称/非对称加密、安全存储、完整性度量、签名认证

TPM体系结构（P32）：
- 受保护的功能：一组命令，只有它们可访问被屏蔽的位置
- 被隔离的位置：内存、寄存器等，能够安全操作敏感数据

安全度量和报告（P37-44）：
- *平台配置寄存器*（platform configuration register, *PCR*）：一个20B的屏蔽存储器，用于存储离散的完整性度量值
	- 操作：重置（reset）、扩展（extend）
	- 与PCR构造相关的密码哈希性质：顺序性、单向性
- 完整性度量、存储、报告（P39）：
	- 目的：允许平台进入任何状态，但这些状态均被如实记录
	- 度量：获得与平台完整性相关的平台特性的度量值的方法
	- 存储：由TPM内的PCR及TPM外的SML（Stored Measurement Log）共同完成
	- 报告：对完整性存储的内容进行证实的过程
- 信任链产生（P40）：
	- 信任链以可信度量根（TPM）为起点建立，再将信任关系逐级传递到各系统模块，从而建立整个系统的信任关系
	- *三个可信根*：可信报告根（RTR）、可信存储根（RTS）、可信度量根（RTM）
- Linux IMA度量机制（P42-43）：
- *完整性报告*（P44）：
	- 本地报告：借助TPM提供的Seal操作完成
	- 远程报告：可信平台使用AIK对当前平台PCR值进行签名，报告给远程挑战者，证明平台可信性。使用挑战-应答协议完成。

*远程证实*（P45-50）：
- 远程证实协议：平台A向平台B发起挑战，要求获得平台B的若干PCR值以验证平台B的可信度
- 背书密钥（endorsement key, *EK*）：每个TPM的背书密钥唯一
- 身份认证密钥（attestation identity keys, *AIKs*）：
	- 由TPM生成，用作EK的别名之一参与认证（EK不直接参与认证）
	- PrivacyCA方法（P47）：根据AIK值签发AIK证书，用于分发给挑战者
		- 一次一密方式：TPM每次认证产生的AIK不同，其他平台无法验证是同一平台的行为
	- DAA方法（direct anonymous attestation，P49）：
		- 参与方：TPM平台、DAA签署方、DAA验证方
		- 两个步骤：Join（签署方验证TPM平台并签署证书）、Sign/Verify（TPM平台使用DAA证书与验证方进行交互，在不违反TPM隐私性的前提下验证DAA证书）
		- 优点：避免了签署方与验证方合谋的风险；生成多个证书只需要一次交互

*数据保护*（P51-54）：通过密钥保护数据
- 受保护的存储结构：*存储根密钥*（storage root key，SRK）
	- 每个可信计算平台只对应一个SRK，存储在TPM中
	- TPM所有者获得TPM所有权后，在TPM中生成SRK，再以SRK为根建立受保护的树状存储结构
- 绑定/包装（binding/wrapping）：用户创建的密钥被TPM加密并存储在TPM外，必要时由TPM解绑/解包装
- 封装（seal）：TPM可以将密钥和平台状态的某些度量值关联起来，如安装了什么软件等，平台状态一致才能解密

*密钥管理*（P55-60）：
- 秘密的类型：
	- 数据、对称密钥：不会被解析的秘密
	- 存储密钥：用于加密的非对称密钥，可保护数据和其他密钥
	- 签名密钥：用于签名的非对称密钥，不可保护其他内容
	- 特殊的签名密钥AIK：作为SRK的直接叶子结点
- 密钥是否可迁移：
	- 不可迁移密钥：由TPM完全控制的密钥，其父密钥也是不可迁移密钥
	- 可迁移不可鉴定密钥：在TPM外生成，受TPM保护
	- 可迁移可鉴定密钥：在TPM内或外部生成，由任意密钥进行了加密
- 密钥的使用：
	- 使用秘密时：在平台满足PCR环境前提下，从SRK开始逐级解密
	- TPM密钥迁移/维护：
		- 迁移：以可信方式迁移可迁移密钥到其他可信平台
		- 维护：允许特权实体对受保护存储结构进行备份/迁移

#### 可信计算软件栈

可信平台软件架构（P62）

软件栈接口（P63）：
- 服务提供者接口
- 核心软件接口：上下文、证书/密钥、度量时间、参数块生成
- TPM设备驱动接口：

使用场景（P64）

## sec2-安全机制

### 2.1-硬件安全机制

*绪论部分*：

os安全性表现：（P2）
- 物理上分离、空间上分离、逻辑上分离、密码上分离

os安全的主要目标：（P3）
- 用户访问控制、身份鉴别、运行时安全、系统安全完整性

必要的安全机制：（P4）
- 硬件安全机制、访问控制机制、可追究机制、连续保护机制

*正文*：

为什么需要硬件安全性：（P6）
- 硬件安全需要更可靠、硬件安全特性更简洁、硬件允许的工作性能高于软件

硬件安全目标：（P7）
- 保证自身的可靠性、同时为系统提供基本安全机制，包括存储保护、运行保护、I/O保护

*存储保护*：

存储保护目标：（P9）
- 单用户系统中：防止用户影响OS；多道程序系统中：进程存储空间相互隔离

存储器管理机制：（P10-13）
- 虚地址空间
- 请求式调页
- 分段虚拟存储

存储器管理的访问控制：（P14）
- 禁止非特权进程写特权段
- 具体手段：
	- 物理页附加密钥（P15）：为进程附加密钥，物理页与密钥值绑定，密钥值匹配方可访问
	- 基于描述符的地址解释（P16）：每个进程一个地址描述符，描述对内存某页/段的访问模式

*运行保护*：

86系列执行模式（P18）

UNIX/Linux系统层次结构：（P19）
- 用户：各个用户进程
- 核心：Linux内核，与用户层以系统调用为界面
- 硬件

基于保护环的等级域机制：（P20）
- 执行域：分层结构，涉及执行方式、状态、范围
- 保护环：R0内核\>...\>R3用户
- 安全概念：R0权限最高，向外依次递减

进程隔离机制：（P21）
- 进程必在某个环内运行，与同一环的其它进程隔离

多域结构的保护机制：（P22）：
- 依据：保护环的权限传递机制
- 硬件保护机制：对每种访问模式（R/W/X）指定可访问的最大环号（如：R6或更高）
- 环界（ring bracket）：一个递增三元组`(R1,R2,R3)`，描述对某个内存段写/读/运行的最低权限（最高环号）
- 环界方法的安全性、局限和解决方案（P24-26）

*I/O保护*：

I/O硬件保护机制：（P30）
- 将I/O划归特权操作
- 将设备看成客体，即安全边界外的对象
- 进行I/O操作的进程必须受到对设备的读/写两种访问控制
- 设备到介质间的路径不必受到约束

*小结*：（P31）
- 操作系统的安全性：物理上的隔离、时间上的隔离、逻辑上的隔离和密码上的隔离
- 操作系统安全的主要目标：数据和资源的访问控制、用户身份的标识和鉴别、审计、以及系统自身的完整性保护等
- 操作系统的必要安全机制：硬件安全机制、访问控制机制、可追究机制、以及连续保护机制
- 硬件安全机制目的：为上层软件提供可靠、简单和高效的安全环境
- 段页式存储管理机制、基于描述符的地址解释机制原理及其保护方法
- 运行保护中的多域结构设计原理及其环界保护方法
- I/O访问控制主要是对处理器和设备之间路径上的读/写访问进行控制

### 2.2-自主访问控制机制

自主访问控制=DAC（discretionary access control）

访问控制机制的任务：（P3）
- 授权：确定可访问客体的主体范围
- 确定（determine）访问权限
- 实施（enforce）访问权限

DAC概念：（P4-5）
- 文件的拥有者可以按照自己的意愿精确指定系统中的其他用户对其文件的访问权
- *DAC定义*：自主访问控制是基于客体所属用户/组身份，以及需知原则来约束对客体的访问的一种手段。这种控制是自主的意义在于：具有特定访问权限的一个主体能够将该权限（直接或间接地）传递给另一个主体。
- “自主”的体现：
	- 用户可以自主地说明他所拥有的资源允许系统中哪些用户以何种权限进行共享
	- 对其他具有授予某种访问权力的用户能够自主地(可能是间接地)将访问权或访问权的某个子集授予另外的用户

*DAC分类*：
- 基于行的访问控制矩阵信息：连接可访问客体到指定用户
- 基于列的访问控制矩阵信息：连接用户列表到指定的客体

![[Pasted image 20241202091252.png]]

*基于行的DAC*：在每个主体上都附加一个该主体可访问的客体的明细表，根据表中信息的不同可分成三种形式：能力表、前缀表和口令。
- 能力表：加密的权限列表，可以向下传递但不可伪造
- 前缀表：受保护客体名及其访问权限列表
- 口令：向OS提供的客体访问凭据

*基于列的DAC*：每个客体上附加一个主体列表，指明主体身份和访问权限。
- UNIX/Linux umask：形如`?rwxr-xr--`，简单但无法控制除拥有者外单用户的权限
- ACL：每个文件一个ACL，存储`<type,id,perm>`三元组，`type`表示主体是用户还是组，`id`表示主体名称，`perm`表示主体访问权限

*讨论*：
- Linux内核主体：uid、euid、suid、fsuid，etc.
- Linux内核客体：文件、目录、特殊文件、设备、各类IPC客体（信号、消息队列、共享内存）
- 块设备与字符设备的区别，相关数据结构
- Linux 2.6 DAC命令：chmod、chown、setfacl、chfacl
- Linux中客体相关的DAC结构：umask、ACL等
- setuid机制

### 2.3-强制访问控制机制

强制访问控制=MAC（mandatory access control）

特洛伊木马威胁：
- 表面上在合法工作，实际上在执行非法操作
- 具有诱使受骗者接受并运行程序的策略
- 具有通过运行使受骗者遭受损失（或使木马设计者获取利益）的手段

为什么DAC无法防止木马：
- DAC允许用户任意修改它拥有的文件，而OS不能区分修改信息的是合法用户还是木马
- 在DAC控制下并没有办法防止木马通过共享客体，把消息从一个进程传给另一个进程
- 尽管OS存在对特定程序修改DAC信息进行控制的能力，但这会影响灵活性

*MAC定义*：一种根据客体敏感性限制主体访问权限，以及授予主体访问特定敏感度客体权限的策略
- 为主体和客体都设置了安全属性，且不能随意变动
- 如果系统判定主体A不能访问客体a，任何其他用户都不能向A提供对a的访问
- 用户进程不能改变自己或其拥有客体的安全属性
- 进程不能随意创建共享文件，外泄敏感信息

多级安全思想：
- 目标：实施强制机密性安全策略，确保信息不会无意泄露
- *安全级*（security label）：
	- 保密级别：unclassified\<confidential\<secret\<top secret
	- 范畴集：安全级涉及的领域
	- 表示形式：`(保密级别: 范畴集)`，如`{top_secret: NUCLEAR, DEFENSE}`
	- 支配：`(L1, S1)`支配`(L2, S2)`，当且仅当`L1>=L2`且`S2`包含于`S1`
	- 支配关系：等于（相互支配）、支配、被支配、无关

多级安全规则与BLP模型：（P14）
- 是符合军事安全策略的、最常用的计算机操作的模型。名称BLP是作者缩写
- *多级安全规则*：高密级不可写低级实体，低密级不可读高级实体![[Drawing 2024-12-02 13.34.56.excalidraw]]
- BLP模型的安全属性：
	- 简单安全属性（Simple Security Property）：当安全级`A`支配`B`且`A`有对`B`的自主访问权限时，`A`可以读取`B`
	- 约束属性（Confinement Property）：当安全级`B`支配`A`且`A`有对`B`的自主访问权限时，`A`可以写入`B`

*安全级的标识及赋值*：
- 安全级数据库（P19）
- 主体的安全级：以用户身份运行的进程的安全级。初始时由管理员指定，登录shell时可指定一个不高于用户最高权限的安全级
- 客体的安全级：缺省取创建进程的安全级。特别地，文件/管道等于父目录安全级，子目录不低于父目录安全级
- 设备的安全级：由系统指定最高和最低安全级
	- 单级设备：某个时刻只能处理单一安全级的数据。如：终端、磁带机、软盘驱动器
	- 多级设备：可以包含多个安全级数据。如：磁盘

MAC规则的实施：设主体安全级为A，客体安全级为B
- 客体为文件/目录时：若读/执行，A必须支配B；若写入，A必须等于B
- 客体为进程时：A必须等于B
- 客体为IPC对象时：A必须等于B

### 2.4-客体重用机制

*客体重用定义*：
- 包含一个或多个客体的存储介质(例如，页面，磁盘扇区，磁带)的主体的重新分配。
- 残留数据：是指数据在被以某种形式擦除后所残留的物理表现。
- 通过标准系统机制，为新的主体重新分配时不应含有任何可用的残留数据。

安全标准对客体重建的要求：（P4）
- TCSEC C2、GB17859 第二级：对客体初始指定、分配或再分配一个主体之前，要求撤消客体所含信息的*所有授权*。当主体获得对一个已被释放的客体的访问权时，当前主体不能获得原主体活动所产生的任何信息。
- CC (EAL 2)、GB/T18336-2001：PP中有FDP类(保护用户数据)，其中子集“9、残留信息保护(FDPRIP)”对应的就是TCSEC和GBl7859中的客体重用机制，用于保护文件和存储器中的残留信息。

残留数据在介质上的体现（P5-7）

### 2.5-标识与鉴别

可追踪机制：
- [[#2.5-标识与鉴别]]
- [[#2.6-可信路径机制]]
- [[#2.7-安全审计机制]]

*标识*：要求系统对用户的身份进行有效标记，且要求代表用户身份的特定名称。
- 用户标识符uid必须唯一，且不能伪造

*鉴别*：将用户标识符与用户联系的过程，用以识别用户的真实身份。
- 总是要求用户提供能证明他身份的特殊信息。

*标识机制*：
- UNIX/Linux：
	- 每个文件客体对应一个属主标识uid和属主组标识gid，保存于inode
	- 主体也具有uid/gid，保存在PCB
	- 客体属主可以chmod，但不能chown
- FreeBSD：文件uid=创建者uid，文件gid=目录gid

*与鉴别有关的认证机制*：
- 在进行任何需要TCB仲裁的操作之前，TCB都应该要求用户标识他们自己。
- TCB必须维护/保护认证数据
- TCB必须维护/保护/显示所有账户的状态信息

口令作为保护机制的要求：（P7-8）
- TCB需要以单向加密方式存储口令，访问需要特权
- TCB需要在输入时隐藏明文口令，且禁止空口令
- TCB应允许用户在认证后自行更换口令
- TCB需要加强口令失效管理（如定期要求替换口令），并在要求替换口令前事先通知
- TCB需要确保口令的复杂性

口令相关技术要点：
- 对口令内部存储的访问控制和加密处理
- 口令从终端到认证机传输过程中的保护
- 登陆尝试次数的限制
- 用户安全属性的检查，比如用户进程的安全级、计算特权集、审计屏蔽码等
- 审计处理，对口令的使用和更改进行审计

口令质量测试：
- 长度测试、相似度测试、回文测试、大小写匹配测试、复杂度测试

### 2.6-可信路径机制

*可信路径*（trusted path）：一种用于保障用户和真实的内核通信的机制。
- 用户需要确定自己是在和内核，而非木马通信

安全标准要求：
- TCSEC B2：可信路径是终端人员能借以直接同可信计算基TCB 通信的一种机制，该机制只能由有关终端人员或可信计算基TCB 启动，不能被不可信软件模仿
- TCSEC B3：连接用户（比如注册、更改主体安全级）时，计算机信息系统TCB 提供它与用户之间的可信通信路径。可信路径上的通信只能由该用户或计算机信息TCB 激活，且在逻辑上与其他路径上的通信相隔离，且能正确地加以区分

*可信路径方法*：（P6-8）
- 方法一：每个用户双终端，一个用作工作，另一个用作连接内核（太昂贵）
- 方法二：使用通用终端，通过发一类特殊信号（称为*安全注意键*SAK）给核心建立可信路径（想要使得该机制不被木马欺骗比较困难）

可信路径实例（P8-10）

### 2.7-安全审计机制

安全审计=security audit

*安全审计*：对系统中安全相关行为进行记录、检查、审核
- 目的：防止非法用户入侵系统，并显示合法用户的误操作
- 意义：从审计追踪中获取详细可靠信息，定位/查询系统事故原因，可为故障预测/事故处理提供证据

审计保证：（P5）为确保审计员的信息真实、有价值，作出正确判断和及时决策，必须满足
- 审计所有必要的事件
- 保证审计追踪过程及信息的完整性：审计与系统其它功能彼此独立，且受系统保护

*审计事件*（audit events）：（P6）系统审计用户操作的最小单位
- 如：系统调用事件、异常事件
- 受审计的事件范围：
	- 主体审计事件：进程代表特定的用户请求系统服务、利用系统资源完成特定的任务，是系统中的活动主体。
	- 客体审计事件：对安全攸关的系统客体（如文件、消息、共享区等）进行的存取活动。

*审计事件标准*：（P8）

![[Pasted image 20241202170327.png]]

- 主体审计策略：
	- 用户事件标准：每个用户自己的待审计事件集
	- 固定事件集：与安全性关联极高，必须审计
- 客体审计策略：

*主体审计事件*：（P9）
- 系统调用事件等
- 包含信息：事件类型、事件成败、进程PID、程序名、用户ruid/rgid/euid/egid、安全级sclass

*事件筛选机制*：（P12）
- 背景：如果不加选择记录，审计记录的规模将不受控，消耗存储空间和系统性能
- 筛选角度：
	- 针对客体审计事件：特定客体筛选、特定客体目录筛选、特定属性客体筛选
	- 针对主体审计事件：特定上下文主题筛选

*审计保护*：（P13）
- 审计系统必须保证：审计系统可以正确记录必要行为，且审计记录不会恶意删除
- 保证措施：审计职责隔离（与管理员分离）、审计数据安全保护（特定策略）

*审计点*（audit point）：（P16）
- 由于系统调用是用户程序和OS的唯一界面，所以在系统调用入口/出口处设置审计点是必要的
- 审计点处调用审计函数并通知审计进程，完成审计信息的缓冲/存储/归档

![[Pasted image 20241202173326.png]]

审计方法：（P18）
- 系统调用入口处：进行审计条件判断，如果需要审计，则设置审计状态并分配内存空间
- 系统调用出口处：收集审计内容，包括操作的类型/参数/结果等

审计必要机制：
- 开启/关闭审计机制
- 增加/减少系统审计事件类型
- 增加/减少用户审计事件类型
- 修改审计控制参数

### 2.8-最小特权管理

连续保护机制：
- [[#2.8-最小特权管理]]
- [[#2.9-隐蔽通道分析与标识]]
- [[#2.10-系统完整性保护]]
- [[#2.11-可信恢复机制]]

*特权*（privilege）：特权高于DAC、MAC，特权可以覆盖DAC、MAC的禁止权限
- 恰当特权（appropriate privilege）：一类进行特定的受限操作或覆盖访问控制权限的能力

*权能*（capability）：用于在具有信息安全的系统上实现适当权限的令牌

*最小特权原则*（principle of least privilege）：所有程序和用户应被授予能够正常运作的最小权限。

basic idea：
- 超级用户特权尽量划分为细粒度的子特权
- 不同的系统操作员/管理员获得超级用户特权的一个最小子集

特权管理的问题：UNIX/Linux的特权过于二元化，粒度不够

权能选择（capability selection）的原则：
- 一个权能应当使得系统对权能授予者免除某些特定的安全要求
- 不同权能的具体效果重叠程度应当最小化
- 满足上面两条的前提下，权能数量应当最小化

例：（P9-10）
- 特权细分：拥有者、setuid权限、读写DAC权限、访问MAC权限、审计权限、网络设置修改权限等
- 定义职责：安全管理员（SSO，可操作DAC/MAC）、审计员（AUDIT，审计）、安全操作员（SOP，setuid）、网络管理员（修改网络设置）

最小特权管理的一种实现：
- 每个可执行程序赋予一个特权集
- 每个进程根据其用户和执行程序，赋予一个特权集
- 进程请求执行特权操作（如mount）时，需调用特权管理机制，判断进程特权集是否可执行特权

*权能状态定义*：
- 可继承集（inheritable set，I）：一个进程可依据条件遗传其后续进程映像的权能
- 许可集（permitted set，P）：当前进程允许生效的最大权能集合
- 有效集（effective set，E）：当前进程中生效的权能集合

主体权能子集间的关系：
- 边界集（bounding set）必须包含于任意权能子集，该集合不可扩充。
- 原则上，P包含于I，P包含于E。

![[Pasted image 20241203101320.png]]

*Linux权能遗传算法*：

![[Pasted image 20241203104213.png]]

*DG/UX权能遗传算法*：

![[Pasted image 20241203104241.png]]

用户初始进程的特权状态：
- 与创建进程的用户属性和shell程序相关：
	- 由于用户通过会话（如：login）成为系统的主体进程，所以要在此过程中根据用户属性(比如:角色)为初始的主体设置恰当的权能状态。
	- 由于可信管理用户登陆后要求安全shell (比如:/bin/bash)支持其执行特权命令，所以应该恰当地指派安全shell程序的权能状态,它将决定初始进程的权能状态。
- 此外,系统第一个进程/sbin/init,以及登陆进程/bin/login对应的权能状态应恰当设置.

### 2.9-隐蔽通道分析与标识

### 2.10-系统完整性保护

### 2.11-可信恢复机制