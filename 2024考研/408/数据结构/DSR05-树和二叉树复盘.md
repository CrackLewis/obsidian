
## 框架

- 树的基本概念
- 二叉树
	- 定义及其主要特征
	- 链式二叉树
	- 二叉树的遍历方法
	- 线索二叉树
- 树和森林
- 树和二叉树的应用：Huffman树、并查集

## 树的基本概念

树的路径长度：从树根到每个结点的路径长度的总和。

树高：从树根到其他结点路径长度的最大值+1。

## 二叉树的基本概念

设度数为0、1、2的结点数为$n_0,n_1,n_2$，其中$n=n_0+n_1+n_2$。

根据度数分析易得：$n=2n_2+n_1+1$。

两式联立得到$n_0=n_2+1$。

## 三种遍历方式的非递归实现

先序遍历的非递归实现：

```cpp
void PreOrderNonInverse(BiTree T) {
	// S内包含所有未遍历右儿子的结点
	InitStack(S);
	BiTree p = T;
	while (p || !IsEmpty(S)) {
		// 一直优先遍历左子树，走到底
		if (p) {
			visit(p);
			Push(S, p);
			p = p->lchild;
		}
		// 走到底了就取出一个父结点，遍历其右子树
		else {
			Pop(S, p);
			p = p->rchild;
		}
	}
}
```

中序遍历的非递归实现：

```cpp
void InOrderNonInverse(BiTree T) {
	InitStack(S);
	BiTree p = T;
	while (p || !IsEmpty(S)) {
		if (p) {
			Push(S, p);
			p = p->lchild;
		}
		else {
			Pop(S, p);
			visit(p);
			p = p->rchild;
		}
	}
}
```

后序遍历的非递归实现：最复杂。

```cpp
void PostOrderNonInverse(BiTree T) {
	InitStack(S);
	BiTree p = T, r = NULL;
	while (p || !IsEmpty(S)) {
		if (p) {
			Push(S, p);
			p = p->lchild;
		}
		else {
			GetTop(S, p);
			// r指向最近遍历完毕的子树树根。
			// 这一步检查p是否有右儿子，右儿子是否需要遍历。
			if (p->rchild && p->rchild != r) {
				p = p->rchild;
			}
			// 如果p为空，则从栈中拿出一个结点访问。
			// 如果p的右儿子完成了遍历，则直接访问自己。
			else {
				Pop(S, p);
				visit(p);
				r = p;
				p = NULL;
			}
		}
	}
}
```

## 线索二叉树

- 线索二叉树是一种物理数据结构。
- 每个结点外引两条线索，其中边数为$n-1$，线索数为$n+1$。
- 在树上找后继结点：
	- 先序线索树：如有左儿子则为左儿子，如无左儿子为右儿子，如无右儿子或右线索则无后继结点。
	- 中序线索树：如有右线索则为右线索，否则为右子树的最左结点。
	- 后续线索树（需要栈）：分三种情形。
		- 若为二叉树的根结点，则无后继。
		- 若为双亲的右孩子，或是双亲的左孩子但双亲无右子树，则其后继为双亲。
		- 若为双亲的左孩子，且双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点。

## 树和森林转化为二叉树

- 设$N$个结点的树或森林$F$有$n$个非叶结点，转化为二叉树$B$。则：
	- 二叉树$B$中没有右儿子的结点数为$n+1$，没有左儿子的结点数为$N-n$。
	- 若二叉树中结点$u$是结点$v$的儿子，则在$F$中它们为父子或相邻兄弟。
	- $F$的后根遍历序列和$B$的中序遍历序列相同。

## 哈夫曼树相关

编码类型：
- 固定长度编码
- 可变长度编码
- 前缀编码：没有一个编码是另一个编码的前缀。