
## KMP

### 计算部分匹配值

子串`S[1...n]`的部分匹配值是满足`S[1...k]==S[n-k+1...n]`且`k<n`的最大值，即前后缀匹配的最大长度。

例如：`ababa`的`PM`为`[0,0,1,2,3]`，`abcac`的`PM`为`[0,0,0,1,0]`。

### 计算next数列

令`next[j+1]=PM[j]+1`，`next[1]=0`。例如`abcac`的`next`数组为`[0,1,1,1,2]`。此时的模式串指针变换公式为`j=next[j]`。这是钦定的next数组取法。

也有令`next2[j+1]=PM[j]`，`next2[1]=-1`的例子。例如`abcac`的`next2`数组为`[-1,0,0,0,1]`。此时的模式串指针变换公式为`j=next2[j]+1`。

### 计算nextval数列

此处所提`next`数列的确切定义为：
- 如果`j=1`，则`next[j]=0`。
- 如果`j>1`，则：
	- 如果存在`P[1...k-1]==P[j-k+1...j-1]`，则`next[j]`取所有`k`的最大值。
	- 如果不存在，则`next[j]=1`。

如果`P[j]==P[next[j]]`，则模式串需要连续后退至少两次才能继续有效匹配。考虑令`k=next[next[...[next[j]]]]`，其中`k`是使得`P[k]!=P[j]`成立的最大值。这样通过模式串指针变换公式`j=nextval[j]`可以最小化变换次数。

### 演绎

![[Pasted image 20231027152245.png]]

8题选C。`abaabc`的`nextval`数组为`[0,1,0,2,1,3]`。但题目中给定的是0开始的下标，因此按后退位置数计算，后退3个位置。

9题选B。第一次失配在`T[6]`位置，后退3个位置于`i=6,j=3`重新开始匹配，随后匹配成功。总共比较次数是6+4=10次。

## 二叉树、线索二叉树、三种遍历方式

- 无递归的遍历方式
- 三种线索二叉树的构造
- 三种线索二叉树的遍历方式

## 关键路径问题

WIP

## AVL树

- 平衡性质及其维护
- 插入和删除操作
- 平均查找长度

## B树

- B树的性质
- B树的插入、删除操作
- B+树的性质

## 哈希表

WIP

## 各类内部排序算法

WIP

## 外部排序

WIP