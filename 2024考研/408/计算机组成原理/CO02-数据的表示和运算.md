
## 框架

- 数制与编码
	- 进位计数制及其相互转换
	- BCD码（略）
	- 定点数的编码表示：原码、反码、补码、移码
	- 整数的表示
- 运算方法和运算电路
	- 基本运算部件
	- 定点数的移位运算
	- 定点数的加减运算
	- 定点数的乘除运算
	- C语言中的整数类型及类型转换
	- 数据的存储和排列
- 浮点数的表示与运算
	- 浮点数的表示
	- 浮点数的加减运算

## 定点数的编码表示

**定点表示**：
- 定点小数：`A.XXXX`，A为符号位。
- 定点整数：`AXXXX`，A为符号位。

| 表示法 | `x1=+0.1101` | `x2=-0.1101` | 0的表示 | 优点 | 缺点 |
| --- | --- | --- | --- | --- | --- |
| 原码 | `0.1101` | `1.1101` | 不唯一 | 与真值的对应关系直观 | 0的表示不唯一，计算复杂 |
| 补码 | `0.1101` | `1.0011` | `0.0000` | 计算简便 | 无 |
| 反码 | `0.1101` | `1.0010` | 不唯一 | 无 | 0的表示不唯一，表示范围少一个负数 |
| 移码 | `1.1101` | `0.0011` | `1.0000` | 无 | 欠直观 |

## 加法运算部件

**一位全加器**：
- 输入：加数$A_i,B_i$和前一位进位$C_{i-1}$。
- 输出：本位和$S_i$和进位$C_i$。

$$
S_i=A_i\oplus B_i\oplus C_{i-1}, C_i=A_i B_i+(A_i\oplus B_i)C_{i-1}
$$

![[Pasted image 20230922211834.png]]

**串行进位加法器**：多个一位全加器串联。

**并行进位加法器**：
令进位产生函数$G_i=A_i B_i$，进位传递函数$P_i=A_i\oplus B_i$，则全加器的进位表达式为：
$$
C_i=G_i+P_i C_{i-1}
$$
对于4位全加器，有：
$$
C_4=G_4+P_4C_3=G_4+P_4G_3+P_4P_3G_2+P_4P_3P_2G_1+P_4P_3P_2P_1C_0
$$

逻辑线路表示：
![[Pasted image 20230922212733.png]]

## 定点数的乘法运算

### 原码一位乘法

设被乘数为$x_S. x_1x_2\cdots x_n$，乘数为$y_S.y_1y_2\cdots y_n$，运算规则：
- 符号位不参加运算，乘积符号位为$x_S\oplus y_S$，乘数取绝对值参加运算，以原码形式表示。
- **生成部分积**：部分积是乘法过程的中间结果。乘数的每一位$y_i$乘以被乘数得$X\cdot y_i$后，将该结果和之前的结果累加，得到部分积，初值为0。
- **部分积右移**：从乘数的最低位$y_n$开始判断：若$y_n=1$，则部分积加上被乘数$|x|$，然后右移一位；若$y_n=0$，则部分积加上0，然后右移一位。
- 重复步骤，判断$n$次。

![[Pasted image 20230922230510.png]]

### 补码一位乘法（Booth算法）

设$[X]_{补}=x_s.x_1x_2\cdot x_n$，$[Y]_{补}=y_s.y_1y_2\cdots y_n$，运算规则：
- 符号位参加运算，运算结果均通过补码表示。
- 被乘数和部分积取双符号位，初值为0，乘数取单符号位。
- 乘数末位增设附加位$y_{n+1}$，初值为0。
- **根据尾数加或减**：根据$(y_n,y_{n+1})$的当前取值情况，分别采取不同操作：
	- $(0,0)$、$(1,1)$：不进行操作。
	- $(0,1)$：部分积加$[X]_{补}$。
	- $(1,0)$：部分积加$[-X]_{补}$。
- 如果当前是第$n+1$次操作，则结束运算；否则部分积**整体右移一位**。这意味着整个运算包括$n+1$次操作和$n$次移位。
- 细节：
	- 部分积包括左侧的高位部分积和右侧的低位部分积，高位部分积的初始值为$x_sx_s.x_1x_2\cdots x_n$，低位部分积的初始值为$y_s.y_1y_2\cdots y_ny_{n+1}$。
	- 运算在左侧的高位部分积上进行。
	- 移位操作会将左侧高位部分积的最右一位移出，移到右侧低位部分积的最左侧，右侧部分积的小数点不动。最左侧补位采用符号补位。
	- 运算结束时，$y_n$和$y_{n+1}$应恰在小数点两侧。运算结果取左侧部分积全部和右侧部分积的高$n$位。

![[Pasted image 20230922232613.png]]

最终结果：$[x\cdot y]_{补}=-0.01110001$。

## 定点数的除法运算

### 原码除法运算（不恢复余数法）

设被除数$[X]_{原}=x_s.x_1x_2\cdots x_n$，除数$[Y]_{原}=y_s.y_1y_2\cdots y_n$。

运算规则：
- 商的符号$Q_s=x_s\oplus y_s$，符号位不参与计算。
- 先用被除数减去除数。根据余数的正负采取不同行动：
	- 余数为正：商1，余数和商左移一位，减去除数。
	- 余数为负：商0，余数和商左移一位，加上除数。
- 上述步骤执行$n+1$步，若第$n+1$步余数为负，则需要加除数得到正确的余数。

![[Pasted image 20230922233730.png]]
![[Pasted image 20230922233744.png]]

### 补码除法运算（加减交替法）

运算规则：
- 符号位参加运算，除数与被除数均用补码表示，商和余数也用补码表示。
- 若被除数和除数同号，则被除数减去除数；若被除数和除数异号，则被除数加上除数。
- 根据余数和除数的符号情况，操作$n$轮：
	- 若两者同号，则商1，余数左移一位，减去除数。
	- 若两者异号，则商0，余数左移一位，加上除数。
- 若对商的精度没有特别要求，则一般末位恒置1。

![[Pasted image 20230923014902.png]]
![[Pasted image 20230923014914.png]]

## 状态位（CF、OF、ZF）在运算中的变化

### 移位操作中CF的变化

### 溢出判断

无符号数溢出则CF=1，有符号数溢出则OF=1。

CF=1：最高位加法有进位，或减法有借位。

OF=1：
- 加法时：操作数符号位一致，但不同于结果的符号位（0+0=1、1+1=0）
- 减法时：差值的符号位和减数符号位一致（1-0=0、0-1=1）

## 浮点数的表示

$$
N=(-1)^S\cdot M\cdot R^E
$$

- S：符号位
- M：尾数
- R：基数（一般是隐含的，不会存储）
- E：指数

**表示范围**：关于原点对称，有两个对称的可表示区间。
- 上溢：指数上溢。
- 下溢：指数下溢。
![[Pasted image 20230923140438.png]]

### 规格化操作

通过调整一个非规格化浮点数的尾数和阶码的大小，使非零浮点数在尾数的最高数位上保证是一个有效值。
- **左规**：对$\pm 0.0\cdots 0\cdots\times \cdots$型的浮点数，需要对尾数左移，每次左移一位、阶码减一（底数为2时）。有可能需要进行多次。
- **右规**：对$\pm 1.\cdots \times\cdots$型的浮点数，需要对尾数右移，每次右移一位、阶码加一（底数为2时）。一般只需要进行一次。

无论何种方式，尾数必须满足$1/R\le |M|< 1$。特别地，$M=2$时，$1/2\le |M|<1$。

### IEEE754

![[Pasted image 20230923142452.png]]

![[Pasted image 20230923142504.png]]

![[Pasted image 20230923142614.png]]

## 浮点数的运算

**主要步骤**：
- 对阶：两个数的阶码必须相等，阶码较小的需要通过若干次右规调整到与另一个数同阶。
- 尾数求和：尾数相加。
- 规格化：尾数相加的结果进行规格化。
- 舍入：对阶和尾数右规时，尾数右移可能丧失精度。低位移出的最高两位一般会留下来，参加中间运算，最后将运算结果舍入。
	- 方法：0舍1入法、恒置1法、截断法。
- 溢出判断：指数上溢则异常，指数下溢则计算结果为0。

## 选择题整理-非真题

![[Pasted image 20230923094111.png]]

17题选D。x为0或正数时都满足条件。

![[Pasted image 20230923094122.png]]

20题选A。如果整数表示法区分+0和-0，说明只能是原码或反码的一种。由于原码的-0表示为10000000，反码的-0表示为11111111，所以题中的表示为原码表示。

21题选D。原码、反码、补码的+127表示为01111111，只有移码的符号位为1。

![[Pasted image 20230923095412.png]]

3题选C。虽然A、B、D也是影响因素，但对于串行进位的加法器而言，C项会直接决定加法器的运算速度，因此最为关键。

![[Pasted image 20230923095422.png]]

10题选C。容易忽视不带进位位这一提示而误选A。在不带进位位的循环左移中，最高位会同时送入CF和最低位。

![[Pasted image 20230923095446.png]]

15题选B。**模4补码**即双符号位补码，模2补码即单符号位补码。

A项说法有误，应该是更易检查加减运算中的溢出问题。

B项是正确的，只有操作模4补码时需要用到两个符号位，而在存储期间不需要，可以只存储一位。同理，C项是错误的。

D项错误，在ALU中操作模4补码需要两个符号位。

![[Pasted image 20230923095543.png]]

22题选B。运算结果的符号位直接通过乘数符号位决定。

![[Pasted image 20230923095723.png]]

24题选D。乘积包括符号位，因此总共2N+1位。

![[Pasted image 20230923095735.png]]

27题选D。三个说法都是正确的。

![[Pasted image 20230923095744.png]]

29题选B。容易误选C。本题涉及到减法在CPU中的实现，传入减数并不是直接计算其相反数的补码，而是先将所有位取反，再置进位为1。

![[Pasted image 20230923145554.png]]

7题选C。对阶不会出现阶码减小的情形。

![[Pasted image 20230923145731.png]]

13题选D。非规格化浮点数的精度有限。

![[Pasted image 20230923145740.png]]

15题选A。注意下溢并非数值过小，而是数值绝对值过小。

![[Pasted image 20230923145954.png]]
![[Pasted image 20230923150008.png]]

20题选C。不带符号说明小数点前一位是符号位。四个选项中，只有C项的最高两位为非零。

21题选C。第一个说法是错的，定点数没有舍入的概念；第二、三、四个说法都是错的，舍入的情形包括对阶和右规格化两种情形。舍入不一定产生误差，第五个说法是正确的。

## 选择题整理-真题

![[Pasted image 20230923095829.png]]

本题选A。本题不要考虑运算的实现细节，而只需要关注计算结果。由于这两个数代表的无符号数减法没有溢出，所以CF=0；由于有符号数减法没有溢出，所以OF=0。

![[Pasted image 20230923154528.png]]

本题选A。容易误选B。因为IEEE754规定全零浮点数对应+0，而不是`1.0*2^(-127)`。

## 大题整理

### 2011：有符号数和无符号数加减法、溢出判断

![[Pasted image 20230923112903.png]]

分析程序的运算过程：
- 第一行：x=134。
- 第二行：y=246。
- 第三行：m=-122。
- 第四行：n=-10。
- 第五行：z1=144。
- 第六行：z2=124。
- 第七行：k1=-112。
- 第八行：k2=-4。

第一问，R1内容为86H，R5内容为90H，R6内容为7CH。

第二问，m=-122，k1=-112。

第三问，能。有符号整数的加减运算可以借由无符号整数加减运算完成，两者都可以在8位加法器中完成。

第四问，判断运算结果符号位和运算数符号位的关系。以加法为例，两个加数的符号位相同，但结果的符号位与两者不同，则认为发生了溢出。第八个语句发生了溢出。

### 2020：有符号和无符号数乘法、溢出判断

![[Pasted image 20230923112911.png]]

第一问，乘法可以分解为加减法和位移运算的组合。对乘数进行位移可以得到乘数的2^N倍，将若干个这样的倍数相加即可得到乘积。

第二问，控制逻辑的目的是控制循环次数、控制加法和移位操作。

第三问：
- 没有乘法指令：乘法会被翻译为一个循环代码段，循环N轮，每轮由K条指令组成，耗费NMK个周期（设CPI为M），耗时最长。
- 有ALU乘法指令：乘法操作不必经过流水线，而是直接由ALU控制，耗费约2N个周期，耗时较短。
- 有阵列乘法器乘法指令：耗时P个周期（P小于N），耗时最短。

第四问：
- 无符号整数乘法指令结果：00000000 FFFFFFFEH。
- 有符号整数乘法指令结果：00000000 FFFFFFFEH。
- umul函数不会发生溢出，但imul会。
- 如果乘法结果的高n位不全为0，则溢出，否则不溢出。

### 2017：整数和浮点数运算的横向对比

![[Pasted image 20230923154946.png]]
![[Pasted image 20230923155015.png]]

第一问，因为循环维持条件`i<=n-1`等价于`i<=FFFFFFFFH`，始终成立。类型改为int则不会出现死循环。

第二问，因为`f2(23)`仍然在单精度浮点数的表示范围内，所以两者相等，均为`(1<<24-1)`。
- `f1(23)=00FFFFFFH`。
- 浮点数的尾数部分为8388607，指数部分为150，符号位为0，`f2(23)=4B7FFFFFH`。

第三问，因为`f2(24)`超出了单精度浮点数的表示范围，尾数最后一位被截断，导致精度损失以及误差产生。

第四问，int类型是32位有符号变量，在运算过程发生了溢出。最大的n是30。

第五问，对应的值是正无穷。使结果不溢出的最大的n是126，使结果精确的最大的n是23。