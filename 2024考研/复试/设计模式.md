
## outline

- 创建型模式
	- 工厂方法模式
	- 抽象工厂模式
	- 单例模式
	- 建造者模式
	- 原型模式
- 结构型模式
	- 适配器模式
	- 装饰器模式
	- 代理模式
	- 外观模式
	- 桥接模式
	- 组合模式
	- 享元模式
- 行为型模式
	- 策略模式
	- 模板方法模式
	- 观察者模式
	- 迭代子模式
	- 责任链模式
	- 命令模式
	- 备忘录模式
	- 状态模式
	- 访问者模式
	- 中介者模式
	- 解释器模式

## 工厂方法模式

## 抽象工厂模式

工厂类的工厂

## 单例模式

## 建造者模式

如果对象的构造工序复杂，则需积极考虑使用建造者模式。

![[Pasted image 20240213012549.png]]

## 原型模式

运行时多态

## 适配器模式

协调器用于协调两或多个互不兼容的类接口

![[Pasted image 20240213083338.png]]

## 装饰器模式

为对象动态添加职责

角色：
- 抽象组件
- 具体组件：被装饰的原始对象
- 抽象装饰器
- 具体装饰器：在调用原始对象方法的前后执行自己的操作

Python的装饰器比较简单灵活

![[Pasted image 20240213145529.png]]

```java
// RedShapeDecorator.java
public class RedShapeDecorator extends ShapeDecorator {
 
   public RedShapeDecorator(Shape decoratedShape) {
      super(decoratedShape);     
   }
 
   @Override
   public void draw() {
	  // 装饰器函数，这里调用被装饰对象的方法
      decoratedShape.draw();         
      setRedBorder(decoratedShape);
   }
 
   private void setRedBorder(Shape decoratedShape){
      System.out.println("Border Color: Red");
   }
}

// DecoratorPatternDemo.java
public class DecoratorPatternDemo {
   public static void main(String[] args) {
 
      Shape circle = new Circle();
      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());
      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());
      System.out.println("Circle with normal border");
      circle.draw();
 
      System.out.println("\nCircle of red border");
      redCircle.draw();
 
      System.out.println("\nRectangle of red border");
      redRectangle.draw();
   }
}
```

## 代理模式

为其他对象提供一种代理以*控制*对被代理对象的访问

与其他模式区别：
- 适配器模式：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。
- 装饰器模式：装饰器模式为了增强功能，而代理模式是为了加以控制。

角色：
- 抽象主题
- 真实主题
- 代理：实现抽象主题接口，持有真实主题引用，提供一些额外功能
- 客户端：使用抽象主题接口操作真实主题或代理主题，而不需要知道是哪个类实现了主题

![[Pasted image 20240213162818.png]]

`ProxyImage`为`RealImage`提供了一层代理。主程序在操作`Image`时，可能操作`RealImage`，也可能操作`ProxyImage`。

## 外观模式

为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

角色：
- 外观：提供子系统对外的简化接口
- 子系统：负责具体功能
- 客户端：与子系统通过外观对象交互

![[Pasted image 20240214090029.png]]

外观类为`ShapeMaker`：

```java
public class ShapeMaker {
   private Shape circle;
   private Shape rectangle;
   private Shape square;
 
   public ShapeMaker() {
      circle = new Circle();
      rectangle = new Rectangle();
      square = new Square();
   }
 
   public void drawCircle(){
      circle.draw();
   }
   public void drawRectangle(){
      rectangle.draw();
   }
   public void drawSquare(){
      square.draw();
   }
}
```

## 桥接模式

将抽象部分与实现部分分离，使它们都可以独立的变化。

角色：
- 抽象：抽象接口，包含对实现接口的调用
- 扩展抽象：对抽象的扩展
- 实现：定义实现接口
- 具体实现：实现实现接口的具体类

![[Pasted image 20240214101747.png]]

类`RedCircle`和`GreenCircle`为接口`DrawAPI`的`drawCircle`方法提供实现，而抽象类`Circle`则规定所画圆形的更多细节（圆心坐标、半径）。

## 组合模式

将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

角色：
- 组件：定义所有对象的通用接口
- 叶子节点
- 复合节点：表示组合中的复合对象，可以包含一系列子结点
- 客户端：通过组件接口与组合结构交互

![[Pasted image 20240214114136.png]]

（说白了和Qt对象树是一个模子）

## 享元模式

如果系统内有大量相似对象，可考虑把其中共同的部分抽象出来，运用共享技术减少创建对象的数量。

角色：
- 享元工厂（flyweight factory）
- 抽象享元
- 具体享元：实现抽象享元接口，通常可以设置外部状态
- 客户端

![[Pasted image 20240214131229.png]]

在`ShapeFactory`类中，`getCircle`并不是每次都会创建一个圆，而是会先查表检查是否创建过相同的对象。

## 策略模式

一个类的行为或其算法可以在运行时更改

角色：
- 环境（context）：维护一个对策略对象的引用
- 抽象策略
- 具体策略：实现抽象策略定义，包含具体算法实现

![[Pasted image 20240214190215.png]]

上例中策略的更改是通过在运行时指定不同的策略对象实现的

## 模板方法模式

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

![[Pasted image 20240214203818.png]]

## 观察者模式

定义了一种*一对多的依赖关系*，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。

角色：
- 主题：被观察者，维护观察者列表
- 观察者：接收主题通知
- 具体主题
- 具体观察者

![[Pasted image 20240214231009.png]]

在上例中，主题`Subject`绑定一系列观察者`Observer`。当主题发生变更，则会调用所有绑定观察者的更新方法：

```java
import java.util.ArrayList;
import java.util.List;
 
public class Subject {
   
   private List<Observer> observers 
      = new ArrayList<Observer>();
   private int state;
 
   public int getState() {
      return state;
   }
 
   public void setState(int state) {
      this.state = state;
      notifyAllObservers();
   }
 
   public void attach(Observer observer){
      observers.add(observer);      
   }
 
   public void notifyAllObservers(){
      for (Observer observer : observers) {
         observer.update();
      }
   }  
}
```

## 迭代子模式

用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

毋庸多言。

## 责任链模式



角色：

## 命令模式

角色：

## 备忘录模式

角色：

## 状态模式

角色：

## 访问者模式

角色：

## 中介者模式

角色：

## 解释器模式

角色：