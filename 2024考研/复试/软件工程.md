
参考资料：
- [博客1](https://blog.csdn.net/RockLis/article/details/125556318)
- [博客2](https://blog.csdn.net/m0_57099044/article/details/121640305)

## outline

- 概论
	- 软件过程模型（8）
- 系统工程
	- 可行性分析：经济可行性、技术可行性、法律可行性
- 需求工程
	- 需求获取
- 设计工程
	- 软件设计任务
	- 软件设计原则
	- 软件体系结构设计
	- 部件级设计技术
- 结构化分析和设计
	- **数据流图**
		- 数据流图的图形表示
		- 数据流图的扩充符号
		- 数据流图的层次结构
		- 分层数据流图的画法
	- 数据字典
- 面向对象方法基础
	- 基本概念、分析和设计过程
	- UML
- 面向对象建模
	- 用况建模
	- 静态建模：类图和对象图
	- 动态建模：状态机图、活动图、顺序图
- 程序设计语言和编码
	- 程序设计风格
- 软件测试
	- 软件测试基础：目的、基本原则、分类
	- 白盒测试
	- 黑盒测试
	- 测试策略：单元、集成、系统、确认
- 软件维护与再工程

## core_questions

- 软件过程有哪些模型，大致分几步
- 可行性分析的内容
- 敏捷开发
- 需求工程的阶段
- 用况
- 软件设计的内容
- 内聚、耦合、模块独立性的关系
- 软件体系结构的5种风格
- 部件级设计的图形表示法3种方式
- 结构化表示方式

## 概论

软件的定义：软件=程序+数据+文档

软件危机：在计算机软件开发和维护过程中遇到的一系列严重问题，包括周期长、成本高、质量差、维护难

软件生存周期：系统工程、需求分析、设计、编码、测试、运行、维护

### 软件过程模型

软件过程模型：
- 瀑布模型（6阶段，特征，缺点）
- 演化模型
- 增量模型（5阶段，特征，用途）
- 原型模型
- 螺旋模型
- 喷泉模型
- 基于构件的开发模型
- 形式方法模型

WIP

## 系统工程

基于计算机的系统是指：通过处理信息来完成某些预定义目标而组织在一起的**元素的集合**。

组成基于计算机系统的元素主要有：软件、硬件、人员、数据库、文档和规程。

### 可行性分析

可行性分析：分析一个系统开发的解决方案是否可行，即是否能在规定的资源和时间约束下完成。
- 经济可行性：成本、效益、货币的时间价值、投资的回收期、纯收入
- 技术可行性：风险分析、资源分析、技术分析
- 法律可行性：可能涉及的合同、侵权、责任以及各种与法律相抵触的问题

WIP

## 需求工程

需求工程的大致阶段：
- 需求获取
- 需求分析和协商
- 系统建模
- 需求规约
- 需求验证
- 需求管理

**需求获取**：
- 软件需求分类：功能、性能、用户或人、环境、界面、文档、数据、资源使用、安全保密、可靠性、软件成本消耗与开发进度、其他非功能性
- 获取方法：顺畅的通信路径、访谈与调查、观察用户操作流程、组成联合小组

**用况**（use case）：
- 定义：是软件工程或系统工程中对系统如何反应外界请求的描述，是一种通过用户的使用*场景*来获取需求的技术。每个用况提供了一个或多个*场景*，该场景说明了系统是如何和最终用户或其它系统互动，也就是谁可以用系统做什么，从而获得一个明确的业务目标。
- 要素：确定并选取*执行者*（actor），定义执行者希望系统做什么（用况*内容*），描述用况的基本过程（何时使用系统、发生什么）。

![[Pasted image 20240208132020.png]]

WIP

## 设计工程

与需求工程的区别：
- 需求工程：做什么
- 设计工程：怎么做

软件设计任务：数据/类设计、体系结构设计、接口设计、部件级设计

![[Pasted image 20240208133010.png]]

软件设计原则：抽象与逐步求精、模块化、信息隐藏、功能独立（高内聚低耦合）

**内聚**（cohesion）

![[Pasted image 20240208133215.png]]

**耦合**（coupling）

![[Pasted image 20240208133244.png]]

### 软件体系结构设计

**软件体系结构的风格**：
- 数据为中心的体系结构
- 数据流风格的体系结构
- 调用和返回风格的体系结构
- 面向对象风格的体系结构
- 层次式风格的体系结构

### 部件级设计技术

#### 结构化程序设计方法

WIP

#### 图形表示法

**程序流程图**：

![[Pasted image 20240208135133.png]]

**N-S图**：

![[Pasted image 20240208135147.png]]

**PAD图**：

![[Pasted image 20240208135157.png]]

## 结构化分析与设计

### 结构化表示方式概述

逻辑模型=数据流图+数据字典

数据字典：
- 实体-关系（E-R）图：数据对象描述
- 状态转换图：控制规约
- 数据流图：加工规约

**实体-关系图**：

![[Pasted image 20240208165530.png]]

**状态转换图**：

![[Pasted image 20240208165549.png]]

**数据流图**：

![[Pasted image 20240208165605.png]]

### 数据流图

**数据流图**（data flow diagram，DFD）：描述输入数据流到输出数据流的变换过程，用于对系统的功能建模，基本元素包括：
- $\rightarrow$（数据流，data flow）：由一组固定成分数据组成，描述数据*流动方向*。
- $\bigcirc$（加工，process）：描述了输入数据流到输出数据流的*加工过程*。
- $=$（文件，file）：用于*保存*某些数据，供以后使用。注意不一定是文件系统，也可以是数据库系统。
- $\square$（源，source；宿，sink）：表示存在于系统之外的人员或组织，源表示输入数据的*来源*，宿表示输出数据的*去向*。

数据流图的**图形表示**：
- 源、宿：数据流流出则表示源，流入则表示宿，皆有则表示源和宿相同。
- 加工：用一个确定的名字定义，有一或多条输入输出流。
- 文件：用一个确定的名字定义，由加工进行读写。
- 数据流：用一组固定成分的数据组成，由一个确定的名字定义，分5种类型：
	- 管道：从一个加工流向另一个加工。
	- 写文件：从加工流向文件。
	- 读文件：从文件流向加工。
	- 输入：从源流向加工。
	- 输出：从加工流向宿。

加工的**扩充符号**：
- 与关系（$*$）：所有输入流同时存在时才能进行加工处理。
- 或关系（$+$）：至少存在一个输入流时，能进行加工处理。
- 异或关系（$\oplus$）：必须存在且仅存在一个输入数据流时，才能进行加工处理。

数据流图的**层次结构**：通过合理拆分使DFD分层，每个较低层的DFD代表其直接上层DFD的一个*加工*。
- 顶层图：只有代表整个软件系统的*一个加工*。
- 0层图：将顶层图的加工初步分解得到的图。
- 中间层图：一或多个加工各自对应一张下层图。
- 底层图：所有加工不再分解为子图。

图和加工的编号：
- 加工的编号：先给0层图的加工编号，再按层级优先的方式给子图的加工编号。
- 图的编号：0层图不编号，其余子图的编号与其对应的加工相同，如：3号加工分解为图3。

### 数据字典

数据字典由字典条目组成，每个条目描述DFD的一个元素，包括：数据流、文件、数据项、加工、源或宿。

![[Pasted image 20240209161233.png]]

数据流条目的**描述内容**：
- 名称、别名、简述
- 数据流的组成、来源、去向：由哪些数据项组成，从哪个加工或源流出，流向哪个加工或宿
- 数据量及其峰值：系统中该数据流总量及某时段的最大数量

## 面向对象方法基础

### 面向对象基本概念

面向对象=对象+分类+继承+通过消息的通信

**对象**（object）：一组属性以及这组属性上的专用操作的封装体。
- 组成：对象名、属性、操作。

**属性**（attribute）：归属于某个对象，表示这个对象的状态。通常只能通过对象提供的操作修改，通常存储一些数据或指向另一个对象。

**操作**（operation）：也称方法或服务，规定了对象的行为，表示对象所能提供的服务。

**封装**（encapsulation）：使用户只能看见对象封装界面上的信息，而屏蔽对象的内部实现细节。目的是使对象的生产者和使用者、定义和实现分开。

**类**（class）：一组具有相同属性和操作的对象集合。一个类中每个对象是该类的一个*实例*（instance）。
- 和对象的关系：类是创建对象的模板，同一个类实例化的所有对象的结构、行为相同。

**继承**（inheritance）：类间的基本关系，基于层次关系的不同类共享数据和操作的一种机制。
- 父类、子类：父类定义公共属性和操作，子类继承父类并定义自己的成员
- 抽象类：提供一套公共成员定义以供其他类继承，但不实际产生实例的类。
- 抽象操作：抽象类中声明但不提供定义的方法，只能通过子类继承并提供实现。
- 单一继承、多重继承：类的父类数量

### 面向对象分析和设计过程

面向对象分析的一般步骤：
- **用况建模**：获取客户对系统的需求（标识场景、用况等），建立需求模型
- **静态建模**：以基本的需求为指南，选择类和对象。
- 定义类的结构和层次：类的2种结构
	- 一般-特殊结构
	- 整体-部分结构
- 建造对象-关系模型：描述静态结构和类间关系
	- 
- 建造对象-行为模型（**动态建模**）
- 利用用况/场景来复审分析模型

![[Pasted image 20240210005811.png]]

![[Pasted image 20240210005824.png]]

### UML

UML的基本概念：
- *视图*（view）：每个视图是整个系统描述的一个投影，说明系统的一个特殊侧面。若干个视图构成整个系统的一个描述。
- *图*（diagram）：视图的组成部分。包含了系统某个特殊方面的信息，阐明系统的一个特定部分或方面。
- *模型元素*：图的组成元素，表示图中的某一*概念*，如：类、对象、用况、节点、接口、包、注释、构件等；或者也可表示其他模型元素之间的*关系*，如：关联、泛化、依赖、实现等。

![[Pasted image 20240210125040.png]]

![[Pasted image 20240210125123.png]]

![[Pasted image 20240210125133.png]]

![[Pasted image 20240210125141.png]]

![[Pasted image 20240210125147.png]]

## 面向对象建模

### 用况建模

创建用况建模的步骤：
- 定义系统
- 确定执行者（与系统交互的人或其它系统）
- 确定用况：用况由*执行者*启动，是类型，不是实例（实例称为场景）
- 描述用况
- 定义用况之间的关系：关联、扩展、包含、泛化
- 确认模型

![[Pasted image 20240210143832.png]]
![[Pasted image 20240210143839.png]]

### 静态建模

类和对象模型：描述系统的静态结构（类、对象、关系），在UML中用类图和对象图表示。

类图和对象图：
- 类图：由系统中使用的类及其间关系组成，是一种静态模型，也是其他图的基础。
- 对象图：类图的一个实例，描述某一时刻类图中类的特定实例、以及这些实例间的特定链接。

![[Pasted image 20240210150922.png]]

![[Pasted image 20240210150935.png]]
![[Pasted image 20240210150940.png]]

**类间关系**：关联、依赖、泛化、实现等。

![[Pasted image 20240210151239.png]]
![[Pasted image 20240210151317.png]]
![[Pasted image 20240210151330.png]]
![[Pasted image 20240210151335.png]]
![[Pasted image 20240210151341.png]]
![[Pasted image 20240210151348.png]]

**静态建模步骤**：
- 标识候选对象
- 筛选候选对象：删除外部执行者、未出现在用况图中、无属性的对象。
- 标识属性和操作
- 确定类之间的关系

### 动态建模

动态建模：用状态机图、活动图、顺序图、通信图和协作图建立动态模型。

#### 状态机图

状态机图通常是对类描述的补充，它说明该类的对象所有可能的状态，以及哪些事件将导致状态的改变。状态机图描述了对象的动态行为，是一种对象生存周期的模型。

画状态机图的步骤：
- 列出对象具有的所有状态
- 标识导致状态转换的事件
- 为状态和迁移定义状态变量和动作

状态：
- 组成：状态名、状态变量、活动
- 状态变量：状态机图所显示的类的属性，也可以是临时变量
- 活动：列出了处于该状态时执行的事件和动作
	- 三个标准事件：`entry`、`do`、`exit`。

状态迁移：
- 标在迁移箭头上的事件出现
- 未指明事件（无条件跳转）

![[Pasted image 20240211095103.png]]

示例：电梯的运行逻辑。在用户发出指令时移动到用户所在楼层，空闲时回到一层。

![[Pasted image 20240211111833.png]]

#### 活动图

活动图：
- 是一种特殊形式的状态机，用于对*计算流程和工作流*建模。活动图的状态表示计算过程中所处的各种状态。
- 用于*描述*完成一个操作所需的*活动*，或一个用况实例（场景）的活动。
- 使用状态机图的*符号表示*，其中的动作状态用圆角矩形表示，迁移用箭头表示，可附加警戒条件、发送子句和动作表达式。
- 与状态机图不同，迁移是在完成活动内事件后便触发，而非事件驱动。

活动图的结构：
- 泳道：一张矩形图的一个矩形分区，顶端标注泳道名。通常根据责任把活动组织到不同的泳道上，能清楚表明动作在哪里执行，或表明一个组织的哪部分工作被执行。
- 迁移的分解、合并：迁移可以分解为若干个并行动作的分解，若干个并行动作的分解也可以合并为一个迁移。合并之前所有并行活动必须全部完成。
- 对象：用矩形符号表示，作为活动的输入或输出，也可表示一个对象受一个特定动作的影响。

示例：订单的接收和处理

![[Pasted image 20240211123622.png]]

#### 顺序图

![[Pasted image 20240211123958.png]]

示例：

![[Pasted image 20240211124843.png]]

## 程序设计语言和编码

**编程风格主要内容**：
- 源程序中的内部文档
    - 标识符的命名
    - 注解
    - 程序的视觉组织
- 数据说明
    - 数据说明的次序应当规范化
    - 说明语句中变量安排有序化
    - 使用注解说明复杂数据结构
- 语句构造
- 输入／输出

## 软件测试

### 软件测试基础

软件测试的**目的**：
- 测试是一个为了发现错误而执行程序的过程。
- 一个好的测试用例是指很可能找到迄今为止尚未发现的错误的测试用例。
- 一个成功的测试是指揭示了迄今为止尚未发现的错误的测试。

软件测试的**基本原则**：
- 所有的测试都应可追溯到客户需求。
- 应该在测试工作真正开始前的较长时间就进行测试计划。
- *Pareto原则*：测试中发现的80%的错误可能来自于20%的程序代码。
- 测试应从“小规模”开始，逐步转向“大规模”。
- 穷举测试是不可能的。
- 为了达到最有效的测试，应由独立的第三方来承担测试。
- 其他原则

白盒测试和黑盒测试：
- 测试用例的设计是软件测试的关键所在。
- 设计尽可能少的测试用例来发现尽可能多的错误。
- 设计最有可能发现软件错误的测试用例，同时避免使用发现错误效果相同的测试用例。
- 测试用例的设计方法大体可分为两类：白盒测试和黑盒测试，也称白箱测试和黑箱测试。

### 白盒测试

白盒测试（结构测试）：
- 含义：把测试对象看成透明盒子，测试人员面向源码逻辑设计测试用例，检查程序中所有逻辑路径是否都按照预定的要求正确工作。
- 主要用途：对模块的测试，包括：
	- 程序模块中的所有独立路径至少执行一次
	- 对所有逻辑判定的取值都至少测试一次
	- 在上下边界及可操作范围内运行所有循环
	- 测试内部数据结构的有效性

**逻辑覆盖测试**：
- 语句覆盖
- 判定覆盖
- 条件覆盖
- 判定/条件覆盖
- 条件组合覆盖
- 路径覆盖

示例：

![[Pasted image 20240212113345.png]]

### 黑盒测试

黑盒测试：在不知晓源码内部结构时实施的测试。

**等价类划分方法**

![[Pasted image 20240212124124.png]]

### 测试策略

测试的**层次**，由低到高：
- **单元测试**：针对程序中的模块或构件，揭露*编码阶段*错误。
- **集成测试**：针对集成的软件系统，揭露*设计阶段*错误。
- **确认测试**：根据软件需求规约，对集成的软件进行确认，揭露*不符合需求规约*的错误。
- **系统测试**：将软件系统集成到计算机系统中，揭露*不符合系统工程对软件要求*的错误。

**单元测试**：
- 单元测试又称模块测试，它着重对软件设计的最小单元（软件构件或模块）进行测试。
- 单元测试根据设计描述，对重要的控制路径进行测试，以发现构件或模块内部的错误。
- 单元测试通常采用白盒测试，并且多个构件或模块可以并行进行测试。
- 这里将构件或模块统一称为模块。

单元测试的**内容**：
- 模块接口
- 局部数据结构
- 边界条件
- 所有独立路径
- 所有错误处理路径

测试的V模型：对应软件工程的前四个阶段

![[Pasted image 20240212124711.png]]

## 软件维护与再工程

软件维护：软件系统交付使用以后，为了改正错误或满足新的需要而修改软件的过程。

软件维护分类：
- 纠错性维护：为了改正软件系统中的错误，使软件能够满足预期的正常运行状态的要求而进行的维护
- 适应性维护：为了使软件适应内部或外部环境变化，而去修改软件的过程。
- 改善性维护：满足使用过程中用户提出增加新功能或修改已有功能的建议维护。
- 预防性维护：为了提高软件的可维护性、可靠性等，为以后进一步改进软件打下良好基础而修改软件的活动。