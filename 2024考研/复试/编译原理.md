
## outline

- 基本概念
- 词法分析
- 语法分析
- 属性文法和语法制导翻译
- 语义分析和中间代码产生
- 符号表
- 运行时存储空间组织
- 优化
- 目标代码生成
- 并行编译基础

## 基本概念

**形式语言**（formal language）：用精确的数学或机器可处理的公式定义的语言。与自然语言相对。
- 字母表：语言包含的所有基本字母的集合。
- 符号：字母表中的元素。
- 符号串：零或多个字母组成的有序序列，无字母组成的称为空符号串（$\varepsilon$）。
	- 运算：连接积、闭包、正则闭包。

**语法**、**文法**（grammar）：字符串的一套产生式规则。
- 形式定义：文法$G=(N,\Sigma,P,S)$，$N$为非终结符集合，$\Sigma$为终结符集合，$P$为产生式规则集合，$S$为起始符号。
- 举例：$N=\{S,B\}$，$\Sigma=\{a,b,c\}$，$P=\{S\rightarrow aBSc,S\rightarrow abc, Ba\rightarrow aB,Bb\rightarrow bb\}$。此时文法$G$定义语言$L(G)=\{a^nb^nc^n|n\ge 1\}$。
- 与语言的关系：$G$定义唯一的$L(G)$，$L(G)$由至少一种文法定义。

文法的种类：
- 0型：无限制文法，定义递归可枚举语言，自动机形式为图灵机。
- 1型：**上下文有关文法**，定义上下文有关语言，自动机形式为线性有界自动机。
	- 产生式规则形式：两种形式等价。
		- 形式一：$\alpha A\beta\rightarrow \alpha\gamma\beta$，或$S\rightarrow \varepsilon$。
		- 形式二：$\alpha A\beta\rightarrow \alpha B\beta$（其中$|B|\le |A|$），或$S\rightarrow \varepsilon$。
- 2型：上下文无关文法（详见[[编译原理#^9582fd]]），定义上下文无关语言，自动机形式为下推自动机。
	- 产生式规则形式：$A\rightarrow  w$，其中$w\in (N\cup \Sigma)^*$。
- 3型：**正则文法**，定义正则语言，自动机形式为有穷自动机。
	- 产生式规则形式：$A\rightarrow a$，或$A\rightarrow aB$，或$C\rightarrow\varepsilon$。

高级语言的一般特性：
- 分类：强制式（imperative，C/Fortran/Pascal）、应用式（applicative，Lisp）、基于规则（rule-based，Prolog）、面向对象（object-oriented，C++/Java）
- 程序结构：程序>子程序>语句>表达式>数据引用、算符、函数调用
- 数据类型：
	- 初等数据类型：整型、实型、字符型等
	- 复合数据类型：数组、记录、字符串等
	- 抽象数据类型：类
	- 三要素：属性（类型+作用域）、值域（精度+范围）、操作
- 名字和标识符：标识符只是名字的表示符号，而名字有明确意义和属性、代表特定格式存储单元，是数据、函数、过程、类型的助记符。
- 语句和控制结构：
	- 表达式
	- 语句：简单语句（说明、赋值、控制、过程调用）、复合语句
- 动态和静态：允许编译器决定某个问题的策略称为静态策略，只允许运行时决定的策略称为动态策略。

**上下文无关文法**： ^9582fd
- 描述高级语言的**语法规则**
- 产生式（产生式规则）：定义语法单位的一种书写规则
- **推导**：从起始符号出发，反复连续使用产生式对非终结符进行替换展开。
	- 直接推出：$A\rightarrow \gamma\Rightarrow \alpha A\beta\rightarrow \alpha\gamma\beta$。
	- **最左推导**（最右推导）：推导中每一步都替换最左（最右）非终结符。
- 句型：从起始符号推导零或任意步得到的终结符与非终结符的组合
- 句式：不含非终结符的句型
- 语言：由文法推导出的所有合法句式的集合：$L(G)=\{\alpha|S\overset{+}{\Rightarrow} \alpha,\alpha\in V_T^*\}$。
- **语法分析树**：文法句型推导的树形表示，简称分析树。
- 文法的二义性：存在某个句子对应两棵不同的语法树。
	- 特点：文法二义不代表对应语言二义，只有产生该语言的所有文法二义时，该语言才二义；非二义语言的二义文法可改写为非二义文法；语法分析器可以设计消除二义性的规则

## 词法分析

### 词法分析任务

源程序的字符序列=>单词序列

单词属性：
- **单词种别**：语法分析阶段使用的抽象符号
	- 符号特征：关键字、标识符、常数、运算符、界符
	- 编码方案：标识符一种，常数一类一种，其他一字一种
- 属性值：单词的附加信息

接口设计的两类方案：
- 独立一遍：被总控程序调用，一次生成整个单词序列
- 子程序：供语法分析程序调用，调用一次识别一词

### 词法分析器的设计

组件：
- 输入缓冲区：送源程序
- 预处理子程序：剔除无关字符和语句，处理预处理命令
- 扫描缓冲区（历史遗留）：双指示器（起点指示器、搜索指示器），双区缓冲（分为两个等长半区，半区长度>=最长标识符长度-1）
- 扫描器

**状态转换图**：
- **正规文法**：用于描述高级语言的**词法规则**
- 含义：一张有限的方向图，表示利用正规文法识别单词符号的全过程
- 组成：
	- 结点：代表一个状态，分初态、中间态和终态
	- 转移：代表一个状态到另一个状态的转移，用一个字符表示

状态转移图的实现（参考）：
- 变量：ch（当前读入字符）、strToken（当前单词）
- 过程：GetChar（取字符）、GetBC（滤除空字符）、Concat（子程序过程）、IsLetter、IsDigit、Reserve（查保留字表，如是返回保留字号，否则返回0）、Retract（回退搜索指针）、InsertID（将标识符插入符号表，返回符号表指针）、InsertConst（将常数插入常数表，返回常数表指针）

### 正规表达式、有限自动机

目的：自动生成词法分析程序

**正规式**和**正规集**：
- 正规式和正规集定义：若$U,V$是正规式，则$\varepsilon,\varnothing,(U|V),(U\cdot V),(U)^*$都是正规式，它们的正规集分别是$\{\varepsilon\},\varnothing,L(U)\cup L(V),L(U)L(V),(L(U))^*$。
- 优先级：括号>星号>连接>并
- 正规式等价条件：正规集相同
- 运算规律：
	- 交换律、结合律、分配律
	- $\varepsilon U=U\varepsilon=U$，$U^*=(U|\varepsilon)^*$
	- 幂等律：$(a^*)^*=a^*$。

> [!example] 正规式和正规集举例
> 令$\Sigma=\{a,b,0,1\}$，则$\Sigma$上正规式$(a|b)(a|b)$对应的正规集有$L(a|b)(a|b)=\{aa,ab,ba,bb\}$，正规式$ba^*$对应的正规集有$L(ba^*)=\{b,ba,baa,baaa,\cdots\}$。

**确定有限自动机**（definite finite automaton，DFA）：
- 定义：五元组$M=(S,\Sigma,\delta,S_0,F)$，$S$是状态集，$\Sigma$是有穷字符表，$\delta$是$S\times \Sigma\rightarrow S$的转移表，$S_0\in S$是唯一初态，$F\subseteq S$是终态集。
- 表示方式：
	- 状态转移矩阵：$|S|$行$|\Sigma|$列
	- 状态转移图
- 接受（识别、读出）：对$\alpha\in \Sigma^*$，若存在一条从初态$S_0$到某一终态结点的通路，且通路上所有弧标记连接成的字为$\alpha$，则称$\alpha$可被DFA接受。DFA M接受的所有单词称为$L(M)$。

非确定有限自动机（non-definite finite automaton，NFA）：
- 定义：五元组$M=(S,\Sigma,\delta,S_0,F)$，$S$是状态集，$\Sigma$是有穷字符表，$\delta$是$S\times \Sigma^*\rightarrow 2^S$的*状态子集转移表*，$S_0\subseteq S$是*初态集*，$F\subseteq S$是终态集。
- 状态转换图：每条弧的标记可为一个串，每个结点的出弧数量也没有限制。
- 接受（识别、读出）：与DFA类似
- 有限自动机等价：$L(M)=L(M')\Rightarrow$ M,M'等价

正规式与有限自动机的等价性：
- 正规式与NFA等价：对$\Sigma$上任意NFA M，都存在一个正规式$V$，使得$L(V)=L(M)$。
	- 证明：先将初态、终态唯一化，再根据正规式规则不断合并NFA内结构，直至仅剩初态和终态。
- DFA与正规式等价：对$\Sigma$上任意正规式$V$，都有DFA M使得$L(M)=L(V)$。
	- 证明：根据正则式规则构造NFA M‘，使得$L(M')=L(V)$，再将NFA确定化为DFA（细节见下）。

非确定有限自动机的确定化：
- 定义：设$I$是$M'$状态集的子集，则：（详见下方定义举例）
	- $\varepsilon-\text{CLOSURE}(I)$：若$S\in I$，则$S\in \varepsilon-\text{CLOSURE}(I)$，且从$S$出发经过任意条$\varepsilon$弧可达的状态$S'$也满足$S'\in \varepsilon-\text{CLOSURE}(I)$，称作$I$的$\varepsilon-$闭包。
	- $I_a$：$I_a=\varepsilon-\text{CLOSURE}(J)$，其中$J$是从$I$中某一个状态结点出发，经过一条$a$弧到达的状态结点全体。（为下文方便叙述，称作$I$关于$a$的转移集）
- 步骤：（详见下方定义举例）
	- 预处理：把标记非空串、非单字符串的弧拆分，确保所有弧的标记要么为空串，要么为单字符串。另起结点$X,Y$，X用$\varepsilon$弧连接到所有初态，所有终态用$\varepsilon$弧连接到Y。
	- 构造状态转换矩阵：每行记录一个不同状态集，以及该状态集关于字母表各个字母的转移集。如果转移集没出现在已记录的状态集中，则将其抄写到新一行中。
	- 重定义状态：对状态转移矩阵中每个不同状态集标号，作为目标DFA的状态号。
	- 画出新的DFA：根据各个DFA状态号及其转移关系，画出DFA。含NFA结点X的为初态，含NFA结点Y的为终态。

> [!example] NFA确定化的有关定义举例
> ![[Pasted image 20240105131142.png]]
> 对于上图所示的状态转换图，设$I=\{1\}$，则$\varepsilon-\text{CLOSURE}(I)=\{1,2\}$，$I_a=\varepsilon-\text{CLOSURE}\{5,4,3\}=\{5,6,2,4,7,3,8\}$。

> [!example] NFA确定化过程举例
> 设$V=(a|b)^*(aa|bb)(a|b)^*$，构造DFA M使得$L(M)=L(V)$。
> 第一步，构造NFA并作相应的预处理。
> ![[Pasted image 20240105131511.png]]
> 

确定有限自动机的化简：

### flex