
## outline

- 语法制导翻译
- 中间代码生成
- 符号表
- 运行时存储空间组织
- 优化
- 目标代码生成
- 并行编译基础

## 语法制导翻译

语法制导翻译（syntax-driven translation，SDT）=语法分析+语义分析+中间代码生成

语义翻译=语义分析+中间代码生成

任务：语法树->中间代码

### 语法制导翻译概述

语法制导定义（syntax-driven definition，SDD）：
- 每个文法符号和一个语义属性集合关联
- 每个产生式和一组语义规则相关联，这些规则用于计算该产生式中各文法符号的属性值

**属性文法**：
- 定义：对文法每个产生式都给出其语义规则的文法称为*属性文法*。
- 概念：
	- 属性：在上下文无关文法的基础上，在描述语义动作时，为每个文法符号（终结符和非终结符）配备若干相关的值，如类型、地址等，用来表示语法成分对应的语义信息，称为*语义属性*，简称*属性*。
	- 常用属性：`X.type`（X的类型）、`X.cat`（X的类别）、`X.val`（X的值或地址）
	- 语义规则：与文法产生式关联的一组属性计算规则称为*语义规则*，如产生式$A\rightarrow \alpha$的描述形式为`b:=f(c1,c2,...,ck)`，其中`b,c1,c2,...,ck`为文法符号的属性，`f`是一个函数。
	- 翻译模式：适合语法制导翻译的另一种语言翻译的描述形式，它给出了使用语义规则进行计算的次序，以表示出某些实现细节。
- 求值顺序：
	- 综合属性：对于产生式$A\rightarrow \alpha$的语义规则`b:=f(c1,c2,...,ck)`，`b`可以是$A$的*综合属性*，此时`c1,c2,...`是产生式右侧符号的属性，信息自下而上传递。
	- 继承属性：对上述规则，`b`也可以是产生式右侧某符号的*继承属性*，`c1,c2,...`则作为$A$和其他符号的属性，信息自上而下传递。

**语法制导翻译方法**：
- 基本思想：随着语法分析进展，在推导或归约时便执行对应的语义子程序，在完成翻译的同时生成中间代码。
- 实现途径：增强语法分析器功能；分析栈改为语义栈（除状态、符号外加一个数值域）

> [!example] 语法制导翻译举例
> ![[Pasted image 20240114133858.png]]

语法制导翻译全过程：
- 初始：`[0,#,_]`
- 读3，移入：`[0,#,_],[5,d,3]`
- 归约：`[0,#,_],[3,F,3]`
- 归约：`[0,#,_],[2,T,3]`
- 读乘号，移入：`[0,#,_],[2,T,3],[7,*,_]`
- 读5，移入：`[0,#,_],[2,T,3],[7,*,_],[5,d,5]`
- 归约：`[0,#,_],[2,T,3],[7,*,_],[10,F,5]`
- 归约：`[0,#,_],[2,T,15]`
- 归约：`[0,#,_],[1,E,15]`
- 读加号，移入：`[0,#,_],[1,E,15],[6,+,_]`
- 读4，移入：`[0,#,_],[1,E,15],[6,+,_],[5,d,4]`
- 归约：`[0,#,_],[1,E,15],[6,+,_],[3,F,4]`
- 归约：`[0,#,_],[1,E,15],[6,+,_],[9,T,4]`
- 归约：`[0,#,_],[1,E,19]`
- 归约：`[0,#,_],[1,E',19]`

## 中间代码生成（旧）

这一部分在原书中讲得颇为混乱，弃坑了。

### 中间语言

**后缀式**（逆波兰式）：
- 特点：运算分量的个数和先后次序不变；运算符个数不变，但其出现顺序即执行顺序；无括号。
- 定义：常规式$E_1.op.E_2$对应后缀式$E_1.E_2.op$；后缀式外部的括号可摘除。
- 推广：
	- 三目运算：$e.X.Y.￥$表示在$e\neq 0$时取$X$，$e=0$时取$Y$。
	- 转移指令：无条件跳转：$p.jump$；$e_1<e_2$时跳转：$e_1.e_2.p.jlt$；$e=0$时跳转：$e.p.jez$。

**树**：表达式和子表达式、语句组和语句的关系可以用树形结构描述。

**三地址代码**：
- 一般形式：`x:=y op z`
- 记录结构：
	- 四元式：带有四个域的记录结构`(op,arg1,arg2,result)`
		- 特点：四元式之间通过临时变量联系；单目运算只使用`arg1`；`arg1,arg2,result`是指向符号表的指针。如`(NEGATE,c,_,T1),(MUL,b,T1,T2)`。
	- 三元式：带有三个域的记录结构`(op,arg1,arg2)`
		- 特点：`arg1,arg2`指向符号表或三元式表，取代临时变量。例如`<1>:(NEGATE,c,_),<2>:(MUL,b,<1>)`。
	- 间接三元式：不直接使用三元式表，另开一张间接码表，按运算次序排出三元式的顺序，去除重复三元式。
- 记录结构比较：三元式优化时修改难；间接三元式只需要改间接码表，节省空间；修改四元式表也容易，但临时变量填表占据空间。

### 翻译说明语句

说明语句作用：用关键字定义名字的性质（数据类型），分简单类型说明、数组和记录类型的说明。

语义动作：填符号表、信息向量表、除动态语句外不生成四元式。

**简单类型说明的翻译**：
- 文法：按语义规则写出文法产生式。例如`decl ::= type namelist`，`type ::= INT | FLOAT`，`namelist ::= IDENT | IDENT ',' namelist`。
- 改写文法，节省推导和归约空间
- 在翻译过程中，填写符号表，确定简单类型变量的内存首地址、类别、空间长度信息

**数组说明的翻译**：
- 文法：`arrdecl ::= type IDENT '[' INT ']'`。
- 改写文法，翻译时填写符号表，确定内存首址和长度等信息。
- 对于可变数组：编译时分配信息向量表区，产生分配对应数组空间的四元式；运行时

**保留作用域信息**：
- 对于面向过程语言的每个过程，维护一个符号表，计算各个符号在过程内部的相对地址。
- 如果语言允许嵌套过程（过程体套过程体），则需要在进入嵌套过程时暂停外部过程的符号分析。

### 翻译简单算术表达式和赋值语句

### 翻译布尔表达式

### 翻译控制语句

### 翻译数组元素引用

### 翻译过程调用

## 中间代码生成

这一部分主要参考了[哈工大编译原理课程](https://www.bilibili.com/video/BV1dL4y1H7T8?p=43&vd_source=4b806a5b4fc9caaf6e7e0cb9bd5da2a0)。

### 类型表达式

下面都是**类型表达式**：
- 基本类型：int、float、char等
- 类型名
- *类型构造符*作用于类型表达式
	- 数组构造符array：`array(length, type)`，如`array(3, int)`、`array(2, array(3, int))`
	- 指针构造符pointer
	- 笛卡尔乘积构造符$\times$
	- 函数构造符$\rightarrow$：$T_1,T_2,\dots,T_n$和$R$是类型表达式，则$T_1\times T_2\times \dots T_n\rightarrow R$也是类型表达式
	- 记录构造符record

> [!example] 类型表达式示例
> 对程序片段：`struct stype { char[8] name; int score; }; stype[50] table; stype* p;`：
> 和`stype`绑定的类型表达式：`record((name*array(8,char))*(score*integer))`
> 和`table`绑定的表达式：`array(50,stype)`
> 和`p`绑定的表达式：`pointer(stype)`

### 声明语句的翻译

语义分析任务：对每个名字，收集类型等信息->分配相对地址。
- 从类型表达式推算*类型宽度*（类型所需存储单元数量）
- 编译时刻，用类型宽度为每个名字分配*相对地址*
- 名字的类型和相对地址信息储存在符号表中

![[Pasted image 20240122152841.png]]

P：起始符号，D：声明列表，T：类型表达式，B：基本类型，C：数组长度后缀

细节：
- 语法符号B、C、T有综合属性`type`（类型表达式）和`width`（类型宽度）
- `offset`：下一个可用的相对地址
- `t`、`w`：将类型和宽度信息从B结点传递到`C->!`结点上
- `enter(id.lexeme, type, offset)`：符号表中填写符号信息

举例1：翻译`real x; int i;`。

![[Pasted image 20240122194810.png]]

举例2：翻译`int[2][3]`。

![[Pasted image 20240122202307.png]]

### 简单赋值语句的翻译

语义分析任务：生成对表达式求值的三地址码序列

![[Pasted image 20240122203527.png]]

S：起始符号，E：子表达式

细节：
- S、E的综合属性`code`记录文法符号对应的三地址码，E的综合属性`addr`记录表达式值的存放地址。
- `lookup(name)`函数查询`name`对应的记录，`gen(code)`函数生成三地址指令，`newtemp()`函数生成一个新的临时变量并返回地址。

增量翻译修正：语法符号不再存储三地址码，而是由全局的增量代码生成方式替代。

![[Pasted image 20240122210639.png]]

举例1：翻译`x=(a+b)*c;`。（详见第46节）

翻译结果：`t1=a+b; t2=t1*c; x=t2;`。

### 数组引用的翻译

语义分析任务：确定数组元素的存放地址

赋值语句的基本文法扩充（蓝字）：

![[Pasted image 20240122212431.png]]

![[Pasted image 20240122213942.png]]

L的综合属性：
- `.type`：数组元素类型
- `.offset`：著是一个临时变量，用于累加公式中的`ij*wj`项（见下面寻址部分），从而计算数组引用的偏移量
- `.array`：数组名在符号表的入口地址

数组元素寻址：
- 一维数组：设`a`首址为`base`、元素宽度`w`，则`a[i]`地址为`base+i*w`。
- 二维数组：设`a`一行的宽度为`w1`、行内元素宽度`w2`，则`a[i1][i2]`地址为`base+i1*w1+i2*w2`。
- k维数组：`a[i1][i2]...[ik]`地址为`base+i1*w1+i2*w2+...+ik*wk`。

示例：翻译`c=a[i1][i2]`可得到下列5行三地址码：
- 偏移值计算：`t1=i1*20`、`t2=i2*4`、`t3=t1+t2`。
- 寻址、赋值：`t4=a[t3]`、`c=t4`。

### 控制流语句、布尔表达式翻译

#### 控制流语句SDT

基本文法：

![[Pasted image 20240122215003.png]]

代码结构：（以if-then-else语句为例）

![[Pasted image 20240122215459.png]]

其中，B、S有如下继承属性，其中指令标号用于标识三地址码：
- `S.next`：存放紧跟在S后的指令标号
- `B.true`：存放B为真时控制流转向的指令标号
- `B.false`：存放B为假时控制流转向的指令标号

SDT：

![[Pasted image 20240123004357.png]]

细节：
- `newlabel()`：生成一个用于存放标号的新临时变量，返回其地址
- `label(L)`：将下一条指令的标号赋给L

![[Pasted image 20240123004540.png]]

![[Pasted image 20240123004655.png]]

![[Pasted image 20240123004732.png]]

#### 布尔表达式SDT

布尔表达式基本文法：

![[Pasted image 20240123004916.png]]

`relop`：6种关系运算符

**逻辑运算符的处理**：翻译为跳转指令。运算符本身不出现在代码中，逻辑表达式值是通过代码序列中的位置表示的。

示例：

![[Pasted image 20240123005418.png]]

SDT：

![[Pasted image 20240123010056.png]]

![[Pasted image 20240123010600.png]]

![[Pasted image 20240123010620.png]]

#### 控制流的一个示例

SDT的通用实现方法：先建立语法树，再按从左到右深度优先的顺序执行语义动作

翻译语句`while a<b do if c<d then x=y+z else x=y-z`。

![[Pasted image 20240123011105.png]]

![[Pasted image 20240123102837.png]]

要点：处理好布尔表达式`.true`、`.false`属性和控制流`.next`属性的关系。

#### 布尔表达式回填

布尔表达式和控制流语句代码生成的关键问题：确定跳转指令的目标标号

回填思想：在生成跳转指令时暂不指定目标标号，而是放入该目标标号对应的列表中

**布尔表达式的综合属性**：
- `B.truelist`：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是当表达式为真时控制流应当转向的指令标号
- `B.falselist`：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是当表达式为假时控制流应当转向的指令标号
- 有关操作：`makelist(i)`（创建一个只包含标号i的列表）、`merge(p1,p2)`（合并两个列表）、`backpatch(p,i)`（将i作为目标标号插入p内各指令）

truelist和falselist的设置思路：
- `B->E1 relop E2`：生成一个只包含`nextquad`（下条指令标号）的列表作为`B.truelist`，以及一个只包含`nextquad+1`的列表作为`B.falselist`。随后先生成指令`if E1 relop E2 goto _`（对应`truelist`），再生成指令`goto _`（对应`falselist`）。
- `B->true`（或`B->false`）：只生成一个包含`nextquad`的列表作为`B.truelist`（或`B.falselist`），并生成指令`goto _`。
- `B->(B1)`：将B1的`truelist`和`falselist`回填到B。
- `B->not B1`：将`B1.truelist`填回`B.falselist`，`B1.falselist`填回`B.truelist`
- `B->B1 or B2`：在推导B1后、B2前记录B2首条指令标号`quad`，推导B2后归约时，用`quad`回填`B1.falselist`，将`B1.truelist`和`B2.truelist`合并作为`B.truelist`，用`B2.falselist`作为`B.falselist`。
- `B->B1 and B2`：在推导B1后、B2前记录B2首条指令标号`quad`，推导B2后归约时，用`quad`回填`B1.truelist`，用`B2.truelist`作为`B.truelist`，将`B1.falselist`和`B2.falselist`合并作为`B.falselist`。

#### 控制流语句的回填

![[Pasted image 20240122215003.png]]

控制流语句有关综合属性：
- `S.nextlist`：指向一个包含跳转指令的列表。这些指令获得的目标标号就是按照运行顺序紧跟在`S`代码之后的指令标号

if-then语句（`S->if B then S1`）回填：
- 在B和S1之间记录当前标号`quad`。
- 在归约时，将`quad`填回`B.truelist`（B为真则执行S1），将`B.falselist`和`S1.nextlist`合并为`S.nextlist`。

![[Pasted image 20240124001747.png]]

if-then-else语句（`S->if B then S1 else S2`）回填：
- 在then和S1之间记录标号`quad1`。
- 在S1和else之间执行`midlist=makelist(nextquad)`，生成指令`goto _`。
- 在else和S2之间记录`quad2`。
- 在归约时，将`quad1`填回`B.truelist`，`quad2`填回`B.falselist`，将`S1.nextlist`、`S2.nextlist`、`midlist`三表合并为`S.nextlist`。

![[Pasted image 20240124001730.png]]

while-do语句（`S->while B do S1`）回填：
- 在while和B之间记录`quad1`，在do和S1之间记录`quad2`。
- 归约时，`quad1`回填`S1.nextlist`，`quad2`回填`B.truelist`，用`B.falselist`作为`S.nextlist`，并生成一条指令`goto quad1`。

![[Pasted image 20240124001815.png]]

顺序语句（`S->S1 S2`）回填：
- 在S1、S2之间记录`quad`。
- 归约时，将`quad`回填`S1.nextlist`，而`S2.nextlist`作为`S.nextlist`。

![[Pasted image 20240124003006.png]]

赋值语句（`S->id=E;|L=E;`）回填：因为不涉及跳转，所以置`S.nextlist=null`。

示例：翻译`while a<b do if c<5 then while x>y do z=x+1 else x=y;`。

![[Pasted image 20240124005003.png]]
![[Pasted image 20240124005026.png]]

### switch语句翻译

![[Pasted image 20240124083102.png]]

翻译方案一：

![[Pasted image 20240124094421.png]]

思路：在每个分支的代码前生成条件跳转语句`if t!=Vk goto Lk`，在代码后生成无条件跳转语句`goto next`。

翻译方案二：

![[Pasted image 20240124094623.png]]

思路：在所有分支之后设立一个`test`代码块用于存放所有条件跳转指令，在每个分支代码后生成无条件跳转语句`goto next`。

case指令：`(CASE,t,V,L)`与`if t==V goto L`等价，但更容易被代码生成器识别（这什么鬼？）

### 过程调用语句翻译

语义分析任务：计算各个实参的值，生成实参列表，最后生成过程调用指令

![[Pasted image 20240124101723.png]]

示例：翻译`f(b*c-1,x+y,x,y)`：
- 计算：`t1=b*c; t2=t1-1; t3=x+y;`。
- 生成实参：`param t2; param t3; param x; param y;`。
- 过程调用：`call f,4`。

## 运行时存储分配

### 概述

**运行存储分配策略**：
- 静态存储分配：编译阶段可确定大小的数据对象，可以在编译期分配内存
- *动态存储分配*：编译阶段不能确定大小，则必须在运行阶段才完成分配，编译期仅产生必要信息
	- 栈式存储分配、堆式存储分配

运行时程序的结构模型：

![[Pasted image 20240124104747.png]]

**活动记录**：
- 背景：以过程作为用户自定义动作的单元的语言，其编译器通常以过程为单位分配存储空间
- *活动*：过程体的每一次执行
- 定义：在过程执行时为它分配的一块临时连续存储区，用于管理过程一次执行所需的所有信息

活动记录的一般形式：

![[Pasted image 20240124105421.png]]

### 静态存储分配

限制条件：数组长度固定、过程不许递归调用、不允许动态建立数据实体

分配方法：顺序分配法、层次分配法

顺序分配法：
- 基本思想：按照过程出现的先后顺序逐段分配存储空间，各过程的活动记录互不相交
- 特点：处理上简单；对内存的使用不够经济合理

![[Pasted image 20240124124200.png]]

层次分配法：
- 基本思想：分析各过程之间的调用关系，对于无相互调用关系的进程，尽量共享空间

![[Pasted image 20240124124819.png]]

层次分配算法：
- 变量：`Units[i]`表示第i进程的分配内存单元数，`base[i]`表示第i进程的基地址，`allocated[i]`为第i进程是否分配局部数据区的标志
- 思路：拓扑排序+动态规划

![[Pasted image 20240124125119.png]]
![[Pasted image 20240124125133.png]]

### 栈式存储分配

思想：当一个过程被调用时，活动记录入栈，过程结束时记录出栈

活动树：
- 定义：描述程序运行期间控制进入和离开各个活动的情况的树
- 结点：树上的每个结点对应一个活动，根节点对应`main`过程的活动

设计活动记录的一些原则：
- 调用者和被调用者间传递的值一般放在被调用者活动记录的*开始位置*，方便调用者管理
- 固定长度的项在*中间位置*：控制链、访问链、机器状态字
- 早期不知道具体大小的项放在*末尾*
- 栈顶指针寄存器指向活动记录中*局部数据开始的位置*，以该位置作为基地址

![[Pasted image 20240124131848.png]]

### 调用序列和返回序列

调用序列：实现过程调用的代码段。为一个活动记录分配栈空间，在此记录的字段中填写信息

![[Pasted image 20240124134159.png]]

返回序列：过程结束时恢复机器状态，使得调用过程可以继续执行的代码段

![[Pasted image 20240124134225.png]]

调用者和被调用者的任务划分：

![[Pasted image 20240124134344.png]]

变长数据的存储分配：
- 非局部对象：堆区分配回收
- 过程的局部对象：运行时刻栈中分配，可以避免回收开销

下列示例中，非定长的数组被放置在调用者p的活动记录尾部，

### 非局部数据的访问

两种情形：
- 支持过程嵌套声明的语言（Python，JS等）：非局部包括*外部方法的局部变量*和全局变量。
- 不支持过程嵌套声明的语言（C/C++，Java等）：非局部变量一般为全局变量。

无过程嵌套声明时的数据访问：
- 全局变量：使用静态确定的地址
- 局部变量：使用`top_sp`加偏移量访问

有过程嵌套声明时的数据访问：
- 嵌套深度：
	- 过程嵌套深度：外部方法深度为1，每嵌套一层加1
	- 变量嵌套深度：即其所在方法的嵌套深度，外部变量为0
- 访问链：相互嵌套过程间的索引指针，使内嵌过程可访问外层过程变量
	- 静态作用域规则：内部过程可访问全局变量和其任何外部过程的局部变量
	- 建立访问链：设调用者`x`深度为`hx`，被调用者`y`深度为`hy`。
		- 外层调用内层：令`hy=hx+1`，在`y`访问链中放一个指向`x`活动记录的指针
		- 本层调用本层：递归调用，直接复制访问链
		- 内层调用外层：沿着活动树找`x`和`y`的最近公共祖先`z`，使`y`访问链指向`z`的活动记录

示例：
- 外调内：`s->q(1,9)`，`q(1,3)->p(1,3)`都是外调内。
- 本调本：`q(1,9)->q(1,3)`是本调本，访问链的上游一致（都是`s`）。
- 内调外：`p(1,3)->e`是内调外。`p,e`最近公共祖先是`s`，所以`e`的访问链指向`s`。

![[Pasted image 20240124145837.png]]
![[Pasted image 20240124145541.png]]

### 符号表

符号表的组织：为每个独立作用域建立一个符号表，包括所有成员变量和直接内层方法

![[Pasted image 20240124153135.png]]

根据符号表进行数据访问：
- 局部名字：查当前过程的符号表，得到偏移值
- 非局部名字：查各级外层过程的符号表

根据符号表构造访问链：通过勾连指针检索，构造规则类似

（美女！）
![[Pasted image 20240124162703.png]]

标识符的基本处理方法：
- 声明语句识别到标识符：查本层符号表
	- 如查到：重复声明，报错
	- 如没查到：加入新登记项，填入标识符和有关信息
- 可执行语句部分识别到标识符：
	- 先查本层符号表，查不到则到上一级去查，一旦找到则取出信息并作相应处理
	- 查遍所有外层符号都没找到，则未声明，报错

符号表的建立：

![[Pasted image 20240124163245.png]]

过程声明语句的SDT：

![[Pasted image 20240124163320.png]]

SDT中的符号及其释义：
- `mktable`、`addwidth`、`enterproc`、`enter`：见图
- 

语义动作解释：
- `P-><M> D`：将

## 代码优化

## 目标代码生成