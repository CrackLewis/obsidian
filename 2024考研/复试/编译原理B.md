
## outline

- 语法制导翻译
- 中间代码生成
- 符号表
- 运行时存储空间组织
- 优化
- 目标代码生成
- 并行编译基础

## 语法制导翻译

语法制导翻译（syntax-driven translation，SDT）=语法分析+语义分析+中间代码生成

语义翻译=语义分析+中间代码生成

任务：语法树->中间代码

### 语法制导翻译概述

语法制导定义（syntax-driven definition，SDD）：
- 每个文法符号和一个语义属性集合关联
- 每个产生式和一组语义规则相关联，这些规则用于计算该产生式中各文法符号的属性值

**属性文法**：
- 定义：对文法每个产生式都给出其语义规则的文法称为*属性文法*。
- 概念：
	- 属性：在上下文无关文法的基础上，在描述语义动作时，为每个文法符号（终结符和非终结符）配备若干相关的值，如类型、地址等，用来表示语法成分对应的语义信息，称为*语义属性*，简称*属性*。
	- 常用属性：`X.type`（X的类型）、`X.cat`（X的类别）、`X.val`（X的值或地址）
	- 语义规则：与文法产生式关联的一组属性计算规则称为*语义规则*，如产生式$A\rightarrow \alpha$的描述形式为`b:=f(c1,c2,...,ck)`，其中`b,c1,c2,...,ck`为文法符号的属性，`f`是一个函数。
	- 翻译模式：适合语法制导翻译的另一种语言翻译的描述形式，它给出了使用语义规则进行计算的次序，以表示出某些实现细节。
- 求值顺序：
	- 综合属性：对于产生式$A\rightarrow \alpha$的语义规则`b:=f(c1,c2,...,ck)`，`b`可以是$A$的*综合属性*，此时`c1,c2,...`是产生式右侧符号的属性，信息自下而上传递。
	- 继承属性：对上述规则，`b`也可以是产生式右侧某符号的*继承属性*，`c1,c2,...`则作为$A$和其他符号的属性，信息自上而下传递。

**语法制导翻译方法**：
- 基本思想：随着语法分析进展，在推导或归约时便执行对应的语义子程序，在完成翻译的同时生成中间代码。
- 实现途径：增强语法分析器功能；分析栈改为语义栈（除状态、符号外加一个数值域）

> [!example] 语法制导翻译举例
> ![[Pasted image 20240114133858.png]]

语法制导翻译全过程：
- 初始：`[0,#,_]`
- 读3，移入：`[0,#,_],[5,d,3]`
- 归约：`[0,#,_],[3,F,3]`
- 归约：`[0,#,_],[2,T,3]`
- 读乘号，移入：`[0,#,_],[2,T,3],[7,*,_]`
- 读5，移入：`[0,#,_],[2,T,3],[7,*,_],[5,d,5]`
- 归约：`[0,#,_],[2,T,3],[7,*,_],[10,F,5]`
- 归约：`[0,#,_],[2,T,15]`
- 归约：`[0,#,_],[1,E,15]`
- 读加号，移入：`[0,#,_],[1,E,15],[6,+,_]`
- 读4，移入：`[0,#,_],[1,E,15],[6,+,_],[5,d,4]`
- 归约：`[0,#,_],[1,E,15],[6,+,_],[3,F,4]`
- 归约：`[0,#,_],[1,E,15],[6,+,_],[9,T,4]`
- 归约：`[0,#,_],[1,E,19]`
- 归约：`[0,#,_],[1,E',19]`

## 中间代码生成

### 中间语言

**后缀式**（逆波兰式）：
- 特点：运算分量的个数和先后次序不变；运算符个数不变，但其出现顺序即执行顺序；无括号。
- 定义：常规式$E_1.op.E_2$对应后缀式$E_1.E_2.op$；后缀式外部的括号可摘除。
- 推广：
	- 三目运算：$e.X.Y.￥$表示在$e\neq 0$时取$X$，$e=0$时取$Y$。
	- 转移指令：无条件跳转：$p.jump$；$e_1<e_2$时跳转：$e_1.e_2.p.jlt$；$e=0$时跳转：$e.p.jez$。

**树**：表达式和子表达式、语句组和语句的关系可以用树形结构描述。

**三地址代码**：
- 一般形式：`x:=y op z`
- 记录结构：
	- 四元式：带有四个域的记录结构`(op,arg1,arg2,result)`
		- 特点：四元式之间通过临时变量联系；单目运算只使用`arg1`；`arg1,arg2,result`是指向符号表的指针。如`(NEGATE,c,_,T1),(MUL,b,T1,T2)`。
	- 三元式：带有三个域的记录结构`(op,arg1,arg2)`
		- 特点：`arg1,arg2`指向符号表或三元式表，取代临时变量。例如`<1>:(NEGATE,c,_),<2>:(MUL,b,<1>)`。
	- 间接三元式：不直接使用三元式表，另开一张间接码表，按运算次序排出三元式的顺序，去除重复三元式。
- 记录结构比较：三元式优化时修改难；间接三元式只需要改间接码表，节省空间；修改四元式表也容易，但临时变量填表占据空间。

### 翻译说明语句

说明语句作用：用关键字定义名字的性质（数据类型），分简单类型说明、数组和记录类型的说明。

语义动作：填符号表、信息向量表、除动态语句外不生成四元式。

**简单类型说明的翻译**：
- 文法：按语义规则写出文法产生式。例如`decl ::= type namelist`，`type ::= INT | FLOAT`，`namelist ::= IDENT | IDENT ',' namelist`。
- 改写文法，节省推导和归约空间
- 在翻译过程中，填写符号表，确定简单类型变量的内存首地址、类别、空间长度信息

**数组说明的翻译**：
- 文法：`arrdecl ::= type IDENT '[' INT ']'`。
- 改写文法，翻译时填写符号表，确定内存首址和长度等信息。
- 对于可变数组：编译时分配信息向量表区，产生分配对应数组空间的四元式；运行时

**保留作用域信息**：
- 对于面向过程语言的每个过程，维护一个符号表，计算各个符号在过程内部的相对地址。
- 如果语言允许嵌套过程（过程体套过程体），则需要在进入嵌套过程时暂停外部过程的符号分析。

### 翻译简单算术表达式和赋值语句

### 翻译布尔表达式

### 翻译控制语句

### 翻译数组元素引用

### 翻译过程调用

