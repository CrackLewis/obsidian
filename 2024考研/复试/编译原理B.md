
## outline

- 语法制导翻译
- 中间代码生成
- 符号表
- 运行时存储空间组织
- 优化
- 目标代码生成
- 并行编译基础

## 语法制导翻译

语法制导翻译（syntax-driven translation，SDT）=语法分析+语义分析+中间代码生成

语义翻译=语义分析+中间代码生成

任务：语法树->中间代码

### 语法制导翻译概述

语法制导定义（syntax-driven definition，SDD）：
- 每个文法符号和一个语义属性集合关联
- 每个产生式和一组语义规则相关联，这些规则用于计算该产生式中各文法符号的属性值

**属性文法**：
- 定义：对文法每个产生式都给出其语义规则的文法称为*属性文法*。
- 概念：
	- 属性：在上下文无关文法的基础上，在描述语义动作时，为每个文法符号（终结符和非终结符）配备若干相关的值，如类型、地址等，用来表示语法成分对应的语义信息，称为*语义属性*，简称*属性*。
	- 常用属性：`X.type`（X的类型）、`X.cat`（X的类别）、`X.val`（X的值或地址）
	- 语义规则：与文法产生式关联的一组属性计算规则称为*语义规则*，如产生式$A\rightarrow \alpha$的描述形式为`b:=f(c1,c2,...,ck)`，其中`b,c1,c2,...,ck`为文法符号的属性，`f`是一个函数。
	- 翻译模式：适合语法制导翻译的另一种语言翻译的描述形式，它给出了使用语义规则进行计算的次序，以表示出某些实现细节。
- 求值顺序：
	- 综合属性：对于产生式$A\rightarrow \alpha$的语义规则`b:=f(c1,c2,...,ck)`，`b`可以是$A$的*综合属性*，此时`c1,c2,...`是产生式右侧符号的属性，信息自下而上传递。
	- 继承属性：对上述规则，`b`也可以是产生式右侧某符号的*继承属性*，`c1,c2,...`则作为$A$和其他符号的属性，信息自上而下传递。

**语法制导翻译方法**：
- 基本思想：随着语法分析进展，在推导或归约时便执行对应的语义子程序，在完成翻译的同时生成中间代码。
- 实现途径：增强语法分析器功能；分析栈改为语义栈（除状态、符号外加一个数值域）

> [!example] 语法制导翻译举例
> ![[Pasted image 20240114133858.png]]

语法制导翻译全过程：
- 初始：`[0,#,_]`
- 读3，移入：`[0,#,_],[5,d,3]`
- 归约：`[0,#,_],[3,F,3]`
- 归约：`[0,#,_],[2,T,3]`
- 读乘号，移入：`[0,#,_],[2,T,3],[7,*,_]`
- 读5，移入：`[0,#,_],[2,T,3],[7,*,_],[5,d,5]`
- 归约：`[0,#,_],[2,T,3],[7,*,_],[10,F,5]`
- 归约：`[0,#,_],[2,T,15]`
- 归约：`[0,#,_],[1,E,15]`
- 读加号，移入：`[0,#,_],[1,E,15],[6,+,_]`
- 读4，移入：`[0,#,_],[1,E,15],[6,+,_],[5,d,4]`
- 归约：`[0,#,_],[1,E,15],[6,+,_],[3,F,4]`
- 归约：`[0,#,_],[1,E,15],[6,+,_],[9,T,4]`
- 归约：`[0,#,_],[1,E,19]`
- 归约：`[0,#,_],[1,E',19]`

## 中间代码生成（旧）

这一部分在原书中讲得颇为混乱，弃坑了。

### 中间语言

**后缀式**（逆波兰式）：
- 特点：运算分量的个数和先后次序不变；运算符个数不变，但其出现顺序即执行顺序；无括号。
- 定义：常规式$E_1.op.E_2$对应后缀式$E_1.E_2.op$；后缀式外部的括号可摘除。
- 推广：
	- 三目运算：$e.X.Y.￥$表示在$e\neq 0$时取$X$，$e=0$时取$Y$。
	- 转移指令：无条件跳转：$p.jump$；$e_1<e_2$时跳转：$e_1.e_2.p.jlt$；$e=0$时跳转：$e.p.jez$。

**树**：表达式和子表达式、语句组和语句的关系可以用树形结构描述。

**三地址代码**：
- 一般形式：`x:=y op z`
- 记录结构：
	- 四元式：带有四个域的记录结构`(op,arg1,arg2,result)`
		- 特点：四元式之间通过临时变量联系；单目运算只使用`arg1`；`arg1,arg2,result`是指向符号表的指针。如`(NEGATE,c,_,T1),(MUL,b,T1,T2)`。
	- 三元式：带有三个域的记录结构`(op,arg1,arg2)`
		- 特点：`arg1,arg2`指向符号表或三元式表，取代临时变量。例如`<1>:(NEGATE,c,_),<2>:(MUL,b,<1>)`。
	- 间接三元式：不直接使用三元式表，另开一张间接码表，按运算次序排出三元式的顺序，去除重复三元式。
- 记录结构比较：三元式优化时修改难；间接三元式只需要改间接码表，节省空间；修改四元式表也容易，但临时变量填表占据空间。

### 翻译说明语句

说明语句作用：用关键字定义名字的性质（数据类型），分简单类型说明、数组和记录类型的说明。

语义动作：填符号表、信息向量表、除动态语句外不生成四元式。

**简单类型说明的翻译**：
- 文法：按语义规则写出文法产生式。例如`decl ::= type namelist`，`type ::= INT | FLOAT`，`namelist ::= IDENT | IDENT ',' namelist`。
- 改写文法，节省推导和归约空间
- 在翻译过程中，填写符号表，确定简单类型变量的内存首地址、类别、空间长度信息

**数组说明的翻译**：
- 文法：`arrdecl ::= type IDENT '[' INT ']'`。
- 改写文法，翻译时填写符号表，确定内存首址和长度等信息。
- 对于可变数组：编译时分配信息向量表区，产生分配对应数组空间的四元式；运行时

**保留作用域信息**：
- 对于面向过程语言的每个过程，维护一个符号表，计算各个符号在过程内部的相对地址。
- 如果语言允许嵌套过程（过程体套过程体），则需要在进入嵌套过程时暂停外部过程的符号分析。

### 翻译简单算术表达式和赋值语句

### 翻译布尔表达式

### 翻译控制语句

### 翻译数组元素引用

### 翻译过程调用

## 中间代码生成

这一部分主要参考了[哈工大编译原理课程](https://www.bilibili.com/video/BV1dL4y1H7T8?p=43&vd_source=4b806a5b4fc9caaf6e7e0cb9bd5da2a0)。

### 类型表达式

下面都是**类型表达式**：
- 基本类型：int、float、char等
- 类型名
- *类型构造符*作用于类型表达式
	- 数组构造符array：`array(length, type)`，如`array(3, int)`、`array(2, array(3, int))`
	- 指针构造符pointer
	- 笛卡尔乘积构造符$\times$
	- 函数构造符$\rightarrow$：$T_1,T_2,\dots,T_n$和$R$是类型表达式，则$T_1\times T_2\times \dots T_n\rightarrow R$也是类型表达式
	- 记录构造符record

> [!example] 类型表达式示例
> 对程序片段：`struct stype { char[8] name; int score; }; stype[50] table; stype* p;`：
> 和`stype`绑定的类型表达式：`record((name*array(8,char))*(score*integer))`
> 和`table`绑定的表达式：`array(50,stype)`
> 和`p`绑定的表达式：`pointer(stype)`

### 声明语句的翻译

语义分析任务：对每个名字，收集类型等信息->分配相对地址。
- 从类型表达式推算*类型宽度*（类型所需存储单元数量）
- 编译时刻，用类型宽度为每个名字分配*相对地址*
- 名字的类型和相对地址信息储存在符号表中

![[Pasted image 20240122152841.png]]

P：起始符号，D：声明列表，T：类型表达式，B：基本类型，C：数组长度后缀

细节：
- 语法符号B、C、T有综合属性`type`（类型表达式）和`width`（类型宽度）
- `offset`：下一个可用的相对地址
- `t`、`w`：将类型和宽度信息从B结点传递到`C->!`结点上
- `enter(id.lexeme, type, offset)`：符号表中填写符号信息

举例1：翻译`real x; int i;`。

![[Pasted image 20240122194810.png]]

举例2：翻译`int[2][3]`。

![[Pasted image 20240122202307.png]]

### 简单赋值语句的翻译

语义分析任务：生成对表达式求值的三地址码序列

![[Pasted image 20240122203527.png]]

S：起始符号，E：子表达式

细节：
- S、E的综合属性`code`记录文法符号对应的三地址码，E的综合属性`addr`记录表达式值的存放地址。
- `lookup(name)`函数查询`name`对应的记录，`gen(code)`函数生成三地址指令，`newtemp()`函数生成一个新的临时变量并返回地址。

增量翻译修正：语法符号不再存储三地址码，而是由全局的增量代码生成方式替代。

![[Pasted image 20240122210639.png]]

举例1：翻译`x=(a+b)*c;`。（详见第46节）

翻译结果：`t1=a+b; t2=t1*c; x=t2;`。

### 数组引用的翻译

语义分析任务：确定数组元素的存放地址

赋值语句的基本文法扩充（蓝字）：

![[Pasted image 20240122212431.png]]

![[Pasted image 20240122213942.png]]

L的综合属性：
- `.type`：数组元素类型
- `.offset`：著是一个临时变量，用于累加公式中的`ij*wj`项（见下面寻址部分），从而计算数组引用的偏移量
- `.array`：数组名在符号表的入口地址

数组元素寻址：
- 一维数组：设`a`首址为`base`、元素宽度`w`，则`a[i]`地址为`base+i*w`。
- 二维数组：设`a`一行的宽度为`w1`、行内元素宽度`w2`，则`a[i1][i2]`地址为`base+i1*w1+i2*w2`。
- k维数组：`a[i1][i2]...[ik]`地址为`base+i1*w1+i2*w2+...+ik*wk`。

示例：翻译`c=a[i1][i2]`可得到下列5行三地址码：
- 偏移值计算：`t1=i1*20`、`t2=i2*4`、`t3=t1+t2`。
- 寻址、赋值：`t4=a[t3]`、`c=t4`。

### 控制流语句、布尔表达式翻译

#### 控制流语句SDT

基本文法：

![[Pasted image 20240122215003.png]]

代码结构：（以if-then-else语句为例）

![[Pasted image 20240122215459.png]]

其中，B、S有如下继承属性，其中指令标号用于标识三地址码：
- `S.next`：存放紧跟在S后的指令标号
- `B.true`：存放B为真时控制流转向的指令标号
- `B.false`：存放B为假时控制流转向的指令标号

SDT：

![[Pasted image 20240123004357.png]]

细节：
- `newlabel()`：生成一个用于存放标号的新临时变量，返回其地址
- `label(L)`：将下一条指令的标号赋给L

![[Pasted image 20240123004540.png]]

![[Pasted image 20240123004655.png]]

![[Pasted image 20240123004732.png]]

#### 布尔表达式SDT

布尔表达式基本文法：

![[Pasted image 20240123004916.png]]

`relop`：6种关系运算符

**逻辑运算符的处理**：翻译为跳转指令。运算符本身不出现在代码中，逻辑表达式值是通过代码序列中的位置表示的。

示例：

![[Pasted image 20240123005418.png]]

SDT：

![[Pasted image 20240123010056.png]]

![[Pasted image 20240123010600.png]]

![[Pasted image 20240123010620.png]]

#### 控制流的一个示例

SDT的通用实现方法：先建立语法树，再按从左到右深度优先的顺序执行语义动作

翻译语句`while a<b do if c<d then x=y+z else x=y-z`。

![[Pasted image 20240123011105.png]]

![[Pasted image 20240123102837.png]]

要点：处理好布尔表达式`.true`、`.false`属性和控制流`.next`属性的关系。

#### 布尔表达式回填

布尔表达式和控制流语句代码生成的关键问题：确定跳转指令的目标标号

回填思想：在生成跳转指令时暂不指定目标标号，而是放入该目标标号对应的列表中

**布尔表达式的综合属性**：
- `B.truelist`：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是当表达式为真时控制流应当转向的指令标号
- `B.falselist`：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是当表达式为假时控制流应当转向的指令标号
- 有关操作：`makelist(i)`（创建一个只包含标号i的列表）、`merge(p1,p2)`（合并两个列表）、`backpatch(p,i)`（将i作为目标标号插入p内各指令）

truelist和falselist的设置思路：
- `B->E1 relop E2`：生成一个只包含`nextquad`（下条指令标号）的列表作为`B.truelist`，以及一个只包含`nextquad+1`的列表作为`B.falselist`。随后先生成指令`if E1 relop E2 goto _`（对应`truelist`），再生成指令`goto _`（对应`falselist`）。
- `B->true`（或`B->false`）：只生成一个包含`nextquad`的列表作为`B.truelist`（或`B.falselist`），并生成指令`goto _`。
- `B->(B1)`：将B1的`truelist`和`falselist`回填到B。
- `B->not B1`：将`B1.truelist`填回`B.falselist`，`B1.falselist`填回`B.truelist`
- `B->B1 or B2`：在推导B1后、B2前记录B2首条指令标号`quad`，推导B2后归约时，用`quad`回填`B1.falselist`，将`B1.truelist`和`B2.truelist`合并作为`B.truelist`，用`B2.falselist`作为`B.falselist`。
- `B->B1 and B2`：在推导B1后、B2前记录B2首条指令标号`quad`，推导B2后归约时，用`quad`回填`B1.truelist`，用`B2.truelist`作为`B.truelist`，将`B1.falselist`和`B2.falselist`合并作为`B.falselist`。

#### 控制流语句的回填

![[Pasted image 20240122215003.png]]

控制流语句有关综合属性：
- `S.nextlist`：指向一个包含跳转指令的列表。这些指令获得的目标标号就是按照运行顺序紧跟在`S`代码之后的指令标号

if-then语句（`S->if B then S1`）回填：
- 在B和S1之间记录当前标号`quad`。
- 在归约时，将`quad`填回`B.truelist`（B为真则执行S1），将`B.falselist`和`S1.nextlist`合并为`S.nextlist`。

![[Pasted image 20240124001747.png]]

if-then-else语句（`S->if B then S1 else S2`）回填：
- 在then和S1之间记录标号`quad1`。
- 在S1和else之间执行`midlist=makelist(nextquad)`，生成指令`goto _`。
- 在else和S2之间记录`quad2`。
- 在归约时，将`quad1`填回`B.truelist`，`quad2`填回`B.falselist`，将`S1.nextlist`、`S2.nextlist`、`midlist`三表合并为`S.nextlist`。

![[Pasted image 20240124001730.png]]

while-do语句（`S->while B do S1`）回填：
- 在while和B之间记录`quad1`，在do和S1之间记录`quad2`。
- 归约时，`quad1`回填`S1.nextlist`，`quad2`回填`B.truelist`，用`B.falselist`作为`S.nextlist`，并生成一条指令`goto quad1`。

![[Pasted image 20240124001815.png]]

顺序语句（`S->S1 S2`）回填：
- 在S1、S2之间记录`quad`。
- 归约时，将`quad`回填`S1.nextlist`，而`S2.nextlist`作为`S.nextlist`。

![[Pasted image 20240124003006.png]]

赋值语句（`S->id=E;|L=E;`）回填：因为不涉及跳转，所以置`S.nextlist=null`。

示例：翻译`while a<b do if c<5 then while x>y do z=x+1 else x=y;`。

![[Pasted image 20240124005003.png]]
![[Pasted image 20240124005026.png]]

### switch语句翻译

![[Pasted image 20240124083102.png]]

翻译方案一：

![[Pasted image 20240124094421.png]]

思路：在每个分支的代码前生成条件跳转语句`if t!=Vk goto Lk`，在代码后生成无条件跳转语句`goto next`。

翻译方案二：

![[Pasted image 20240124094623.png]]

思路：在所有分支之后设立一个`test`代码块用于存放所有条件跳转指令，在每个分支代码后生成无条件跳转语句`goto next`。

case指令：`(CASE,t,V,L)`与`if t==V goto L`等价，但更容易被代码生成器识别（这什么鬼？）

### 过程调用语句翻译

语义分析任务：计算各个实参的值，生成实参列表，最后生成过程调用指令

![[Pasted image 20240124101723.png]]

示例：翻译`f(b*c-1,x+y,x,y)`：
- 计算：`t1=b*c; t2=t1-1; t3=x+y;`。
- 生成实参：`param t2; param t3; param x; param y;`。
- 过程调用：`call f,4`。

## 运行时存储分配

### 概述

**运行存储分配策略**：
- 静态存储分配：编译阶段可确定大小的数据对象，可以在编译期分配内存
- *动态存储分配*：编译阶段不能确定大小，则必须在运行阶段才完成分配，编译期仅产生必要信息
	- 栈式存储分配、堆式存储分配

运行时程序的结构模型：

![[Pasted image 20240124104747.png]]

**活动记录**：
- 背景：以过程作为用户自定义动作的单元的语言，其编译器通常以过程为单位分配存储空间
- *活动*：过程体的每一次执行
- 定义：在过程执行时为它分配的一块临时连续存储区，用于管理过程一次执行所需的所有信息

活动记录的一般形式：

![[Pasted image 20240124105421.png]]

### 静态存储分配

限制条件：数组长度固定、过程不许递归调用、不允许动态建立数据实体

分配方法：顺序分配法、层次分配法

顺序分配法：
- 基本思想：按照过程出现的先后顺序逐段分配存储空间，各过程的活动记录互不相交
- 特点：处理上简单；对内存的使用不够经济合理

![[Pasted image 20240124124200.png]]

层次分配法：
- 基本思想：分析各过程之间的调用关系，对于无相互调用关系的进程，尽量共享空间

![[Pasted image 20240124124819.png]]

层次分配算法：
- 变量：`Units[i]`表示第i进程的分配内存单元数，`base[i]`表示第i进程的基地址，`allocated[i]`为第i进程是否分配局部数据区的标志
- 思路：拓扑排序+动态规划

![[Pasted image 20240124125119.png]]
![[Pasted image 20240124125133.png]]

### 栈式存储分配

思想：当一个过程被调用时，活动记录入栈，过程结束时记录出栈

活动树：
- 定义：描述程序运行期间控制进入和离开各个活动的情况的树
- 结点：树上的每个结点对应一个活动，根节点对应`main`过程的活动

设计活动记录的一些原则：
- 调用者和被调用者间传递的值一般放在被调用者活动记录的*开始位置*，方便调用者管理
- 固定长度的项在*中间位置*：控制链、访问链、机器状态字
- 早期不知道具体大小的项放在*末尾*
- 栈顶指针寄存器指向活动记录中*局部数据开始的位置*，以该位置作为基地址

![[Pasted image 20240124131848.png]]

### 调用序列和返回序列

调用序列：实现过程调用的代码段。为一个活动记录分配栈空间，在此记录的字段中填写信息

![[Pasted image 20240124134159.png]]

返回序列：过程结束时恢复机器状态，使得调用过程可以继续执行的代码段

![[Pasted image 20240124134225.png]]

调用者和被调用者的任务划分：

![[Pasted image 20240124134344.png]]

变长数据的存储分配：
- 非局部对象：堆区分配回收
- 过程的局部对象：运行时刻栈中分配，可以避免回收开销

下列示例中，非定长的数组被放置在调用者p的活动记录尾部，

### 非局部数据的访问

两种情形：
- 支持过程嵌套声明的语言（Python，JS等）：非局部包括*外部方法的局部变量*和全局变量。
- 不支持过程嵌套声明的语言（C/C++，Java等）：非局部变量一般为全局变量。

无过程嵌套声明时的数据访问：
- 全局变量：使用静态确定的地址
- 局部变量：使用`top_sp`加偏移量访问

有过程嵌套声明时的数据访问：
- 嵌套深度：
	- 过程嵌套深度：外部方法深度为1，每嵌套一层加1
	- 变量嵌套深度：即其所在方法的嵌套深度，外部变量为0
- 访问链：相互嵌套过程间的索引指针，使内嵌过程可访问外层过程变量
	- 静态作用域规则：内部过程可访问全局变量和其任何外部过程的局部变量
	- 建立访问链：设调用者`x`深度为`hx`，被调用者`y`深度为`hy`。
		- 外层调用内层：令`hy=hx+1`，在`y`访问链中放一个指向`x`活动记录的指针
		- 本层调用本层：递归调用，直接复制访问链
		- 内层调用外层：沿着活动树找`x`和`y`的最近公共祖先`z`，使`y`访问链指向`z`的活动记录

示例：
- 外调内：`s->q(1,9)`，`q(1,3)->p(1,3)`都是外调内。
- 本调本：`q(1,9)->q(1,3)`是本调本，访问链的上游一致（都是`s`）。
- 内调外：`p(1,3)->e`是内调外。`p,e`最近公共祖先是`s`，所以`e`的访问链指向`s`。

![[Pasted image 20240124145837.png]]
![[Pasted image 20240124145541.png]]

### 符号表

符号表的组织：为每个独立作用域建立一个符号表，包括所有成员变量和直接内层方法

![[Pasted image 20240124153135.png]]

根据符号表进行数据访问：
- 局部名字：查当前过程的符号表，得到偏移值
- 非局部名字：查各级外层过程的符号表

根据符号表构造访问链：通过勾连指针检索，构造规则类似

（美女！）
![[Pasted image 20240124162703.png]]

标识符的基本处理方法：
- 声明语句识别到标识符：查本层符号表
	- 如查到：重复声明，报错
	- 如没查到：加入新登记项，填入标识符和有关信息
- 可执行语句部分识别到标识符：
	- 先查本层符号表，查不到则到上一级去查，一旦找到则取出信息并作相应处理
	- 查遍所有外层符号都没找到，则未声明，报错

符号表的建立：

![[Pasted image 20240124163245.png]]

过程声明语句的SDT：

![[Pasted image 20240124163320.png]]

SDT中的符号及其释义：
- `mktable`、`addwidth`、`enterproc`、`enter`：见图
- `tblptr`：维护各级符号表指针的一个栈
- `offset`：维护各级符号表偏移量的一个栈

语义动作解释：
- `P-><M> D`：先创建一个前驱为`null`的空符号表`t`，并将`<0,t>`入栈；再解析`D`；最后将`top[offset]`设置为符号表`top[tblptr]`内所有符号项的宽度和，并将它们弹出。对应全局符号表的解析过程。
- `D->D1 D2`：顺序翻译`D1,D2`即可。
- `Dp->proc id; <N> D1 S`：创建一个前驱为`top[tblptr]`的空符号表`t`，将`<0,t>`入栈；依次解析`D1,S`；最后填符号表全宽，弹出`<width,t>`，在上一级过程的符号表中填入子过程项`<id,t>`。
  - `Dv->id: T;`：当前符号表中填变量项`<id,T.type,top[offset]>`，并设置`top[offset]<-top[offset]+T.width`。

![[Pasted image 20240125013657.png]]

## 代码优化

任务：对代码进行等价变换，增强代码的运行效率

### 流图

基本块：满足以下条件的三地址指令序列
- 入口条件：控制流只能从第一个指令进入该块，没有其他入口
- 出口条件：除了基本块的最后一个指令外，控制流在离开基本块前不会跳转或停机

基本块划分算法：
- 输入：三地址指令序列
- 输出：输入序列对应的基本块列表，其中每个指令恰好被分配给一个基本块
- 方法：
	- 确定首指令：指令序列首个指令、跳转目标指令、跳转指令后的第一条指令
	- 每个首指令及其后直到后一条首指令之前的所有指令归属于一个基本块

示例：下面是快速排序函数的一段指令序列。其中：
- 1号指令是首指令。
- 5、9、23号指令作为跳转目标指令而成为首指令。
- 9、13、14、23号指令作为跳转指令后第一条指令而成为首指令。
- 去除重复，则1、5、9、13、14、23号指令是首指令，对应1-4、5-8、9-12、13、14-22、23-30总计6个基本块。

![[Pasted image 20240125100416.png]]

流图：
- 以基本块为结点的有向图
- 基本块B到C之间有边，当且仅当C的首条指令*可能*紧随B的最后一条指令之后执行，此时称B是C的*前驱*，C是B的*后继*
- 确认边的两种方式：
	- 有一条B末尾到C开头的跳转语句
	- C紧跟B后，且B末尾没有无条件跳转语句

示例：刚才那个例子可以如下图这样确定连接关系

![[Pasted image 20240125102117.png]]
![[Pasted image 20240125102700.png]]

### 常用代码优化方案

优化分类：
- 机器无关优化：针对中间代码
- 机器相关优化：针对目标代码
- 局部代码优化：单个基本块范围内的优化
- 全局代码优化：面向多个基本块的优化

常用优化方法：
- 删除公共子表达式
- 删除无用代码
- 常量合并
- 代码移动
- 强度削弱
- 删除归纳变量

#### 删除公共子表达式

原理：如果`x op y`先前被计算过，且`x,y`都没改变过，则`x op y`的再次出现称为*公共子表达式*。公共子表达式不必占据多个临时变量，在`x,y`修改之前只需要计算一次。

例：

![[Pasted image 20240125151107.png]]

图中的B5在优化前有9条指令。通过块内检查得知`t7`、`t10`分别与`t6`、`t8`重复，所以进行删除替换。结果如黄框所示。

![[Pasted image 20240125151306.png]]

局部优化后B5剩下7条指令。通过“逆流而上”分析知，`t6`、`t8`分别与到达B5的必经之路B2、B3中的`t2`、`t4`重复，所以进行删除替换。结果如黄框所示。

![[Pasted image 20240125152809.png]]

同理，`a[t2]`、`a[t4]`也是公共子表达式，可以将`t9`删除替换，剩4条指令。

**注意：** 数组元素形式的表达式往往容易被误认为是公共子表达式，但实际上随着控制流变化，对数组任意元素的修改可能会波及对公共子表达式的修改。

（如何自动识别公共子表达式？后面章节介绍）

#### 删除无用代码

原理：删除公共子表达式等优化方法会引入一些复制语句（如`x=y`），这种赋值语句在`x`再次赋值前没有意义，相当于给`y`指定一个别名`x`，因此可以通过将该区段的`x`全部替换为`y`实现优化。

复制传播：在`x=y`后尽可能用`y`替代`x`。

![[Pasted image 20240125205944.png]]

无用代码：计算结果永远不会使用的语句。

例：下图B5、B6中`x=t3`都是无用代码。

![[Pasted image 20240126002209.png]]

（如何自动识别无用代码？后面章节）

#### 常量合并

原理：如果编译期推导出一个表达式的值是常量，则可以使用常量代替这个表达式。

例如：臭名昭著的5050case

![[Pasted image 20240126003750.png]]

#### 代码移动

原理：如果某个表达式的计算是循环不变的（loop-invariant），即不管循环多少次结果都一致，则可以考虑在循环外就求好值。

![[Pasted image 20240126005113.png]]

循环不变计算的相对性：在多重嵌套循环中，循环不变可能是相对某个循环而言的，对于外层循环未必是循环不变计算。

例如：

![[Pasted image 20240126011117.png]]

#### 强度削弱

原理：用较快的运算代替较慢的运算，如：位移和加法代替乘法，多项式分解，矩阵快速幂等。

循环中的强度削弱：
- 归纳变量：如果循环中存在常数`c`，使得`x`每次赋值时必变化`c`（即`x=x+c`），则称`x`为归纳变量（induction variable）
- 方法：统一转化为增量运算

例：`i,t2,t4`都是归纳变量，可以转化为增量运算

![[Pasted image 20240126013301.png]]

进一步，如果循环内存在不止一个归纳变量，则通常可以简化为只有一个，称为**删除归纳变量**。对于上例，可以考虑去掉`i,j`而只留`t2,t4`，跳转条件更正为`t2>=t4`。

### 基本块的优化

优化思路：先将基本块转化为DAG图，再谈优化。

#### 基本块的DAG表示

基本块中的每个语句s都对应一个内部结点N：
- 结点N的标号是s中的*运算符*；同时还有一个*定值变量表*被关联到N ，表示s是在此基本块内最晚对表中变量进行定值的语句
- N的子结点是基本块中在s之前、最后一个对s所使用的运算分量进行定值的语句对应的结点。如果s的某个运算分量在基本块内没有在s之前被定值，则这个运算分量对应的子结点就是代表该运算分量初始值的叶结点（为区别起见，叶节点的定值变量表中的变量加上下脚标0）
- 在为语句`x=y+z`构造结点N时，如果x已经在某结点M的定值变量表中，则从M的定值变量表中删除变量x

例：对基本块`a=b+c; b=a-d; c=b+c; d=a-d;`，可以如下构造DAG：

![[Pasted image 20240126090948.png]]

其中：`b=a-d`和`d=a-d`复用了`a,d0`结点。

#### 基于基本块DAG删除无用代码

活跃变量：变量值可能会在后续被使用的变量 ^4bf8a4

动作：删除所有没有附加活跃变量的根结点。这些结点对应一条*无用代码*，反复清除这类结点即可消除无用代码。

例：假如基本块的后续块会使用`a,b`。那么`a,b`都是活跃变量，`c,e`不是活跃变量，可以移除对应结点。

![[Pasted image 20240126114801.png]]

#### 数组元素赋值指令的表示

特别情形：考虑基本块`x=a[i]; a[j]=y; z=a[i];`。注意这个例子中`a[i]`*不是*公共子表达式，因为`a[j]=y`指令会在`i==j`时修改`a[i]`。

**数组元素赋值指令的表示**：
- 方法：对于形如`a[j]=y`的指令，把取数组元素和赋值两步结合，设置一个运算符为`[]=`的结点，其有3个子结点`a,j,y`。
- 特点：该结点无定值变量表；该结点的创建会杀死所有已经建立的，其值依赖于`a`的结点；一个被杀死的结点不会再获得任何定值变量，即不可能成为一个公共子表达式。

![[Pasted image 20240126123205.png]]

#### 从DAG获得基本块的部分信息

根据基本块的DAG可以获得如下信息：
- 哪些变量的值在该基本块中赋值前被引用过：DAG中创建了叶结点的那些变量
- 哪些语句计算的值可以在基本块外被引用：在DAG构造过程中为语句s（该语句为变量x定值）创建的结点N，在DAG构造结束时x仍然是N的定值变量

#### 从DAG到基本块的重组

对每个具有若干定值变量的结点，构造一个三地址语句计算其中某个变量的值。

倾向于把计算得到的结果赋给一个在基本块*出口处活跃*的变量（如果没有全局活跃变量的信息作为依据，就要假设所有变量都在基本块出口处活跃，但是不包含编译器为处理表达式而生成的临时变量）。

如果结点有多个附加的活跃变量，就必须引入复制语句，以便给每一个变量都赋予正确的值。

![[Pasted image 20240126130000.png]]

### 数据流分析

数据流分析：一组用来获取程序执行路径上数据流信息的技术

特点：每个程序点都会和一个数据流值关联起来

应用：
- 到达-定值分析（reaching-definition analysis）
- 活跃变量分析（live-variable analysis）
- 可用表达式分析（available-expression analysis）

**语句数据流模式**：
- `IN[s]`：语句s之前的数据流值
- `OUT[s]`：语句s之后的数据流值
- `f[s]`：语句s的*传递函数*
	- 表示一个赋值语句s之前和之后的数据流值的关系
	- 两种风格：前向数据流（`IN->OUT`）、逆向数据流（`OUT->IN`）
	- 块内相邻语句`s; t;`的数据流值关系：`IN[t]=OUT[s]`。

**基本块的数据流模式**：
- `IN[B]`：紧靠基本块B之前的数据流值
- `OUT[B]`：紧随基本块B之后的数据流值
- `f[B]`：基本块B的传递函数
	- 两种风格：前向/逆向
- 与语句数据流的关系：设语句序列为`s1,s2,...,sn`，对应的传递函数为`f1,f2,...,fn`。
	- `IN[B]=IN[s1]`，`OUT[B]=OUT[sn]`。
	- `OUT[B]=OUT[sn]=fn(fn-1(...(f2(f1(IN[s1])))...))`。

### 到达定值分析

定值（definition）：变量`x`的定值是（可能）将一个值赋给`x`的语句。

“生成”和“杀死”定值：一个对变量`x`的定值`d`（`d: x=val;`）会
- 生成对变量`x`的定值`d`
- 杀死程序中其它对`x`的定值

到达定值（reaching definition）：
- 定值“杀死”定值：对于变量`x`及其定值`d`，如果在程序点`p`之前、定值`d`后有其它定值`d'`，则称定值`d'`“杀死”了定值`d`。（例：`x=d; ...; x=d'; ...; p:`）
- 定值到达程序点：如果存在一条从紧跟在定值`d`后面的点到达某一程序点`p`的路径，且不存在“杀死”`d`的定值，则称定值`d`到达程序点`p`。
- 如果变量`x`的定值`d`到达程序点`p`，则`p`处使用的`x`值*可能*是由`d`最后赋予的。（考虑其他分支存在，所以不是*一定*）

例：以`d1`为例，它能到达`B2`，但`d4`对`i`的重新赋值在到`B3`、`B4`的路上杀死了`d1`，所以`d1`只能到达`B2`。其他同理。

![[Pasted image 20240126143055.png]]

主要用途：
- 循环不变计算的检测
- 常量合并
- 判定未经定值便引用的情形
- etc.

**到达定值的传递函数**：脑子炸了，看课件吧

![[Pasted image 20240126151947.png]]

例：`gen`和`kill`会记录其基本块杀死的所有定值，无论它们的逻辑顺序如何。最显著的就是`B1`杀死`d4,d5,d6,d7`。

![[Pasted image 20240126152012.png]]

**到达定值的数据流方程**：

![[Pasted image 20240126153838.png]]

### 到达定值方程的计算

**计算到达定值的迭代算法**：
- 输入：程序流图G，包括每个基本块及其`gen`和`kill`集合
- 输出：`IN[B]`、`OUT[B]`。
- 思路：先置所有的`OUT[Bi]=OUT[ENTRY]=!`，再不断根据定义更新`IN[Bi],OUT[Bi]`直至其收敛。

迭代算法的伪代码：

```
for (B in basic_blocks) OUT[B] = set();
while (OUT is modified) {
    for (B in basic_blocks) {
        if (B is ENTRY) continue;
        IN[B] = union(OUT[P] for P in B.prefixes())
        OUT[B] = union(gen[B], IN[B] - kill[B])
    }
}
```

例：

![[Pasted image 20240126203527.png]]

**引用-定值链**（use-definition chains）：
- 定义：一个列表，对变量的每一次引用，到达该引用的所有定值都在该列表中
	- 如果块B内在引用a前有定值：a的最后一次定值会出现在UD链中
	- 如果块B内在引用a前无定值：引用的UD链是`IN[B]`中a定值的集合

### 活跃变量分析

回顾概念：
- [[编译原理B#^4bf8a4|活跃变量]]：变量值可能会在后续被使用的变量

变量的活跃性在流图中的体现：对于变量`x`和程序点`p`，若从`p`开始的某条路径会引用`x`在`p`处的值，则称`x`在点`p`处活跃，否则`x`在点`p`处不活跃。

例：

![[Pasted image 20240126210103.png]]

活跃变量信息主要用途：
- 删除*无用赋值*：如果`x`在`p`的定值在基本块内所有后继点都不被引用，出口之后也不活跃，则该定值无用
- 为基本块分配寄存器：非活跃变量不应在结尾占据寄存器

**活跃变量传递函数**：
- 逆向数据流问题：`IN[B]=fB(OUT[B])`。
- 传递函数：$f_B(x)=use_B \cup (x-def_B)$。
	- $def_B$：在B中定值，但定值前在B中没被引用的变量集合
	- $use_B$：在B中引用，但引用前在B中没被定值的变量集合

例子：

![[Pasted image 20240126223531.png]]

活跃变量数据流方程：

![[Pasted image 20240126224645.png]]

**计算活跃变量的迭代算法**：
- 输入：已计算`use`和`def`的流图G；输出：`IN[B],OUT[B]`
- 方法：初始置`IN[Bi]=IN[EXIT]=!`，随后不断运用数据流方程调整`IN[B],OUT[B]`直至其收敛。

例：

![[Pasted image 20240127005644.png]]
![[Pasted image 20240127005707.png]]

**定值-引用链**（definition-use chains）：

![[Pasted image 20240127005754.png]]

### 可用表达式分析

可用表达式：
- 条件·：
	- 从流图首结点到程序点p的每条路径都对`x op y`进行计算
	- 每条路径的最后一次计算到p之间，`x,y`都没有重新定值
- 直观意义：在点p上，`x op y`被计算过且无需重复计算

可用表达式主要用途：
- 消除全局公共子表达式
- 进行复制传播

可用表达式的传递函数：
- `e_gen[B]`计算：对B中每个语句`z=x op y`，先把`x op y`加入`e_gen[B]`，再把`e_gen[B]`中所有包含`z`的表达式删除
- `e_kill[B]`：对B中每个语句`z=x op y`，先从`e_kill[B]`中删除`x op y`，再把所有和`z`相关的表达式加入到`e_kill[B]`中

![[Pasted image 20240127095124.png]]

可用表达式的数据流方程：

![[Pasted image 20240127111653.png]]

计算可用表达式的迭代算法：
- 输入：计算了`e_gen`和`e_kill`的流图G；输出：`IN[B],OUT[B]`
- 思路：初始置`OUT[Bi]=U`，随后按照数据流方程不断迭代更新`IN[Bi],OUT[Bi]`直至其收敛
- 初始化为`U`的原因：初始化为`!`局限性太大

### 支配结点和回边

支配结点（dominators）：从流图入口到结点`n`的每条路径都经过结点`d`，则称`d`*支配*`n`，简记为`d dom n`。

支配结点树：流图的各级支配结点可以形成层级关系，从而用树来描述
- 直接支配结点（immediate dominator）：`n`的各级支配结点中的最低一级。

例：

![[Pasted image 20240127115512.png]]

寻找支配结点：

![[Pasted image 20240127121652.png]]

计算支配结点的迭代算法：
- 输入：流图`G=(N,E)`；输出：对每个结点`n`给出其支配结点集合`D(n)`
- 方法：初始置`OUT[ENTRY]={ENTRY},OUT[Bi]=N`（整个点集），再根据方程不断迭代`IN[Bi],OUT[Bi]`直至收敛

例：下面的流图可以如下计算。

![[Pasted image 20240127123944.png]]

回边（back edges）：若`d dom n`，且存在有向边`<n,d>`，则称`<n,d>`为回边。 ^33e520

![[Pasted image 20240127124555.png]]

### 自然循环及其识别

**自然循环**（natural loops）的定义：
- 有唯一的入口结点，称为*首结点*
- 循环中至少有一条返回首结点的路径

研究自然循环的意义：自然循环方便优化

识别自然循环：给定一个[[编译原理B#^33e520|回边]]`<n,d>`，其自然循环为`d`以及所有可不经过`d`而到达`n`的结点，`d`为循环的首结点。

例：

![[Pasted image 20240127142014.png]]

构造回边自然循环的算法：

![[Pasted image 20240127142504.png]]

自然循环的一个重要性质：两个自然循环必满足以下三种情形之一：
- 首结点相同
- 首结点不同，互不相交
- 首结点不同，一个嵌入在另一个之中

以刚才的图为例：各级循环相互包含。

![[Pasted image 20240127142014.png]]

最内循环：不包含其他循环的循环
- 如果两个循环的首结点相同，则可以考虑合并两个循环的其余部分

### 删除全局公共子表达式和复制语句



### 代码移动

### 作用于归纳变量的强度削弱

### 归纳变量的删除

### 总结

此章内容颇多，细节十分琐碎，下面是一个自检引用表：



## 目标代码生成