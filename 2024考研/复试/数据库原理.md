
参考资料：
- 数据库系统概念（中文第六版）
- [博客](https://blog.csdn.net/weixin_45591044/article/details/106350680)
- [关系代数详解](https://blog.csdn.net/JavaEEKing/article/details/109223552)
- [函数依赖（人话版）](https://blog.csdn.net/Jeremy_Tsang/article/details/108949656)
- [各个范式的区分，Armstrong公理系统](https://blog.csdn.net/aiHYQ/article/details/107871381)

## outline

- 概述
- 关系数据库
- 数据库设计
- 数据库应用设计、开发（略）
- 大数据分析
- 数据存储和索引
- 查询处理和优化

## 概述
 
基本概念：
- 数据
- 数据库
- 数据库管理系统（DBMS）：位于用户和操作系统之间的一层数据管理软件
- 数据定义语言（DDL）
- 数据操作语言（DML）
- 数据库系统（DBS）

数据库管理技术发展历程：人工管理阶段、文件系统阶段、数据库系统阶段

数据模型：
- 分类：概念模型、逻辑模型和物理模型
- 组成要素：数据结构、数据操作、完整性约束条件

逻辑模型分类：
- 非关系模型：
	- 层次模型：整个数据库呈树状结构
	- 网状模型：整个数据库呈图状结构
- 关系模型

关系模型术语：
- 关系：对应一张数据表
- 属性：数据表的一列
- 域：属性的取值范围
- 元组：数据表的一行
- 码（码键）：数据表的某个属性组，可以唯一确定一个元组
- 分量：元组中的一个属性值
- 关系模式：对关系的描述，一般描述为`relation(attr1,attr2,...)`

实体-关系（entity-relationship，E-R）图：
- 实体型：矩形，标实体名
- 属性：与其归属实体型代表的矩形相连的椭圆，标属性名
- 联系：连接两个矩形的菱形，标联系名和联系类型（`1:1`、`1:n`、`m:n`）

数据库系统结构：
- 模式（逻辑模式）：数据库中*全体数据*逻辑结构和特征的描述
	- 地位：与存储细节和开发环境无关
- 外模式（子模式、用户模式）：数据库*用户局部数据*的逻辑结构和特征的描述
	- 用途：保证数据库安全性
- 内模式（存储模式）：数据*物理结构和存储方式*的描述
	- 细节：记录存储方式、索引组织方式、压缩存储、加密、存储记录结构规定

![[Pasted image 20240202112824.png]]

## 关系数据库

### 关系数据结构和形式化定义

**域**（domain）：一组具有相同数据类型的值的集合。例如整数、自然数、实数都是域。

**笛卡尔积**（cartesian product）：域内的一种集合运算，一组域$D_1,D_2,\dots,D_n$的笛卡尔积为：
$$
D_1\times D_2\times \dots \times D_n=\{(d_1,d_2,\dots,d_n)|d_i\in D_i,i=1,2,\dots, n\}
$$
笛卡尔积的每个元素$(d_1,d_2,\dots,d_n)$称为一个$n$元组，简称**元组**。笛卡尔积可表示为一个$\displaystyle\left(\prod_{i=1}^n |D_i|\right)\times n$的二维表，每行表示一个元组，每列表示一个域。

**关系**（relation）：$D_1\times D_2\times \dots\times D_n$的子集叫作在域$D_1,D_2, \dots,D_n$上的关系，表示为$R(D_1,D_2,\dots,D_n)$。其中：$R$为*关系名*，$n$为关系的目或*度*（degree）。
- 表示：可表示为一个$m\times n$的二维表，其中$1\le m\le \displaystyle\prod_{i=1}^n |D_i|$。
- 码键：
	- *候选码*（candidate key）：能唯一标识一个元组的属性组合。
	- *主码*（primary key）：被选定用于标识元组的候选码
	- *主属性*（primary attribute）：被至少一个候选码包含的属性。不包含于任何候选码的属性称为*非主属性*。
	- *全码*（all-key）：关系模式的所有属性都是主属性。

### 关系操作

常用关系操作：
- 增（insert）、删（delete）、改（update）
- 查（query）：
	- 5类基本操作：选择（select）、投影（project）、并（union）、差（except）、笛卡尔积（produce）
	- 扩展操作：连接（join）、除（divide）、交（intersect）

### 关系完整性

3类完整性约束：
- 实体完整性（entity integrity）：以主码作为唯一性标识，主属性不能为空值
- 参照完整性（referential integrity）：外码
- 用户自定义完整性（user-defined integrity）：反映某一具体应用所涉及的数据必须满足的语义要求

### 关系代数

#### 选择运算

选择运算：从关系$R$中选取使逻辑表达式$F$为真的元组。运算只针对行，不会影响列。

例如：查询所有计算机系的学生：$\sigma_{dept='CS'}(Student)$。

![[Pasted image 20240202125955.png]]

#### 投影运算

投影运算：选取原关系的部分列，组成一个新的关系。运算可能会因为取消了部分主属性列，而去除部分重复的行（因为元组不允许重复）。

例如：取全体学生的姓名和院系信息：$\pi_{name,dept}(Student)$。

![[Pasted image 20240202130341.png]]

#### 连接运算：一般连接、等值连接、自然连接

连接运算：从两个关系的笛卡尔积中选取属性间满足一定条件的元组。
- 一般连接：条件任意
- 等值连接：条件指定两个关系的*某一对属性组*相等
- 自然连接：特殊的等值连接，要求两个关系中*名称相同的属性组*相等

![[Pasted image 20240203115030.png]]

![[Pasted image 20240203115042.png]]

![[Pasted image 20240203115055.png]]

悬浮元组：自然连接$R\Join S$中，若$R$（或$S$）中某些元组在$R,S$公共属性上的值不与$S$（或$R$）中任何元组相等，导致在自然连接积中被舍弃，则称这些元组为*悬浮元组*。

外连接（outer join）：在自然连接中保存悬浮元组，置其新属性的数值为空。
- 左外连接：只保留左边关系$R$中的悬浮元组
- 右外连接：只保留右边关系$S$中的悬浮元组

#### 除运算

除运算：对关系$R,S$而言，除运算$R\div S$包括$R$的非公共属性列，其内所有元组满足其在$R$中的原元组的公共属性与$S$内的记录匹配。

![[Pasted image 20240203121040.png]]

## SQL

### 基本概念、专有名词

![[Pasted image 20240203133051.png]]

**基本表**：对应一个关系。

**索引**：基本表的内部数据结构，可以加快查询速度，属于内模式细节。
- 唯一索引：使用`unique`关键字
- 非唯一索引：不使用`unique`关键字
- 聚簇索引：索引项的顺序与表中记录的物理顺序一致的索引组织。最经常查询的列（如主键）可使用聚簇索引

**视图**：从一个或几个基本表（或视图）导出的表，只存放定义不存放数据，查询时重新计算。

视图作用：简化用户操作、使用户能以多种角度来看待同一数据、对重构数据库提供了一定的逻辑独立性、能够对机密数据提供安全保护、适当的利用视图可以更清晰地表达查询语句

### 数据定义

| 操作对象 | 创建 | 删除 | 修改 |
| ---- | ---- | ---- | ---- |
| 模式 | `create schema` | `drop schema` | `/` |
| 表 | `create table` | `drop table` | `alter table` |
| 视图 | `create view` | `drop view` | `/` |
| 索引 | `create index` | `drop index` | `/` |

#### 创建、删除数据库

```sql
-- 创建samp_db数据库，并指定gbk字符集
create database samp_db character set gbk;
-- 删除samp_db数据库
drop database samp_db;
```

#### 创建、删除、修改基本表

创建基本表：指定表的关系模式
- 属性名
- 数据类型：`int`、`varchar`、`char`、`double`、`float`、`datetime`等
- 约束：主键（`auto_increment`）、非空（`not null`）等

```sql
create table student (
	id int auto_increment primary key,
	name varchar(50),
	sex varchar(20),
	edate varchar(50),
	content varchar(100)
) default charset=utf8;
```

删除基本表：

```sql
drop table student;
```

修改基本表：

```sql
-- 先定义数据表
create table test (
	id int not null auto_increment primary key,
	name varchar(20) not null default 'NoName',
	department_id int not null,
	position_id int not null,
	unique (department_id,position_id)
);

-- 修改表的名称
alter table test rename to test2;

-- 增加一个字段
alter table test add new_attr varchar(20);

-- 修改某个字段的名字
alter table test change name uname varchar(50);

-- 修改表内的某个字段
    -- 增加列tcol
alter table test add tcol char(10);
    -- 修改列tcol的属性
alter table test modify test char(20) not null;
    -- 修改列tcol默认值
alter table test alter tcol set default '123';
    -- 去除tcol默认值
alter table test alter tcol drop default;
    -- 删除列tcol
alter table test drop column tcol;
    -- 删除主键
alter table test drop primary key;
    -- 增加主键
alter table test add primary key pm_tcol (tcol2, tcol3);
```

#### 主键、外键

主键：可以唯一标识一个单独的行，具有唯一性。

外键：确保这一列的值有效（其值在另一个表存在且合法）。

#### 建立、删除索引

建立索引语法：

`create <unique> <cluster> index "index_name" on "table_name" ("col1" "seq1", ...)`。

含义：`unique`（每个索引值对应的数据记录唯一）、`cluster`（建立聚簇索引）

删除索引语法：

`drop index "index_name"`。

![[Pasted image 20240204003810.png]]

### 数据查询

一般语法：

```
select <all|distinct> "col1"<, "col2"<, "col3"> ...>
        from "table_name"<, "table_name_2"<, "table_name_3" ...>>
        <where "expression">
        <group by "query_col_1" having "expression">
        <order by "query_col_2" <asc|desc>>
```

#### 单表查询：where、orderby、groupby、聚集函数

查询语法：

```sql
create table test (
	id int primary key,
	name varchar(30) not null,
	age int not null
);

-- 根据列名选择若干列
select name, age from test;
-- 选择所有列
select * from test;
-- 根据列名表达式选择若干列
select name, 2024 - age from test;
-- 选择列的同时，指定别名
select name, 2024 - age as year_of_birt from test;
```

`select distinct`：选取若干不重复的行

`where`选择器：筛选符合特定条件的元组
- 比较条件：比较运算符`=`、`>`、`<`、`>=`、`<=`、`!=`、`<>`、`!>`、`!<`
- 确定范围条件：`BETWEEN...AND...`
- 确定集合条件：`IN...`
- 字符匹配条件：`LIKE...`
- 空值条件：`IS NULL`
- 多重条件组合：`AND`、`OR`、`NOT`

正则表达式：用于`IN`子句。
- 特殊符号：`%`匹配任意长度子串、`_`匹配单个字符、`[...]`匹配一个括号内字符、`[^...]`匹配一个非括号内字符。
- 匹配汉字：`gbk`字符集需要一个`_`，`ascii`字符集需要两个`_`

`order by`子句：按照一或多个属性升降序排列，*缺省升序*。

`group by`子句：将查询结果按某一列或多列的值分组，值相等的为一组，使得聚集函数可以细化到某一批元组上。

**聚集函数**：`distinct`和`all`可选，缺省为`all`。
- `count(*)`：统计元组个数
- `count(<distinct|all> col_name)`：统计一列中值的个数
- `sum(<distinct|all> col_name)`：计算一列值的总和（必须是数值列）
- `avg(<distinct|all> col_name)`：计算一列值的平均值（必须是数值列）
- `max(<distinct|all> col_name)`：计算一列的最大值
- `min(<distinct|all> col_name)`：计算一列的最小值

单表查询综合举例：

```sql
-- 查询学生总人数
select count(*) from student;
-- 查询计算机系小于20岁的所有学生姓名
select s_name from student where s_dept = 'CS' and s_age < 20;
-- 统计各系人数
select count(1) from student group by s_dept;
-- 统计平均成绩不低于90学生的各科均分
select s_no, avg(grade) from scores group by s_no having avg(grade) >= 90;
```

#### 连接查询：等值与非等值连接、自身连接、外连接、复合条件连接

连接查询：通过将多个数据表或视图连接实现联合查询。

等值连接：指定多个数据表的某几对属性值对等，返回连接结果。

非等值连接：指定多个数据表的某几对属性值满足某种非对等关系（小于、大于，等等），返回连接结果。

自身连接：参与连接的多个数据表中有相同数据表。

外连接：`outer join`，记录所有的公共属性值不合法的元组，登记其余值为`null`。

内连接：`inner join`，只记录公共属性值合法的元组。

左连接：`left join`，设`A,B`为连接的左右表，则左连接只记录`A`表中公共属性值不合法的元组，登记其余值为`null`。

右连接：`right join`，只记录`B`表中公共属性值不合法的元组，登记其余值为`null`。

举例：

```sql
-- 等值连接：生成导师和学生对接信息表
select mentor.name, stud.name from mentor, stud where mentor.id = stud.mentor_id;

-- 非等值连接：生成A,B中不同id的组合（实用性较低）
select distinct A.id, B.id from A, B where A.id != B.id;

-- 自身连接：查表中两列的匹配
select A.id2, B.id1 from my_tab A, my_tab B where A.id1 = B.id2;

-- 外连接：查居民和房产的匹配关系（MySQL不支持）
-- 居民可以没有房产，房产也可以没有居民
select civ.name, estate.addr from civ outer join estate on civ.estate_id = estate.id;

-- 左连接：查学生分数
-- 学生可以没有分数，但分数一定是某个学生的，不会单独存在
select stud.name, grade.chn, grade.math, grade.eng from stud left join grade on stud.id = grade.stud_id;

-- 右连接：调换上面的stud和grade，left改为right即可。
```

![[Pasted image 20240204172438.png]]

#### 嵌套查询

如下情形可能需要使用嵌套查询：
- 语句内的某个值是查询结果
- `select`语句查询的表是查询结果
- `where`子句的条件是`in...`
- `where`子句使用了`exists(...)`谓词
- `where`子句使用了`any(...)`、`some(...)`或`all(...)`谓词

```sql
SELECT * FROM alumni_info t WHERE EXISTS(SELECT a_id FROM alumni_education e WHERE e.a_id='6588' );
```

#### 集合查询

- `union`
- `intersect`
- `except`

### 数据更新

插入数据：`insert into "table_name" ("col1"<, "col2"<, "col3" ...>>) values ("const_1"<, "const_2"<, "const_3" ...>>);`

修改数据：`update "table_name" set "col_name1"="expr1"<, "col_name2"="expr2" ...> <where "condition">;`

删除数据：`delete from "table_name" <where "condition">;`

### 视图

`create view "view_name" <"col_name1"<, "col_name2"<, "col_name3" ...>>> as "query_name" <with check option>;`

## 数据库安全性

专有名词：
- 数据库管理员：拥有所有对象的所有权限，包括任意的用户授权
- 用户：拥有自己创建对象的所有操作权限，可以通过`grant`授予其他用户操作自己对象的权限
- 角色：数据库角色是权限的集合，每个角色代表一组相同权限用户。
- 审计：用审计日志（audit log）记录所有数据库操作，以便审计员监控数据库行为

**用户标识与鉴别**：由系统提供方式，使用户进入系统时核对身份，通过鉴定后提供使用权。例如：数据库用户和密码。

**存取控制**：
- 内容：定义用户权限、合法权限检查
- *自主存取控制*：同一用户对不同对象权限不同，不同用户对同一对象权限不同，用户可以转授自己的权限。
- *强制存取控制*：对数据库对象设置密级，用户设置许可证，只允许具有许可证的用户访问对应等级的资源。

**自主存取控制**（discretionary access control，DAC）：
- SQL格式：
	- 授权：`grant "permissions" on "object_type" "objects" to "users" <with grant option>;`
	- 撤销授权：`revoke "permissions" on "object_type" "objects" from "users" <cascade|restrict>;`
- 要求：
	- 权限为下表中某一种
	- 如果允许再授权，必须指定`with grant option`
	- 不允许循环授权，例如：T1->T2->T3->T4，则T4不能授权给T1

![[Pasted image 20240205005446.png]]

**强制存取控制**（mandatory access control，MAC）：
- 主体：系统中的活动实体，如实际用户、用户进程等
- 客体：系统中的被动实体，如视图、数据表、索引等
- *敏感度标记*：绝密（Top Secret）>=机密（Secret）>=秘密（Confidential）>=公开（Public）。主体的敏感度标记称作*许可证级别*（clearance level），客体的敏感度标记称作*密级*（classification level）。
- 方法：（主体）*向上写，向下读*。
	- 向上写：主体许可证级别不高于客体密级时，有写权限。因为高级主体有可能通过写低级客体泄密。
	- 向下读：主体许可证级别不低于客体密级时，有读权限。因为低级主体获取高级客体内容后可能泄密。

## 数据库完整性

数据库完整性：数据的正确性和相容性，防止数据库中存在不符合语义的数据
- 定义完整性约束条件的机制
- 完整性检查方法
- 违约处理

### 实体完整性

通过`primary key`定义：
- 列级约束：`id int primary key`
- 表级约束：`create table newtb (..., PRIMARY KEY(id))`

违约处理：当用户操作基本表时
- 检查主码值是否唯一，如不唯一则拒绝操作
- 检查主码各个属性是否为空，如不唯一则拒绝操作

### 参照完整性

通过`foreign key`短语定义，用`references(...)`短语指明这些外码参照哪些表的主码。

例如：

```sql
CREATE TABLE SC (
       Sno CHAR(9) NOT NULL,
       Cno CHAR(4) NOT NULL,
       Grade SMALLINT,
       PRIMARY KEY(Sno, Cno),
       FOREIGN KEY(Sno) REFERENCES Student(Sno),
       FOREIGN KEY(Cno) REFERENCES Course(Cno)  /*在表级定义参照完整性*/
);
```

违约检查：对参照表和被参照表增删改时

![[Pasted image 20240205012211.png]]

当不一致发生时，系统采用如下策略：
- 拒绝（no action）：默认策略，不允许操作执行
- 级联（cascade）：通过`on "action" cascade`设置。当删除或修改被参照表的一个元组导致与参照表（SC）的不一致时，删除或修改参照表中的所有导致不一致的元组
- 设置为空值：当删除或修改被参照表的一个元组时造成了不一致，则将参照表中所有造成不一致的元组的对应属性设置为空值

### 用户自定义完整性

属性上的自定义约束：`not null`、`unique`等。

元组上的自定义约束：`check(...)`子句，写在创建数据表声明的括号中，表明所有元组必须满足括号内的条件。

```sql
CREATE TABLE SC (
       Sno CHAR(9) NOT NULL,
       Cno CHAR(4) NOT NULL,
       Grade SMALLINT,
       PRIMARY KEY(Sno, Cno),
       CHECK(Sno='x' OR Cno NOT LIKE 'MS.%') -- 自定义约束
);
```

### 触发器

触发器：用户定义在关系表上的一类由事件驱动的特殊过程，其不仅可以用于数据库完整性检查，也可以用来实现数据库的其他功能，包括数据库安全性，以及一些业务流程和控制流程。

定义触发器：`create trigger "trigger_name" <before|after> "event" on "table" referencing <new|old> row as "variable" for each <row|statement> when "event" "trigger_body";`

定义要点：
- 限制：只有表的创建者才能在表上创建触发器，触发器名称唯一，数量有限，只能定义在基本表上，不能定义在视图上。
- 触发事件：可以是`insert`、`delete`或`update`，也可以是事件的组合，如`insert or delete`等，也可以指定哪些列的操作会触发，如`update of id, name`等。
- 触发时机：`before`表示在事件发生前触发，`after`表示在事件发生后触发。
- 触发器类型：`for each row`为行级触发器，对表内每行触发一次，`for each statement`为语句触发器，对每个操作触发一次
- 触发条件：如果指定了触发条件`when`，则只有触发条件为真时，才执行触发动作体。
- 触发动作体：描述触发的具体行为，用一对`begin...end`包裹。

例：

```sql
create trigger insert_or_update_salary
	before insert or update on teacher
	for each row
	as begin
		if (new.job = 'professor') and (new.salary < 4000) then
			new.salary := 4000;
		end if;
	end;
```

删除触发器：`drop trigger "trigger_name" on "table_name";`

## 关系数据库理论

**数据依赖**：一个关系内部属性与属性之间的约束关系，其中最重要的是*函数依赖*（functional dependency，FD）和*多值依赖*（multivalued dependency，MVD）

一个不太好的关系模式会引入如下问题：
- 数据冗余：信息重复存储，浪费存储空间
- 更新异常：重复信息的一个副本被修改，所有副本必须同时修改，增大修改代价
- 插入异常：只有一些信息已经存在时，另一些信息才能存入
- 删除异常：删除某些信息可能导致其他信息的丢失

### 规范化

规范化理论：改造关系模式，通过分解消除不合适的数据依赖

定义：
- **关系模式**（relationship schema）：$R(U)$是属性集$U$上的关系模式。
- **函数依赖**（functional dependency）：设属性集$X,Y,U$满足$X,Y\subseteq U$，若对于$R(U)$上任意一个可能的关系$r$，$r$中*不存在*两个元组在$X$中的值相等，在$Y$中的值不相等，则称$Y$函数依赖于$X$（或$X$函数确定$Y$），记作$X\rightarrow Y$。（人话：存在集合$X\rightarrow Y$的映射）

函数依赖举例：设属性集`U=(s_no,s_name,s_sex,s_age,s_dept)`：
- 对于属性组`(s_no,s_name)`，如果存在元组`(1,'Li Ming')`和`(1, 'Li Hua')`，那么`s_no->s_name`的函数依赖关系便不成立。
- 当且仅当对任意的`s_no_1!=s_no_2`，都有`s_name_1!=s_name_2`，才能称`s_no->s_name`。

函数依赖的部分性、完全性和传递性：
- **完全函数依赖**：若存在函数依赖$X\rightarrow Y$，且$Y$依赖于$X$的所有属性，缺一不可，则称$X\rightarrow Y$为完全函数依赖，记作$X\overset{F}{\rightarrow} Y$。
- **部分函数依赖**：若存在函数依赖$X\rightarrow Y$，且$Y$只依赖于$X$的部分属性，则称$X\rightarrow Y$为部分函数依赖，记作$X\overset{P}{\rightarrow} Y$。
- **传递函数依赖**：若存在函数依赖$X\rightarrow Y,Y\rightarrow Z$，则$X\rightarrow Z$也成立，称这种函数依赖为传递函数依赖。

关于上面概念的一个生动例子：查学生成绩必须要学生ID和课程ID两个属性，但查学生院系只需要学生ID。因此学生ID、课程ID到成绩属于完全函数依赖，而到学生院系属于部分函数依赖。

### 1NF

**第一范式**（the 1st normal form，1NF）：属性集内的任意属性不可分，即没有子属性，是原子值（`int`、`varchar`等）。

意义：第一范式是关系数据库的最基本要求，不满足第一范式的数据库模式不是关系数据库。

例子：`address`不是一个原子属性，因此应当拆分为省、市、街道。

![[Pasted image 20240205172957.png]]

### 2NF

**第二范式**（the 2nd normal form，2NF）：在第一范式基础上，每一个非主属性都*完全函数依赖*于任何一个候选码。

目的：将只*部分函数依赖*于候选码（依赖于部分而非所有属性）的非主属性转移到其他表中。

例子：关系`Grade(Sno, Cno, Sdept, Sloc)`不符合第二范式，因为`Sdept,Sloc`仅依赖于`Sno`，而不依赖同为候选码属性的`Cno`。因此应当拆分出一个关系`(Sno,Sdept,Sloc)`。

意义：消除了数据冗余和其他的一些异常，但没有消除传递依赖问题（在3NF中解决）。

![[Pasted image 20240205174805.png]]

![[Pasted image 20240205174811.png]]

### 3NF

**第三范式**（the 3rd normal form）：在2NF基础上，要求每一个非主属性既不*部分依赖*于码也不*传递依赖*于码。（人话：要么干脆不依赖，要么就直接全部依赖）

目的：去除不直接依赖于候选码的非主属性

投影分解法：一种分解关系模式，使其从符合2NF变为符合3NF。详见[[#补充：关系数据理论]]。

举例：在属性集`(Sno,Sdept,Sloc)`中，`Sno->Sdept`和`Sdept->Sloc`都成立，那么这时都包含在一个表就不是最好选项，最好方法是拆成`(Sno,Sdept)`和`(Sdept,Sloc)`两个表。

### BCNF

**修正第三范式**（又称Boyce-Codd范式，BCNF）：满足如下条件：
- 所有非主属性都完全函数依赖于每个候选码
- 所有的主属性都完全函数依赖于每个不包含它的候选码
- 没有任何属性完全函数依赖于非码的任何一组属性

（人话：非主属性互不依赖，主属性间层次分明）

意义：相较3NF，排除了任何属性对候选码的部分依赖和传递依赖，以及主属性之间的传递依赖。

![[Pasted image 20240206020217.png]]

## 数据库设计

数据库设计：6个阶段
- 需求分析：准确了解和分析用户需求
- 概念结构设计：通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型
- 逻辑结构设计：将概念结构转换为某个DBMS所支持的数据模型，并对其进行优化
- 物理结构设计：为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）
- 数据库实施：根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库并试运行
- 数据库运行和维护：在数据库投入正式使用后不断地对其进行评价、调整与修改

### 需求分析

需求分析完成的两个任务：数据流程图（dataflow diagram，DFD）、数据字典

数据字典：包括如下5个部分


## 关系查询处理、查询优化

## 数据库恢复技术

## 并发控制概述

## 补充：关系数据理论